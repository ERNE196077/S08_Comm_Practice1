ANSI-C/cC++ Compiler for HC08 V-5.0.45 Build 14019, Jan 20 2014

    1:  /*****************************************************************************
    2:  * Timer implementation.
    3:  *
    4:  * Copyright (c) 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "EmbeddedTypes.h"
   14:  #include "IrqControlLib.h"
   15:  #include "TS_Interface.h"
   16:  #include "TMR_Interface.h"
   17:  #include "Timer.h"
   18:  #include "FunctionLib.h"
   19:  
   20:  /*****************************************************************************
   21:  ******************************************************************************
   22:  * Private macros
   23:  ******************************************************************************
   24:  *****************************************************************************/
   25:  
   26:  
   27:  /* Number of elements in an array. */
   28:  #define NumberOfElements(array)   ((sizeof(array) / (sizeof(array[0]))))
   29:  
   30:  /* Timer status. If none of these flags are on, the timer is not allocated.
   31:  * For allocated timers, exactly one of these flags will be set.
   32:  * mTmrStatusActive_c   Timer has been started and has not yet expired.
   33:  * mTmrStatusReady_c    TMR_StartTimer() has been called for this timer, but
   34:  *                      the timer task has not yet actually started it. The
   35:  *                      timer is considered to be active.
   36:  * mTmrStatusInactive_c Timer is allocated, but is not active.
   37:  */
   38:  typedef uint8_t tmrStatus_t;
   39:  #define mTmrStatusFree_c        0
   40:  #define mTmrStatusActive_c      0x20
   41:  #define mTmrStatusReady_c       0x40
   42:  #define mTmrStatusInactive_c    0x80
   43:  
   44:  #define mTimerStatusMask_c      ( mTmrStatusActive_c \
   45:                                  | mTmrStatusReady_c \
   46:                                  | mTmrStatusInactive_c)
   47:  
   48:  /* If all bits in the status byte are zero, the timer is free. */
   49:  #define TMR_IsTimerAllocated(timerID)   (maTmrTimerStatusTable[(timerID)])
   50:  #define TMR_MarkTimerFree(timerID)       (maTmrTimerStatusTable[(timerID)] = mTmrStatusFree_c)
   51:  
   52:  #define mTimerType_c            ( gTmrSingleShotTimer_c \
   53:                                   | gTmrSetSecondTimer_c \
   54:                                   | gTmrSetMinuteTimer_c \
   55:                                   | gTmrIntervalTimer_c \
   56:                                   | gTmrLowPowerTimer_c )
   57:                                
   58:  
   59:  /* TMR_Task() event flag. Only one event is needed. */
   60:  #define mTMR_Event_c    ( 1 << 0 )
   61:  
   62:  /* One minute in milliseconds */
   63:  #define mOneMinute_c 60000
   64:  /* One second in milliseconds */
   65:  #define mOneSecond_c 1000
   66:  
   67:  /* Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that the currentTimeInTicks 
   68:  will never roll over previousTimeInTicks in the TMR_Task(); 
   69:  A task have to be executed at most in 4 ms  */
   70:  #define mMaxToCountDown_c (0x7FFF - TmrTicksFromMilliseconds(8))
   71:  
   72:  /* 4ms in ticks (for different source clocks).
   73:     It's assumed that a task is executed in 4 ms; */
   74:  /* Compensate for the real TMR clock (4.096ms) */
   75:  #define m4msTicks_c   ((TmrTicksFromMilliseconds(5) == 0) ? 1 : TmrTicksFromMilliseconds(5))
   76:  
   77:  /* Detect the timer type */                                          
   78:  #define IsMinuteTimer(type)  (((type) & gTmrMinuteTimer_c) == gTmrMinuteTimer_c)
   79:  #define IsSecondTimer(type)  (((type) & gTmrSecondTimer_c) == gTmrSecondTimer_c)                                         
   80:  #define IsLowPowerTimer(type)  ((type) & gTmrLowPowerTimer_c)
   81:  #define IsLowPowerMinuteTimer(type)  (((type) & gTmrLowPowerMinuteTimer_c) == gTmrLowPowerMinuteTimer_c)
   82:  #define IsLowPowerSecondTimer(type)  (((type) & gTmrLowPowerSecondTimer_c) == gTmrLowPowerSecondTimer_c)
   83:  #define IsLowPowerSingleShotMillisTimer(type)  (((type) & gTmrLowPowerSingleShotMillisTimer_c) \
   84:                                                    == gTmrLowPowerSingleShotMillisTimer_c)
   85:  #define IsLowPowerIntervalMillisTimer(type)  (((type) & gTmrLowPowerIntervalMillisTimer_c) \
   86:                                                    == gTmrLowPowerIntervalMillisTimer_c)
   87:  
   88:  /* Transform ticks to milliseconds
   89:     Is assumed that 1 tick has at least 1ms...
   90:  */
   91:  #define TmrMillisecondsFromTicks(ticks) ((uint32_t)((uint16_t)mOneSecond_c/TmrTicksForOneSecond()) * (uint32_t)(ticks))
   92:  
   93:   
   94:  /*****************************************************************************
   95:  ******************************************************************************
   96:  * Private type definitions
   97:  ******************************************************************************
   98:  *****************************************************************************/
   99:  
  100:  /* Used to read 16 bit hardware registers. */
  101:  typedef union read16bitReg_tag {
  102:    uint16_t wordAccess;
  103:    uint8_t  byteAccess[2];
  104:  } read16bitReg_t;
  105:  
  106:  /* One entry in the main timer table.
  107:  * intervalInTicks      The timer's original duration, in ticks. Used to reset
  108:  *                      intervnal timers.
  109:  * countDown            When a timer is started, this is set to the duration.
  110:  *                      The timer task decrements this value. When it reaches
  111:  *                      zero, the timer has expired.
  112:  */
  113:  typedef struct tmrTimerTableEntry_tag {
  114:    tmrTimerTicks_t intervalInTicks;
  115:    tmrTimerTicks_t countDown;
  116:    pfTmrCallBack_t pfCallBack;
  117:  } tmrTimerTableEntry_t;
  118:  
  119:  /* The status and type are bitfields, to save RAM. This costs some code */
  120:  /* space, though. */
  121:  typedef uint8_t tmrTimerStatus_t;
  122:  
  123:  /*****************************************************************************
  124:  ******************************************************************************
  125:  * Private prototypes
  126:  ******************************************************************************
  127:  *****************************************************************************/
  128:  
  129:  static tmrStatus_t TMR_GetTimerStatus(tmrTimerID_t timerID);
  130:  static void TMR_SetTimerStatus(tmrTimerID_t timerID, tmrStatus_t status);
  131:  static tmrTimerType_t TMR_GetTimerType(tmrTimerID_t timerID);
  132:  static void TMR_SetTimerType(tmrTimerID_t timerID, tmrTimerType_t type);
  133:  
  134:  /*****************************************************************************
  135:  ******************************************************************************
  136:  * Private memory declarations
  137:  ******************************************************************************
  138:  *****************************************************************************/
  139:  
  140:  /* Main timer table. All allocated timers are stored here. A timer's ID */
  141:  /* is it's index in this table. */
  142:  static tmrTimerTableEntry_t maTmrTimerTable[gTmrTotalTimers_c];
  143:  
  144:  /* Making the single-byte-per-timer status table a separate array saves */
  145:  /* a bit of code space. If an entry is == 0, the timer is not allocated. */
  146:  static tmrStatus_t maTmrTimerStatusTable[gTmrTotalTimers_c];
  147:  
  148:  /* Number of Active timers (without low power capability)
  149:     the MCU can not enter low power if numberOfActiveTimers!=0 */
  150:  static uint8_t numberOfActiveTimers = 0;
  151:  /* Number of low power active timer 
  152:     The MCU can enter in low power if more low power timers are active */
  153:  static uint8_t numberOfLowPowerActiveTimers = 0;
  154:  
  155:  #define IncrementActiveTimerNumber(type)  ((type & gTmrLowPowerTimer_c) \
  156:                                            ?(++numberOfLowPowerActiveTimers) \
  157:                                            :(++numberOfActiveTimers) )                                   
  158:  #define DecrementActiveTimerNumber(type)  ((type & gTmrLowPowerTimer_c) \
  159:                                            ?(--numberOfLowPowerActiveTimers) \
  160:                                            :(--numberOfActiveTimers) ) 
  161:  
  162:  /* Used to access 16 bit hardware registers. */
  163:  static read16bitReg_t mTmrRead16bitReg;
  164:  
  165:  /* No other code should ever post an event to the timer task. */
  166:  static tsTaskID_t gTimerTaskID;
  167:  
  168:  /* The previous time in ticks when the counter register was read */
  169:  static uint16_t previousTimeInTicks = 0;
  170:  /* Flag if the hardware timer is running or not*/
  171:  static bool_t timerHardwareIsRunning = FALSE;
  172:  
  173:  /*****************************************************************************
  174:  ******************************************************************************
  175:  * Public functions
  176:  ******************************************************************************
  177:  *****************************************************************************/
  178:  
  179:  /* Initialize the timer module. */
  180:  void TMR_Init
  181:  (
  182:  void
  183:  )
  184:  {
  185:    /* Configure a TPM channel: enable interrupts; set output compare mode. */
  186:    gTPMxCnSC_c = (gTPMxCnSC_IE_c | gTPMxCnSC_MSA_c);
  0000 6e500d   [4]             MOV   #80,13
  187:    
  188:    gTimerTaskID = TS_CreateTask(gTsTimerTaskPriority_c, TMR_Task);
  0003 a6fe     [2]             LDA   #-2
  0005 87       [2]             PSHA  
  0006 450000   [3]             LDHX  @TMR_Task
  0009 89       [2]             PSHX  
  000a 8b       [2]             PSHH  
  000b a600     [2]             LDA   @TMR_Task:PAGE
  000d 87       [2]             PSHA  
  000e ac000000 [8]             CALL  TS_CreateTask
  0012 a704     [2]             AIS   #4
  0014 c70000   [4]             STA   gTimerTaskID
  189:  }                                       /* TMR_Init() */
  0017 8d       [7]             RTC   
  190:  
  191:  /****************************************************************************/
  192:  
  193:  /* Allocate a timer.
  194:  * Returns the timer id, or gTmrInvalidTimerID_c if the timer table is full.
  195:  */
  196:  tmrTimerID_t TMR_AllocateTimer
  197:  (
  198:  void
  199:  )
  200:  {
  201:    index_t i;
  202:    
  203:    for (i = 0; i < NumberOfElements(maTmrTimerTable); ++i) {
  0000 5f       [1]             CLRX  
  0001          L1:     
  204:      if (!TMR_IsTimerAllocated(i)) {
  0001 8c       [1]             CLRH  
  0002 d60000   [4]             LDA   @maTmrTimerStatusTable,X
  0005 2609     [3]             BNE   L10 ;abs = 0010
  205:        TMR_SetTimerStatus(i, mTmrStatusInactive_c);
  0007 89       [2]             PSHX  
  0008 a680     [2]             LDA   #-128
  000a ac000000 [8]             CALL  TMR_SetTimerStatus
  206:        return i;
  000e 86       [3]             PULA  
  000f 8d       [7]             RTC   
  0010          L10:    
  0010 5c       [1]             INCX  
  0011 a322     [2]             CPX   #34
  0013 25ec     [3]             BCS   L1 ;abs = 0001
  207:      }
  208:    }
  209:    
  210:    /* Out of timers. Assert. */
  211:  #if gTMR_Debug_d
  212:    BeeAppAssert(gAssertCode_NoTimers_c);
  0015 a602     [2]             LDA   #2
  0017 ac000000 [8]             CALL  BeeAppAssert
  213:  #endif
  214:    return gTmrInvalidTimerID_c;
  001b a6ff     [2]             LDA   #-1
  215:  }                                       /* TMR_AllocateTimer() */
  001d 8d       [7]             RTC   
  216:  
  217:  
  218:  /*****************************************************************************/
  219:  
  220:  /* Return true if there are no active timers (without low power capability); 
  221:     return FALSE otherwise. */
  222:  bool_t TMR_AreAllTimersOff
  223:  (
  224:  void
  225:  )
  226:  {
  227:    return !numberOfActiveTimers;
  0000 c60000   [4]             LDA   numberOfActiveTimers
  0003 2702     [3]             BEQ   L7 ;abs = 0007
  0005 4f       [1]             CLRA  
  0006 8d       [7]             RTC   
  0007          L7:     
  0007 a601     [2]             LDA   #1
  228:  }                                       /* TMR_AreAllTimersOff() */
  0009 8d       [7]             RTC   
  229:  
  230:  /****************************************************************************/
  231:  
  232:  /* Free any timer. Harmless if the timer is already free. */
  233:  void TMR_FreeTimer
  234:  (
  235:  tmrTimerID_t timerID
  236:  )
  237:  {
  238:    TMR_StopTimer(timerID);
  0000 87       [2]             PSHA  
  0001 ac000000 [8]             CALL  TMR_StopTimer
  239:    TMR_MarkTimerFree(timerID);
  0005 8c       [1]             CLRH  
  0006 88       [3]             PULX  
  0007 4f       [1]             CLRA  
  0008 d70000   [4]             STA   @maTmrTimerStatusTable,X
  240:  }                                       /* TMR_FreeTimer() */
  000b 8d       [7]             RTC   
  241:  
  242:  /****************************************************************************/
  243:  /* Place it in NON_BANKED memory */
  244:  #ifdef MEMORY_MODEL_BANKED
  245:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
  246:  #else
  247:  #pragma CODE_SEG DEFAULT
  248:  #endif /* MEMORY_MODEL_BANKED */
  249:  /* Timer ISR. */
  250:  INTERRUPT_KEYWORD void TMR_InterruptHandler(void) {
  0000 8b       [2]             PSHH  
  251:    __asm {                               /* The HCS08 does not save H on interrupt. */
  252:      PSHH
  0001 8b       [2]             PSHH  
  253:    }
  254:      
  255:    /* Clearing the overflow flag requires reading it and then writing it. */
  256:    if ( gTPMxCnSC_c & gTPMxCnSC_F_c ) {
  0002 0f0d0c   [5]             BRCLR 7,13,L11 ;abs = 0011
  257:      gTPMxCnSC_c &= ~gTPMxCnSC_F_c;
  0005 1f0d     [5]             BCLR  7,13
  258:      TS_SendEvent(gTimerTaskID, mTMR_Event_c);
  0007 c60000   [4]             LDA   gTimerTaskID
  000a ae01     [2]             LDX   #1
  000c 8c       [1]             CLRH  
  000d ac000000 [8]             CALL  TS_SendEvent
  0011          L11:    
  259:    }
  260:    
  261:    __asm {
  262:      PULH
  0011 8a       [3]             PULH  
  263:    }
  264:  }                                       /* TMR_InterruptHandler() */
  0012 8a       [3]             PULH  
  0013 80       [9]             RTI   
  265:  #pragma CODE_SEG DEFAULT
  266:  /*****************************************************************************/
  267:  
  268:  
  269:  /* Return TRUE if the timer is active. */
  270:  bool_t TMR_IsTimerActive
  271:  (
  272:  tmrTimerID_t timerID
  273:  )
  274:  {
  275:    return TMR_GetTimerStatus(timerID) == mTmrStatusActive_c;
  0000 ac000000 [8]             CALL  TMR_GetTimerStatus
  0004 412002   [4]             CBEQA #32,L9 ;abs = 0009
  0007 4f       [1]             CLRA  
  0008 8d       [7]             RTC   
  0009          L9:     
  0009 a601     [2]             LDA   #1
  276:  }                                       /* TMR_IsTimerActive() */
  000b 8d       [7]             RTC   
  277:  
  278:  /****************************************************************************/
  279:  
  280:  /****************************************************************************
  281:  *
  282:  * Start a timer (BeeStack or application). When the timer goes off, call
  283:  * the callback function in non-interrupt context.
  284:  *
  285:  *****************************************************************************/
  286:  void TMR_StartTimer
  287:  (
  288:  tmrTimerID_t timerID,                       /* IN: */
  289:  tmrTimerType_t timerType,                   /* IN: */
  290:  tmrTimeInMilliseconds_t timeInMilliseconds, /* IN: */
  291:  void (*pfTimerCallBack)(tmrTimerID_t)       /* IN: */
  292:  )
  293:  {
  0000 a7fc     [2]             AIS   #-4
  294:    tmrTimerTicks_t intervalInTicks;
  295:    tmrTimerTableEntry_t *currentTimer = &maTmrTimerTable[timerID];
  0002 95       [2]             TSX   
  0003 e60f     [3]             LDA   15,X
  0005 ae07     [2]             LDX   #7
  0007 42       [5]             MUL   
  0008 ab00     [2]             ADD   @maTmrTimerTable
  000a 87       [2]             PSHA  
  000b 4f       [1]             CLRA  
  000c a900     [2]             ADC   @maTmrTimerTable:MSB
  000e 87       [2]             PSHA  
  000f 8a       [3]             PULH  
  0010 88       [3]             PULX  
  0011 9eff03   [5]             STHX  3,SP
  296:    
  297:    /* Stopping an already stopped timer is harmless. */
  298:    TMR_StopTimer(timerID);
  0014 95       [2]             TSX   
  0015 e60f     [3]             LDA   15,X
  0017 ac000000 [8]             CALL  TMR_StopTimer
  299:    /* if it's a minute/second timer .intervalInTicks will count down the minutes/seconds
  300:       and .countDown is initialized with ticks for one minute/second */
  301:    
  302:  #if gTMR_EnableMinutesSecondsTimers_d
  303:    if (IsMinuteTimer(timerType)) 
  001b 95       [2]             TSX   
  001c e60e     [3]             LDA   14,X
  001e a406     [2]             AND   #6
  0020 a106     [2]             CMP   #6
  0022 2614     [3]             BNE   L38 ;abs = 0038
  304:    {
  305:       currentTimer->intervalInTicks = (uint16_t)timeInMilliseconds;
  0024 9efe03   [5]             LDHX  3,SP
  0027 9ee60d   [4]             LDA   13,SP
  002a f7       [2]             STA   ,X
  002b 9ee60e   [4]             LDA   14,SP
  002e e701     [3]             STA   1,X
  306:       currentTimer->countDown = TmrTicksForOneMinute();
  0030 a639     [2]             LDA   #57
  0032 e702     [3]             STA   2,X
  0034 a630     [2]             LDA   #48
  307:    } 
  0036 2053     [3]             BRA   L8B ;abs = 008b
  0038          L38:    
  308:    else 
  309:    {  
  310:      if (IsSecondTimer(timerType)) 
  0038 e60e     [3]             LDA   14,X
  003a a40a     [2]             AND   #10
  003c a10a     [2]             CMP   #10
  003e 2612     [3]             BNE   L52 ;abs = 0052
  311:      {
  312:        currentTimer->intervalInTicks = (uint16_t)timeInMilliseconds;
  0040 9efe03   [5]             LDHX  3,SP
  0043 9ee60d   [4]             LDA   13,SP
  0046 f7       [2]             STA   ,X
  0047 9ee60e   [4]             LDA   14,SP
  004a e701     [3]             STA   1,X
  313:        currentTimer->countDown = TmrTicksForOneSecond();
  004c 6f02     [5]             CLR   2,X
  004e a6f4     [2]             LDA   #-12
  314:      } 
  0050 2039     [3]             BRA   L8B ;abs = 008b
  0052          L52:    
  315:        else 
  316:  #endif     /* gTMR_EnableMinutesSecondsTimers_d */
  317:         { 
  318:         /* here, the timer is single shot or interval in milliseconds*/
  319:          intervalInTicks = TmrTicksFromMilliseconds(timeInMilliseconds);
  0052 af0a     [2]             AIX   #10
  0054 cd0000   [6]             JSR   _LMUL_RC
  0057 00000139         DC.L  313
  005b 95       [2]             TSX   
  005c cd0000   [6]             JSR   _LDIVU_RC
  005f 00000500         DC.L  1280
  0063 95       [2]             TSX   
  0064 e602     [3]             LDA   2,X
  0066 87       [2]             PSHA  
  0067 ee03     [3]             LDX   3,X
  0069 8a       [3]             PULH  
  006a 9eff09   [5]             STHX  9,SP
  320:          if (!intervalInTicks) 
  006d a708     [2]             AIS   #8
  006f 2606     [3]             BNE   L77 ;abs = 0077
  321:             intervalInTicks = 1;
  0071 ae01     [2]             LDX   #1
  0073 8c       [1]             CLRH  
  0074 9eff01   [5]             STHX  1,SP
  0077          L77:    
  322:        
  323:          currentTimer->intervalInTicks = intervalInTicks;
  0077 9efe03   [5]             LDHX  3,SP
  007a 9ee601   [4]             LDA   1,SP
  007d f7       [2]             STA   ,X
  007e 9ee602   [4]             LDA   2,SP
  0081 e701     [3]             STA   1,X
  324:          currentTimer->countDown = intervalInTicks;
  0083 9ee601   [4]             LDA   1,SP
  0086 e702     [3]             STA   2,X
  0088 9ee602   [4]             LDA   2,SP
  008b          L8B:    
  008b e703     [3]             STA   3,X
  325:         }
  326:  #if gTMR_EnableMinutesSecondsTimers_d       
  327:    }/* end else... if (timerType == gTmrMinuteTimer_c)... */
  328:  #endif  /* gTMR_EnableMinutesSecondsTimers_d */
  329:    
  330:    
  331:    TMR_SetTimerType(timerID, timerType);
  008d 95       [2]             TSX   
  008e ee0f     [3]             LDX   15,X
  0090 9ee60f   [4]             LDA   15,SP
  0093 ac000000 [8]             CALL  TMR_SetTimerType
  332:    
  333:    currentTimer->pfCallBack = pfTimerCallBack;
  0097 9efe03   [5]             LDHX  3,SP
  009a 9ee608   [4]             LDA   8,SP
  009d e704     [3]             STA   4,X
  009f 9ee609   [4]             LDA   9,SP
  00a2 e705     [3]             STA   5,X
  00a4 9ee60a   [4]             LDA   10,SP
  00a7 e706     [3]             STA   6,X
  334:    
  335:    /* Enable timer, the timer task will do the rest of the work. */
  336:    TMR_EnableTimer(timerID);
  00a9 95       [2]             TSX   
  00aa e60f     [3]             LDA   15,X
  00ac ac000000 [8]             CALL  TMR_EnableTimer
  337:  }                                       /* TMR_StartTimer() */
  00b0 a704     [2]             AIS   #4
  00b2 8d       [7]             RTC   
  338:  
  339:  /* Start a low power timer. When the timer goes off, call the callback function */
  340:  /* in non-interrupt context. If the timer is running when this function */
  341:  /* is called, it will be stopped and restarted. */
  342:  /* Start the timer with the following timer types:
  343:     gTmrLowPowerMinuteTimer_c
  344:     gTmrLowPowerSecondTimer_c
  345:     gTmrLowPowerSingleShotMillisTimer_c
  346:     gTmrLowPowerIntervalMillisTimer_c
  347:  */
  348:  /* The MCU can enter in low power if there are only active low power timers */
  349:  void TMR_StartLowPowerTimer
  350:  (
  351:  tmrTimerID_t timerId,
  352:  tmrTimerType_t timerType,
  353:  uint32_t timeIn,
  354:  void (*pfTmrCallBack)(tmrTimerID_t)
  355:  ) 
  356:  {
  357:  
  358:  TMR_StartTimer(timerId, timerType | gTmrLowPowerTimer_c, timeIn, pfTmrCallBack);
  0000 95       [2]             TSX   
  0001 e60a     [3]             LDA   10,X
  0003 aa10     [2]             ORA   #16
  0005 ee0b     [3]             LDX   11,X
  0007 89       [2]             PSHX  
  0008 87       [2]             PSHA  
  0009 9efe0b   [5]             LDHX  11,SP
  000c 89       [2]             PSHX  
  000d 8b       [2]             PSHH  
  000e 9efe0b   [5]             LDHX  11,SP
  0011 89       [2]             PSHX  
  0012 8b       [2]             PSHH  
  0013 9efe0b   [5]             LDHX  11,SP
  0016 89       [2]             PSHX  
  0017 8b       [2]             PSHH  
  0018 95       [2]             TSX   
  0019 e60b     [3]             LDA   11,X
  001b 87       [2]             PSHA  
  001c ac000000 [8]             CALL  TMR_StartTimer
  0020 a709     [2]             AIS   #9
  359:  
  360:  }
  0022 8d       [7]             RTC   
  361:  
  362:  #if gTMR_EnableMinutesSecondsTimers_d
  363:  /* Start a minute timer. */
  364:  /* Note: this is a single shot timer. There are no interval minute timers. */
  365:  void TMR_StartMinuteTimer
  366:  (
  367:  tmrTimerID_t timerId, 
  368:  tmrTimeInMinutes_t timeInMinutes, 
  369:  void (*pfTmrCallBack)(tmrTimerID_t)
  370:  )
  371:  {
  372:   TMR_StartTimer(timerId, gTmrMinuteTimer_c, timeInMinutes, pfTmrCallBack);
  0000 95       [2]             TSX   
  0001 e608     [3]             LDA   8,X
  0003 87       [2]             PSHA  
  0004 a606     [2]             LDA   #6
  0006 87       [2]             PSHA  
  0007 9efe09   [5]             LDHX  9,SP
  000a 89       [2]             PSHX  
  000b 8b       [2]             PSHH  
  000c 4f       [1]             CLRA  
  000d 87       [2]             PSHA  
  000e 87       [2]             PSHA  
  000f 9efe0b   [5]             LDHX  11,SP
  0012 89       [2]             PSHX  
  0013 8b       [2]             PSHH  
  0014 95       [2]             TSX   
  0015 e60b     [3]             LDA   11,X
  0017 87       [2]             PSHA  
  0018 ac000000 [8]             CALL  TMR_StartTimer
  001c a709     [2]             AIS   #9
  373:  }
  001e 8d       [7]             RTC   
  374:  #endif /* gTMR_EnableMinutesSecondsTimers_d */
  375:  
  376:  
  377:  #if gTMR_EnableMinutesSecondsTimers_d  
  378:  /* Start a second timer. */
  379:  /* Note: this is a single shot timer. There are no interval second timers. */
  380:  void TMR_StartSecondTimer
  381:  (
  382:  tmrTimerID_t timerId, 
  383:  tmrTimeInSeconds_t timeInSeconds, 
  384:  void (*pfTmrCallBack)(tmrTimerID_t)
  385:  ) 
  386:  {
  387:   TMR_StartTimer(timerId, gTmrSecondTimer_c, timeInSeconds, pfTmrCallBack);
  0000 95       [2]             TSX   
  0001 e608     [3]             LDA   8,X
  0003 87       [2]             PSHA  
  0004 a60a     [2]             LDA   #10
  0006 87       [2]             PSHA  
  0007 9efe09   [5]             LDHX  9,SP
  000a 89       [2]             PSHX  
  000b 8b       [2]             PSHH  
  000c 4f       [1]             CLRA  
  000d 87       [2]             PSHA  
  000e 87       [2]             PSHA  
  000f 9efe0b   [5]             LDHX  11,SP
  0012 89       [2]             PSHX  
  0013 8b       [2]             PSHH  
  0014 95       [2]             TSX   
  0015 e60b     [3]             LDA   11,X
  0017 87       [2]             PSHA  
  0018 ac000000 [8]             CALL  TMR_StartTimer
  001c a709     [2]             AIS   #9
  388:  }
  001e 8d       [7]             RTC   
  389:  #endif /* gTMR_EnableMinutesSecondsTimers_d */
  390:   
  391:  /****************************************************************************/
  392:  
  393:  void TMR_StartIntervalTimer
  394:  (
  395:  tmrTimerID_t timerID,
  396:  tmrTimeInMilliseconds_t timeInMilliseconds,
  397:  void (*pfTimerCallBack)(tmrTimerID_t)
  398:  )
  399:  {
  400:    TMR_StartTimer(timerID, gTmrIntervalTimer_c, timeInMilliseconds, pfTimerCallBack);
  0000 95       [2]             TSX   
  0001 e60a     [3]             LDA   10,X
  0003 87       [2]             PSHA  
  0004 a602     [2]             LDA   #2
  0006 87       [2]             PSHA  
  0007 9efe0b   [5]             LDHX  11,SP
  000a 89       [2]             PSHX  
  000b 8b       [2]             PSHH  
  000c 9efe0b   [5]             LDHX  11,SP
  000f 89       [2]             PSHX  
  0010 8b       [2]             PSHH  
  0011 9efe0b   [5]             LDHX  11,SP
  0014 89       [2]             PSHX  
  0015 8b       [2]             PSHH  
  0016 95       [2]             TSX   
  0017 e60b     [3]             LDA   11,X
  0019 87       [2]             PSHA  
  001a ac000000 [8]             CALL  TMR_StartTimer
  001e a709     [2]             AIS   #9
  401:  }
  0020 8d       [7]             RTC   
  402:  
  403:  void TMR_StartSingleShotTimer
  404:  (
  405:  tmrTimerID_t timerID,
  406:  tmrTimeInMilliseconds_t timeInMilliseconds,
  407:  void (*pfTimerCallBack)(tmrTimerID_t)
  408:  )
  409:  {
  410:    TMR_StartTimer(timerID, gTmrSingleShotTimer_c, timeInMilliseconds, pfTimerCallBack);
  0000 95       [2]             TSX   
  0001 e60a     [3]             LDA   10,X
  0003 87       [2]             PSHA  
  0004 a601     [2]             LDA   #1
  0006 87       [2]             PSHA  
  0007 9efe0b   [5]             LDHX  11,SP
  000a 89       [2]             PSHX  
  000b 8b       [2]             PSHH  
  000c 9efe0b   [5]             LDHX  11,SP
  000f 89       [2]             PSHX  
  0010 8b       [2]             PSHH  
  0011 9efe0b   [5]             LDHX  11,SP
  0014 89       [2]             PSHX  
  0015 8b       [2]             PSHH  
  0016 95       [2]             TSX   
  0017 e60b     [3]             LDA   11,X
  0019 87       [2]             PSHA  
  001a ac000000 [8]             CALL  TMR_StartTimer
  001e a709     [2]             AIS   #9
  411:  }
  0020 8d       [7]             RTC   
  412:  
  413:  /****************************************************************************/
  414:  
  415:  /* Stop a timer. Does not free the timer; does not call the timer's callback
  416:  * function.
  417:  *
  418:  * Harmless if the timer is already inactive.
  419:  */
  420:  void TMR_StopTimer
  421:  (
  422:  tmrTimerID_t timerID
  423:  )
  424:  {
  0000 87       [2]             PSHA  
  0001 8b       [2]             PSHH  
  425:    tmrStatus_t status;
  426:    uint8_t ccr;
  427:    
  428:    IrqControlLib_BackupIrqStatus(ccr);
  0002 85       [1]             TPA   
  0003 95       [2]             TSX   
  0004 f7       [2]             STA   ,X
  429:    IrqControlLib_DisableAllIrqs();
  0005 9b       [1]             SEI   
  430:    status = TMR_GetTimerStatus(timerID);
  0006 e601     [3]             LDA   1,X
  0008 ac000000 [8]             CALL  TMR_GetTimerStatus
  431:    if (   (status == mTmrStatusActive_c) ||
  000c 412004   [4]             CBEQA #32,L13 ;abs = 0013
  432:           (status == mTmrStatusReady_c)
  000f a140     [2]             CMP   #64
  0011 262f     [3]             BNE   L42 ;abs = 0042
  0013          L13:    
  433:       ) 
  434:    {
  435:          TMR_SetTimerStatus(timerID, mTmrStatusInactive_c);
  0013 95       [2]             TSX   
  0014 ee01     [3]             LDX   1,X
  0016 a680     [2]             LDA   #-128
  0018 ac000000 [8]             CALL  TMR_SetTimerStatus
  436:          DecrementActiveTimerNumber(TMR_GetTimerType(timerID));
  001c 95       [2]             TSX   
  001d e601     [3]             LDA   1,X
  001f ac000000 [8]             CALL  TMR_GetTimerType
  0023 a510     [2]             BIT   #16
  0025 2605     [3]             BNE   L2C ;abs = 002c
  0027 450000   [3]             LDHX  @numberOfActiveTimers
  002a 2003     [3]             BRA   L2F ;abs = 002f
  002c          L2C:    
  002c 450000   [3]             LDHX  @numberOfLowPowerActiveTimers
  002f          L2F:    
  002f 7a       [4]             DEC   ,X
  437:          /* if no sw active timers are enabled, */
  438:          /* call the TMR_Task() to countdown the ticks and stop the hw timer*/
  439:      		if (!numberOfActiveTimers && !numberOfLowPowerActiveTimers) 
  0030 c60000   [4]             LDA   numberOfLowPowerActiveTimers
  0033 ca0000   [4]             ORA   numberOfActiveTimers
  0036 260a     [3]             BNE   L42 ;abs = 0042
  440:      		   TS_SendEvent(gTimerTaskID, mTMR_Event_c);
  0038 c60000   [4]             LDA   gTimerTaskID
  003b ae01     [2]             LDX   #1
  003d 8c       [1]             CLRH  
  003e ac000000 [8]             CALL  TS_SendEvent
  0042          L42:    
  441:  
  442:    }
  443:    IrqControlLib_RestoreIrqStatus(ccr);    
  0042 95       [2]             TSX   
  0043 f6       [3]             LDA   ,X
  0044 84       [1]             TAP   
  444:  }  
  0045 a702     [2]             AIS   #2
  0047 8d       [7]             RTC   
  445:  /*****************************************************************************/
  446:  
  447:  /*****************************************************************************
  448:  * Timer task. Called by the kernel when the timer ISR posts a timer event.
  449:  ******************************************************************************/
  450:  void TMR_Task
  451:  (
  452:  event_t events
  453:  )
  454:  {
  0000 a7ed     [2]             AIS   #-19
  455:    pfTmrCallBack_t pfCallBack;
  456:    uint16_t currentTimeInTicks;
  457:    uint16_t nextInterruptTime;
  458:    tmrTimerStatus_t status;
  459:    uint16_t ticksSinceLastHere;
  460:    index_t timerID;
  461:    uint16_t ticksdiff;   
  462:    uint8_t ccr;
  463:    tmrTimerTableEntry_t *currentTimer;
  464:  #if gTMR_EnableMinutesSecondsTimers_d 
  465:    uint8_t stopIt = FALSE; 
  0002 95       [2]             TSX   
  0003 6f12     [5]             CLR   18,X
  466:  #endif /* gTMR_EnableMinutesSecondsTimers_d */
  467:    tmrTimerType_t timerType; 
  468:    (void)events;
  469:    
  470:    IrqControlLib_BackupIrqStatus(ccr);
  0005 85       [1]             TPA   
  0006 e705     [3]             STA   5,X
  471:    IrqControlLib_DisableAllIrqs();  
  0008 9b       [1]             SEI   
  0009 ac0001aa [8]             CALL  TMR_Task:426
  000d ac0001aa [8]             CALL  TMR_Task:426
  472:    TpmReadCNTRegister(currentTimeInTicks);
  473:    
  474:    #ifdef PROCESSOR_MC1323X  
  475:     TpmReadCNTRegister(currentTimeInTicks);
  0011 320000   [5]             LDHX  mTmrRead16bitReg
  0014 9eff07   [5]             STHX  7,SP
  476:    #endif
  477:    IrqControlLib_RestoreIrqStatus(ccr);
  0017 95       [2]             TSX   
  0018 e605     [3]             LDA   5,X
  001a 84       [1]             TAP   
  478:    
  479:    /* calculate difference between current and previous. This scheme works up to 32K of difference */
  480:    ticksSinceLastHere = (uint16_t)((int16_t)currentTimeInTicks - (int16_t)previousTimeInTicks);
  001b e607     [3]             LDA   7,X
  001d c00001   [4]             SUB   previousTimeInTicks:1
  0020 87       [2]             PSHA  
  0021 e606     [3]             LDA   6,X
  0023 c20000   [4]             SBC   previousTimeInTicks
  0026 87       [2]             PSHA  
  0027 8a       [3]             PULH  
  0028 88       [3]             PULX  
  0029 9eff0d   [5]             STHX  13,SP
  481:    
  482:    /* remember for next time */
  483:    previousTimeInTicks = currentTimeInTicks;
  002c 9efe07   [5]             LDHX  7,SP
  002f 960000   [5]             STHX  previousTimeInTicks
  484:   
  485:      /* Find the shortest active timer. */
  486:    nextInterruptTime = mMaxToCountDown_c;
  0032 457ffe   [3]             LDHX  #32766
  0035 9eff02   [5]             STHX  2,SP
  487:    
  488:    for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID) 
  0038 95       [2]             TSX   
  0039 7f       [4]             CLR   ,X
  003a          L3A:    
  489:    {
  490:      /* Pointer to the current timer. Optimize the code size */
  491:      currentTimer = &maTmrTimerTable[timerID];
  003a f6       [3]             LDA   ,X
  003b ae07     [2]             LDX   #7
  003d 42       [5]             MUL   
  003e ab00     [2]             ADD   @maTmrTimerTable
  0040 87       [2]             PSHA  
  0041 4f       [1]             CLRA  
  0042 a900     [2]             ADC   @maTmrTimerTable:MSB
  0044 87       [2]             PSHA  
  0045 8a       [3]             PULH  
  0046 88       [3]             PULX  
  0047 9eff04   [5]             STHX  4,SP
  492:      
  493:      IrqControlLib_BackupIrqStatus(ccr);
  004a 85       [1]             TPA   
  004b 95       [2]             TSX   
  004c e705     [3]             STA   5,X
  494:      IrqControlLib_DisableAllIrqs();
  004e 9b       [1]             SEI   
  495:      status = TMR_GetTimerStatus(timerID);
  004f f6       [3]             LDA   ,X
  0050 ac000000 [8]             CALL  TMR_GetTimerStatus
  0054 95       [2]             TSX   
  0055 e711     [3]             STA   17,X
  496:  
  497:      if (status == mTmrStatusReady_c) 
  0057 a140     [2]             CMP   #64
  0059 260d     [3]             BNE   L68 ;abs = 0068
  498:      {
  499:        /* If TMR_StartTimer() has been called for this timer, start it's count */
  500:        /* down as of now. */
  501:        TMR_SetTimerStatus(timerID, mTmrStatusActive_c);            
  005b fe       [3]             LDX   ,X
  005c a620     [2]             LDA   #32
  005e ac000000 [8]             CALL  TMR_SetTimerStatus
  502:        IrqControlLib_RestoreIrqStatus(ccr);
  0062 95       [2]             TSX   
  0063 e605     [3]             LDA   5,X
  0065 84       [1]             TAP   
  503:      }
  0066 206f     [3]             BRA   LD7 ;abs = 00d7
  0068          L68:    
  504:      else
  505:      {          
  506:        IrqControlLib_RestoreIrqStatus(ccr);        
  0068 e605     [3]             LDA   5,X
  006a 84       [1]             TAP   
  507:        
  508:        /* Process the active timers. This does not includes the Ready timers started in this loop */
  509:        if (status == mTmrStatusActive_c) 
  006b e611     [3]             LDA   17,X
  006d a120     [2]             CMP   #32
  006f 2666     [3]             BNE   LD7 ;abs = 00d7
  510:        {      
  511:          /* This timer is active. Decrement it's countdown. If the countdown */
  512:          /* reaches zero, the timer is expired. */
  513:          if (currentTimer->countDown > ticksSinceLastHere) 
  0071 9efe04   [5]             LDHX  4,SP
  0074 9ece02   [5]             LDHX  2,X
  0077 9ef30d   [6]             CPHX  13,SP
  007a 2313     [3]             BLS   L8F ;abs = 008f
  514:          {
  515:           currentTimer->countDown -= ticksSinceLastHere;
  007c 9efe04   [5]             LDHX  4,SP
  007f e603     [3]             LDA   3,X
  0081 9ee00e   [4]             SUB   14,SP
  0084 e703     [3]             STA   3,X
  0086 e602     [3]             LDA   2,X
  0088 9ee20d   [4]             SBC   13,SP
  008b e702     [3]             STA   2,X
  008d          L8D:    
  516:          }
  008d 2048     [3]             BRA   LD7 ;abs = 00d7
  008f          L8F:    
  517:          else
  518:          {       
  519:           bool_t callbackCall = TRUE;
  008f a601     [2]             LDA   #1
  0091 95       [2]             TSX   
  0092 e70e     [3]             STA   14,X
  520:           /* Timer countDown expired */
  521:           
  522:           /* Get timer type to detect it*/
  523:           timerType = TMR_GetTimerType(timerID); 
  0094 f6       [3]             LDA   ,X
  0095 ac000000 [8]             CALL  TMR_GetTimerType
  0099 95       [2]             TSX   
  009a e70b     [3]             STA   11,X
  524:                  
  525:           #if gTMR_EnableMinutesSecondsTimers_d   
  526:           /* check if a second/minute expired, load the next one  */
  527:           if (IsMinuteTimer(timerType) || IsSecondTimer(timerType)) 
  009c a406     [2]             AND   #6
  009e 410608   [4]             CBEQA #6,LA9 ;abs = 00a9
  00a1 e60b     [3]             LDA   11,X
  00a3 a40a     [2]             AND   #10
  00a5 a10a     [2]             CMP   #10
  00a7 2630     [3]             BNE   LD9 ;abs = 00d9
  00a9          LA9:    
  528:           {
  529:             /* Check if the minute/second timer expired */
  530:             if(currentTimer->intervalInTicks > 1) 
  00a9 9efe04   [5]             LDHX  4,SP
  00ac 9eae     [5]             LDHX  ,X
  00ae 650001   [3]             CPHX  #1
  00b1 2338     [3]             BLS   LEB ;abs = 00eb
  531:             {
  532:               --currentTimer->intervalInTicks; 
  00b3 9efe04   [5]             LDHX  4,SP
  00b6 6d01     [4]             TST   1,X
  00b8 2601     [3]             BNE   LBB ;abs = 00bb
  00ba 7a       [4]             DEC   ,X
  00bb          LBB:    
  00bb 6a01     [5]             DEC   1,X
  533:               /* Load with next minute/second to count down */
  534:               if(IsMinuteTimer(timerType))
  00bd 9ee60c   [4]             LDA   12,SP
  00c0 a406     [2]             AND   #6
  00c2 a106     [2]             CMP   #6
  00c4 2608     [3]             BNE   LCE ;abs = 00ce
  535:               {            
  536:                 currentTimer->countDown = TmrTicksForOneMinute();
  00c6 a639     [2]             LDA   #57
  00c8 e702     [3]             STA   2,X
  00ca a630     [2]             LDA   #48
  537:               }
  00cc 2004     [3]             BRA   LD2 ;abs = 00d2
  00ce          LCE:    
  538:               else
  539:               {            
  540:                 /* else if it's a second timer */
  541:                 currentTimer->countDown = TmrTicksForOneSecond();
  00ce 6f02     [5]             CLR   2,X
  00d0 a6f4     [2]             LDA   #-12
  00d2          LD2:    
  00d2 e703     [3]             STA   3,X
  542:               }
  543:  
  544:              callbackCall = FALSE;
  00d4 95       [2]             TSX   
  00d5 6f0e     [5]             CLR   14,X
  00d7          LD7:    
  545:             } 
  00d7 2046     [3]             BRA   L11F ;abs = 011f
  00d9          LD9:    
  546:             else 
  547:             {          
  548:               /* Minute/second Timer expired... stop it */
  549:               TMR_StopTimer(timerID);
  550:             }
  551:           } 
  552:           else 
  553:           #endif /* gTMR_EnableMinutesSecondsTimers_d */
  554:           {
  555:             /* If this is an interval millisec. timer, restart it */
  556:             if (timerType & gTmrIntervalTimer_c)
  00d9 e60b     [3]             LDA   11,X
  00db a502     [2]             BIT   #2
  00dd 270c     [3]             BEQ   LEB ;abs = 00eb
  557:             {          
  558:              currentTimer->countDown = currentTimer->intervalInTicks;
  00df 9efe04   [5]             LDHX  4,SP
  00e2 f6       [3]             LDA   ,X
  00e3 e702     [3]             STA   2,X
  00e5 e601     [3]             LDA   1,X
  00e7 e703     [3]             STA   3,X
  559:             }
  00e9 2006     [3]             BRA   LF1 ;abs = 00f1
  00eb          LEB:    
  560:             else
  561:             {
  562:              TMR_StopTimer(timerID);
  00eb 95       [2]             TSX   
  00ec f6       [3]             LDA   ,X
  00ed ac000000 [8]             CALL  TMR_StopTimer
  00f1          LF1:    
  563:             }
  564:           }
  565:           
  566:           if(callbackCall)
  00f1 95       [2]             TSX   
  00f2 6d0e     [4]             TST   14,X
  00f4 2729     [3]             BEQ   L11F ;abs = 011f
  567:           {        
  568:             /* This timer has expired. */
  569:             pfCallBack = currentTimer->pfCallBack;
  00f6 9efe04   [5]             LDHX  4,SP
  00f9 e604     [3]             LDA   4,X
  00fb 9ee709   [4]             STA   9,SP
  00fe 9ece05   [5]             LDHX  5,X
  0101 9eff0a   [5]             STHX  10,SP
  570:        
  571:             /* Call callback if it is not NULL. This is done after the timer got updated,
  572:              * in case the timer gets stopped or restarted in the callback
  573:              */
  574:              if (pfCallBack) 
  0104 95       [2]             TSX   
  0105 af08     [2]             AIX   #8
  0107 cd0000   [6]             JSR   _CMP24_RC
  010a 00               DC.B  0
  010b 0000             DC.W  0
  010d 2710     [3]             BEQ   L11F ;abs = 011f
  575:              {
  576:               pfCallBack(timerID);
  010f 9efe0a   [5]             LDHX  10,SP
  0112 8b       [2]             PSHH  
  0113 8b       [2]             PSHH  
  0114 9ee603   [4]             LDA   3,SP
  0117 87       [2]             PSHA  
  0118 9ee60c   [4]             LDA   12,SP
  011b ac000000 [8]             CALL  _CALL_STAR08_FAR
  011f          L11F:   
  577:              }
  578:           }
  579:           
  580:          }
  581:        }
  582:        
  583:      } // end else if (status == mTmrStatusReady_c)     
  584:      
  585:      /* Timer is still active (not stopped)? 
  586:       * This test includes the Ready timers started in this loop
  587:       */
  588:       if (TMR_GetTimerStatus(timerID) == mTmrStatusActive_c) 
  011f 95       [2]             TSX   
  0120 f6       [3]             LDA   ,X
  0121 ac000000 [8]             CALL  TMR_GetTimerStatus
  0125 a120     [2]             CMP   #32
  0127 2614     [3]             BNE   L13D ;abs = 013d
  589:       {           
  590:          if (nextInterruptTime > currentTimer->countDown) 
  0129 9efe04   [5]             LDHX  4,SP
  012c 9ece02   [5]             LDHX  2,X
  012f 9ef302   [6]             CPHX  2,SP
  0132 2409     [3]             BCC   L13D ;abs = 013d
  591:          {
  592:            nextInterruptTime = currentTimer->countDown;
  0134 9efe04   [5]             LDHX  4,SP
  0137 9ece02   [5]             LDHX  2,X
  013a 9eff02   [5]             STHX  2,SP
  013d          L13D:   
  013d 95       [2]             TSX   
  013e 7c       [4]             INC   ,X
  013f f6       [3]             LDA   ,X
  0140 a122     [2]             CMP   #34
  0142 2403     [3]             BCC   L147 ;abs = 0147
  0144 cc003a   [4]             JMP   L3A ;abs = 003a
  0147          L147:   
  593:          }
  594:       }
  595:  
  596:    } // end for
  597:    
  598:    
  599:    IrqControlLib_BackupIrqStatus(ccr);
  0147 85       [1]             TPA   
  0148 e705     [3]             STA   5,X
  600:    IrqControlLib_DisableAllIrqs();
  014a 9b       [1]             SEI   
  601:    
  602:    /* Update the compare register */
  603:    nextInterruptTime += currentTimeInTicks;
  014b e607     [3]             LDA   7,X
  014d eb02     [3]             ADD   2,X
  014f e702     [3]             STA   2,X
  0151 e601     [3]             LDA   1,X
  0153 e906     [3]             ADC   6,X
  0155 e701     [3]             STA   1,X
  604:    
  605:    #ifndef PROCESSOR_QE128
  606:     gTPMxCnVL_c = TPMxCnVLvalue(nextInterruptTime);
  0157 ee02     [3]             LDX   2,X
  0159 bf0f     [3]             STX   15
  607:     gTPMxCnVH_c = TPMxCnVHvalue(nextInterruptTime);
  015b b70e     [3]             STA   14
  608:    #endif
  609:    
  610:    /* Check to be sure that the timer was not programmed in the past for different source clocks.
  611:     * The interrupts are now disabled.
  612:     */      	 
  613:    TpmReadCNTRegister(ticksdiff);  
  015d be09     [3]             LDX   9
  015f cf0000   [4]             STX   mTmrRead16bitReg
  0162 be0a     [3]             LDX   10
  0164 cf0001   [4]             STX   mTmrRead16bitReg:1
  0167 320000   [5]             LDHX  mTmrRead16bitReg
  016a 9eff10   [5]             STHX  16,SP
  614:    
  615:    #ifdef PROCESSOR_QE128
  616:     /* Always program minimum 2 ticks ahead on QE128 */ 
  617:     if(((int16_t)nextInterruptTime - (int16_t)ticksdiff) < 2 )
  618:     {
  619:       nextInterruptTime = ticksdiff + 2;
  620:     }
  621:     gTPMxCnVL_c = TPMxCnVLvalue(nextInterruptTime);
  622:     gTPMxCnVH_c = TPMxCnVHvalue(nextInterruptTime);
  623:   
  624:    #else
  625:      
  626:     if((((int16_t)ticksdiff - (int16_t)nextInterruptTime) >= 0) && (!(gTPMxCnSC_c & gTPMxCnSC_F_c)))
  016d 95       [2]             TSX   
  016e e610     [3]             LDA   16,X
  0170 e002     [3]             SUB   2,X
  0172 e60f     [3]             LDA   15,X
  0174 e201     [3]             SBC   1,X
  0176 4d       [1]             TSTA  
  0177 910d     [3]             BLT   L186 ;abs = 0186
  0179 0e0d0a   [5]             BRSET 7,13,L186 ;abs = 0186
  627:     {  
  628:       /* Timer counter passed the comparator value. The Compare Flag was not set */
  629:       /* The compare register was programmed in the past. The next interrupt time has already passed */
  630:       TS_SendEvent(gTimerTaskID, mTMR_Event_c);
  017c c60000   [4]             LDA   gTimerTaskID
  017f ae01     [2]             LDX   #1
  0181 8c       [1]             CLRH  
  0182 ac000000 [8]             CALL  TS_SendEvent
  0186          L186:   
  631:     }
  632:     
  633:    #endif 
  634:    
  635:    IrqControlLib_RestoreIrqStatus(ccr);   
  0186 95       [2]             TSX   
  0187 e605     [3]             LDA   5,X
  0189 84       [1]             TAP   
  636:  
  637:    if (!numberOfActiveTimers && !numberOfLowPowerActiveTimers) {
  018a c60000   [4]             LDA   numberOfLowPowerActiveTimers
  018d ca0000   [4]             ORA   numberOfActiveTimers
  0190 2605     [3]             BNE   L197 ;abs = 0197
  638:      TpmStopTimerHardware();
  0192 3f08     [5]             CLR   8
  639:      timerHardwareIsRunning = FALSE;
  0194 4f       [1]             CLRA  
  640:    } else if (!timerHardwareIsRunning) {
  0195 200d     [3]             BRA   L1A4 ;abs = 01a4
  0197          L197:   
  0197 c60000   [4]             LDA   timerHardwareIsRunning
  019a 260b     [3]             BNE   L1A7 ;abs = 01a7
  641:      TpmStartTimerHardware();
  019c b608     [3]             LDA   8
  019e aa1f     [2]             ORA   #31
  01a0 b708     [3]             STA   8
  642:      timerHardwareIsRunning = TRUE;
  01a2 a601     [2]             LDA   #1
  01a4          L1A4:   
  01a4 c70000   [4]             STA   timerHardwareIsRunning
  01a7          L1A7:   
  643:    }
  644:  }                                       /* TMR_Task() */
  01a7 a713     [2]             AIS   #19
  01a9 8d       [7]             RTC   
  01aa          L1AA:   
  01aa b609     [3]             LDA   9
  01ac c70000   [4]             STA   mTmrRead16bitReg
  01af b60a     [3]             LDA   10
  01b1 c70001   [4]             STA   mTmrRead16bitReg:1
  01b4 8d       [7]             RTC   
  645:  /*****************************************************************************/
  646:  
  647:  /* Enable or disable the timer tmrID
  648:     If enable = TRUE timer is active
  649:     Else timer is inactive 
  650:  */
  651:  void TMR_EnableTimer(tmrTimerID_t tmrID)
  652:  {    
  0000 87       [2]             PSHA  
  0001 8b       [2]             PSHH  
  653:    uint8_t ccr;
  654:    
  655:    IrqControlLib_BackupIrqStatus(ccr);
  0002 85       [1]             TPA   
  0003 95       [2]             TSX   
  0004 f7       [2]             STA   ,X
  656:    IrqControlLib_DisableAllIrqs();
  0005 9b       [1]             SEI   
  657:    if (TMR_GetTimerStatus(tmrID) == mTmrStatusInactive_c)
  0006 e601     [3]             LDA   1,X
  0008 ac000000 [8]             CALL  TMR_GetTimerStatus
  000c a180     [2]             CMP   #-128
  000e 2627     [3]             BNE   L37 ;abs = 0037
  658:    {      
  659:      IncrementActiveTimerNumber(TMR_GetTimerType(tmrID));    
  0010 95       [2]             TSX   
  0011 e601     [3]             LDA   1,X
  0013 ac000000 [8]             CALL  TMR_GetTimerType
  0017 a510     [2]             BIT   #16
  0019 2605     [3]             BNE   L20 ;abs = 0020
  001b 450000   [3]             LDHX  @numberOfActiveTimers
  001e 2003     [3]             BRA   L23 ;abs = 0023
  0020          L20:    
  0020 450000   [3]             LDHX  @numberOfLowPowerActiveTimers
  0023          L23:    
  0023 7c       [4]             INC   ,X
  660:      TMR_SetTimerStatus(tmrID, mTmrStatusReady_c);
  0024 95       [2]             TSX   
  0025 ee01     [3]             LDX   1,X
  0027 a640     [2]             LDA   #64
  0029 ac000000 [8]             CALL  TMR_SetTimerStatus
  661:      TS_SendEvent(gTimerTaskID, mTMR_Event_c);
  002d c60000   [4]             LDA   gTimerTaskID
  0030 ae01     [2]             LDX   #1
  0032 8c       [1]             CLRH  
  0033 ac000000 [8]             CALL  TS_SendEvent
  0037          L37:    
  662:    }  
  663:    IrqControlLib_RestoreIrqStatus(ccr);
  0037 95       [2]             TSX   
  0038 f6       [3]             LDA   ,X
  0039 84       [1]             TAP   
  664:  }
  003a a702     [2]             AIS   #2
  003c 8d       [7]             RTC   
  665:  /*****************************************************************************/
  666:  
  667:  /* brief: Get the remaining time in milliseconds for the specified timer 
  668:     param(s): tmrID - the ID of the timer
  669:     return: the remaining time until timer expires
  670:  */
  671:  uint32_t TMR_GetRemainingTime
  672:  (
  673:      tmrTimerID_t tmrID
  674:  )
  675:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fc     [2]             AIS   #-4
  676:      uint32_t  remainingTime;
  677:  
  678:      if(gTmrInvalidTimerID_c == tmrID)
  0004 a1ff     [2]             CMP   #-1
  0006 2609     [3]             BNE   L11 ;abs = 0011
  679:          return 0;
  0008 7f       [4]             CLR   ,X
  0009 6f01     [5]             CLR   1,X
  000b 6f02     [5]             CLR   2,X
  000d 6f03     [5]             CLR   3,X
  000f 2032     [3]             BRA   L43 ;abs = 0043
  0011          L11:    
  680:  
  681:      if(0 == gTPMxSC_PrescaleCount_c)
  682:      {
  683:          remainingTime = (10*maTmrTimerTable[tmrID].countDown)/gTmrSourceClkForMilli_c;
  684:      }
  685:      else
  686:      {
  687:          remainingTime = (gPrescaleCountForMilli_c*maTmrTimerTable[tmrID].countDown)/gTmrSourceClkForMilli_c;
  0011 ae07     [2]             LDX   #7
  0013 42       [5]             MUL   
  0014 8c       [1]             CLRH  
  0015 97       [1]             TAX   
  0016 9ebe0002 [6]             LDHX  @maTmrTimerTable:2,X
  001a 4f       [1]             CLRA  
  001b 89       [2]             PSHX  
  001c 8b       [2]             PSHH  
  001d 87       [2]             PSHA  
  001e 87       [2]             PSHA  
  001f 95       [2]             TSX   
  0020 cd0000   [6]             JSR   _LMUL_RC
  0023 00000500         DC.L  1280
  0027 95       [2]             TSX   
  0028 cd0000   [6]             JSR   _LDIVU_RC
  002b 00000139         DC.L  313
  002f af08     [2]             AIX   #8
  0031 cd0000   [6]             JSR   _POP32
  688:      }
  689:  
  690:      return remainingTime;
  0034 9efe0d   [5]             LDHX  13,SP
  0037 89       [2]             PSHX  
  0038 8b       [2]             PSHH  
  0039 95       [2]             TSX   
  003a af0a     [2]             AIX   #10
  003c a604     [2]             LDA   #4
  003e cd0000   [6]             JSR   _COPY
  0041 a708     [2]             AIS   #8
  0043          L43:    
  691:  }
  0043 a706     [2]             AIS   #6
  0045 8d       [7]             RTC   
  692:  /*****************************************************************************/
  693:  
  694:  /*
  695:  This function is called by Low Power module; Also this function stops the 
  696:  harware timer.
  697:  Return: time in millisecond that wasn't counted before entering in sleep  
  698:  */
  699:  uint32_t TMR_NotCountedMillisTimeBeforeSleep(void)
  700:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  701:    uint16_t currentTimeInTicks;
  702:    
  703:    if (!numberOfLowPowerActiveTimers)
  0004 c60000   [4]             LDA   numberOfLowPowerActiveTimers
  0007 2609     [3]             BNE   L12 ;abs = 0012
  704:      return 0;
  0009 7f       [4]             CLR   ,X
  000a 6f01     [5]             CLR   1,X
  000c 6f02     [5]             CLR   2,X
  000e 6f03     [5]             CLR   3,X
  0010 2038     [3]             BRA   L4A ;abs = 004a
  0012          L12:    
  705:    TpmReadCNTRegister(currentTimeInTicks);
  0012 b609     [3]             LDA   9
  0014 450000   [3]             LDHX  @mTmrRead16bitReg
  0017 f7       [2]             STA   ,X
  0018 b60a     [3]             LDA   10
  001a e701     [3]             STA   1,X
  001c 9eae     [5]             LDHX  ,X
  001e 9eff01   [5]             STHX  1,SP
  706:    TpmStopTimerHardware();
  0021 3f08     [5]             CLR   8
  707:    timerHardwareIsRunning = FALSE; 
  0023 4f       [1]             CLRA  
  0024 c70000   [4]             STA   timerHardwareIsRunning
  708:       
  709:    return  TmrMillisecondsFromTicks((currentTimeInTicks - previousTimeInTicks));
  0027 95       [2]             TSX   
  0028 e601     [3]             LDA   1,X
  002a c00001   [4]             SUB   previousTimeInTicks:1
  002d 87       [2]             PSHA  
  002e f6       [3]             LDA   ,X
  002f c20000   [4]             SBC   previousTimeInTicks
  0032 88       [3]             PULX  
  0033 87       [2]             PSHA  
  0034 89       [2]             PSHX  
  0035 95       [2]             TSX   
  0036 e601     [3]             LDA   1,X
  0038 87       [2]             PSHA  
  0039 4f       [1]             CLRA  
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 95       [2]             TSX   
  003d a602     [2]             LDA   #2
  003f cd0000   [6]             JSR   _LLSL
  0042 9efe0c   [5]             LDHX  12,SP
  0045 cd0000   [6]             JSR   _POP32
  0048 a705     [2]             AIS   #5
  004a          L4A:    
  710:  } 
  004a a704     [2]             AIS   #4
  004c 8d       [7]             RTC   
  711:  
  712:  /*****************************************************************************/
  713:        
  714:  /* This function is called by the Low Power Module */
  715:  /* each time the MCU wakes up */ 
  716:  /* The function make an approximate sync. the active low power timers. */   
  717:                           
  718:  void TMR_SyncLpmTimers(tmrTimeInMilliseconds_t sleepDurationMillisec) 
  719:  {
  0000 a7e8     [2]             AIS   #-24
  720:  #if gTMR_EnableMinutesSecondsTimers_d
  721:   uint16_t spentSeconds = 0;
  0002 95       [2]             TSX   
  0003 6f07     [5]             CLR   7,X
  0005 6f06     [5]             CLR   6,X
  722:   uint16_t spentMinutes = 0;
  0007 6f0c     [5]             CLR   12,X
  0009 6f0b     [5]             CLR   11,X
  723:   uint16_t restTicksForMinutes = 0;
  724:   uint16_t restTicksForSeconds = 0;
  725:  #endif /* gTMR_EnableMinutesSecondsTimers_d */ 
  726:   uint32_t durationMillis = sleepDurationMillisec;
  000b 9efe1e   [5]             LDHX  30,SP
  000e 9eff12   [5]             STHX  18,SP
  0011 9efe1c   [5]             LDHX  28,SP
  0014 9eff10   [5]             STHX  16,SP
  727:   index_t  timerID;
  728:   tmrTimerType_t timerType;
  729:   tmrTimerTableEntry_t *currentTimer;
  730:   
  731:   /* Check if there are low power active timer */
  732:   if (!numberOfLowPowerActiveTimers)
  0017 c60000   [4]             LDA   numberOfLowPowerActiveTimers
  001a 2624     [3]             BNE   L40 ;abs = 0040
  733:      return;
  001c cc0257   [4]             JMP   L257 ;abs = 0257
  001f          L1F:    
  734:   
  735:  #if gTMR_EnableMinutesSecondsTimers_d           
  736:   /* Calc the units spent in sleep mode - minutes and seconds */
  737:   while(durationMillis >= mOneMinute_c) 
  738:   {
  739:     durationMillis -= mOneMinute_c;
  001f 95       [2]             TSX   
  0020 af0f     [2]             AIX   #15
  0022 cd0000   [6]             JSR   _LSUB_RC
  0025 0000ea60         DC.L  60000
  0029 cd0000   [6]             JSR   _POP32
  740:     spentMinutes++;
  002c 95       [2]             TSX   
  002d 6c0c     [5]             INC   12,X
  002f 2602     [3]             BNE   L33 ;abs = 0033
  0031 6c0b     [5]             INC   11,X
  0033          L33:    
  741:     if(spentSeconds < ((uint16_t)0xFFFE-60)) 
  0033 9efe07   [5]             LDHX  7,SP
  0036 65ffc2   [3]             CPHX  #-62
  0039 2405     [3]             BCC   L40 ;abs = 0040
  742:     {    
  743:      spentSeconds+=60;
  003b af3c     [2]             AIX   #60
  003d 9eff07   [5]             STHX  7,SP
  0040          L40:    
  0040 95       [2]             TSX   
  0041 af0f     [2]             AIX   #15
  0043 cd0000   [6]             JSR   _LCMP_RC
  0046 0000ea60         DC.L  60000
  004a 24d3     [3]             BCC   L1F ;abs = 001f
  744:     }
  745:        
  746:   }
  747:   /* durationMillis now indicates the rest of milliseconds spent after spentMinutes */
  748:   restTicksForMinutes = TmrTicksFromMilliseconds(durationMillis);
  004c 95       [2]             TSX   
  004d af0f     [2]             AIX   #15
  004f cd0000   [6]             JSR   _LMUL_RC
  0052 00000139         DC.L  313
  0056 95       [2]             TSX   
  0057 cd0000   [6]             JSR   _LDIVU_RC
  005a 00000500         DC.L  1280
  005e 95       [2]             TSX   
  005f e602     [3]             LDA   2,X
  0061 87       [2]             PSHA  
  0062 ee03     [3]             LDX   3,X
  0064 8a       [3]             PULH  
  0065 9eff1d   [5]             STHX  29,SP
  749:     
  750:   while(durationMillis >= mOneSecond_c) 
  0068 a708     [2]             AIS   #8
  006a 201c     [3]             BRA   L88 ;abs = 0088
  006c          L6C:    
  751:   {
  752:     durationMillis -= mOneSecond_c;
  006c 95       [2]             TSX   
  006d af0f     [2]             AIX   #15
  006f cd0000   [6]             JSR   _LSUB_RC
  0072 000003e8         DC.L  1000
  0076 cd0000   [6]             JSR   _POP32
  753:     if(spentSeconds < (uint16_t)0xFFFE) 
  0079 9efe07   [5]             LDHX  7,SP
  007c 65fffe   [3]             CPHX  #-2
  007f 2407     [3]             BCC   L88 ;abs = 0088
  754:     {    
  755:      spentSeconds++;
  0081 95       [2]             TSX   
  0082 6c07     [5]             INC   7,X
  0084 2602     [3]             BNE   L88 ;abs = 0088
  0086 6c06     [5]             INC   6,X
  0088          L88:    
  0088 95       [2]             TSX   
  0089 af0f     [2]             AIX   #15
  008b cd0000   [6]             JSR   _LCMP_RC
  008e 000003e8         DC.L  1000
  0092 24d8     [3]             BCC   L6C ;abs = 006c
  756:     }
  757:   }
  758:   /* durationMillis now indicates the rest of milliseconds spent after spentSeconds */
  759:   restTicksForSeconds = TmrTicksFromMilliseconds(durationMillis);
  0094 95       [2]             TSX   
  0095 af0f     [2]             AIX   #15
  0097 cd0000   [6]             JSR   _LMUL_RC
  009a 00000139         DC.L  313
  009e 95       [2]             TSX   
  009f cd0000   [6]             JSR   _LDIVU_RC
  00a2 00000500         DC.L  1280
  00a6 95       [2]             TSX   
  00a7 e602     [3]             LDA   2,X
  00a9 87       [2]             PSHA  
  00aa ee03     [3]             LDX   3,X
  00ac 8a       [3]             PULH  
  00ad 9eff1f   [5]             STHX  31,SP
  760:  #endif /* gTMR_EnableMinutesSecondsTimers_d */
  761:  
  762:  /* For each timer, detect the timer type and count down the spent duration in sleep */  
  763:  for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID) 
  00b0 95       [2]             TSX   
  00b1 6f0b     [5]             CLR   11,X
  00b3 a708     [2]             AIS   #8
  00b5          LB5:    
  764:  {
  765:  
  766:    /* Detect the timer type and count down the spent duration in sleep */
  767:    timerType = TMR_GetTimerType(timerID);
  00b5 95       [2]             TSX   
  00b6 e603     [3]             LDA   3,X
  00b8 ac000000 [8]             CALL  TMR_GetTimerType
  00bc 95       [2]             TSX   
  00bd e708     [3]             STA   8,X
  768:    
  769:    currentTimer = &maTmrTimerTable[timerID];
  00bf e603     [3]             LDA   3,X
  00c1 ae07     [2]             LDX   #7
  00c3 42       [5]             MUL   
  00c4 ab00     [2]             ADD   @maTmrTimerTable
  00c6 87       [2]             PSHA  
  00c7 4f       [1]             CLRA  
  00c8 a900     [2]             ADC   @maTmrTimerTable:MSB
  00ca 87       [2]             PSHA  
  00cb 8a       [3]             PULH  
  00cc 88       [3]             PULX  
  00cd 9eff05   [5]             STHX  5,SP
  770:    
  771:    /* Sync. only the low power timers that are active */
  772:    if ( (TMR_GetTimerStatus(timerID) == mTmrStatusActive_c)
  00d0 95       [2]             TSX   
  00d1 e603     [3]             LDA   3,X
  00d3 ac000000 [8]             CALL  TMR_GetTimerStatus
  00d7 a120     [2]             CMP   #32
  00d9 2703     [3]             BEQ   LDE ;abs = 00de
  00db cc01fc   [4]             JMP   L1FC ;abs = 01fc
  00de          LDE:    
  773:          && (IsLowPowerTimer(timerType)) ) 
  00de 95       [2]             TSX   
  00df e608     [3]             LDA   8,X
  00e1 a510     [2]             BIT   #16
  00e3 2603     [3]             BNE   LE8 ;abs = 00e8
  00e5 cc01fc   [4]             JMP   L1FC ;abs = 01fc
  00e8          LE8:    
  774:    {
  775:  #if gTMR_EnableMinutesSecondsTimers_d
  776:  
  777:           if (IsLowPowerSecondTimer(timerType) || IsLowPowerMinuteTimer(timerType)) 
  00e8 a41a     [2]             AND   #26
  00ea 411a0b   [4]             CBEQA #26,LF8 ;abs = 00f8
  00ed e608     [3]             LDA   8,X
  00ef a416     [2]             AND   #22
  00f1 a116     [2]             CMP   #22
  00f3 2703     [3]             BEQ   LF8 ;abs = 00f8
  00f5 cc01d1   [4]             JMP   L1D1 ;abs = 01d1
  00f8          LF8:    
  778:           {
  779:             bool_t timerExpired = FALSE;
  00f8 6f13     [5]             CLR   19,X
  780:             
  781:             uint16_t spentUnits = spentSeconds; /* seconds or minutes depending on the timer type */
  00fa 9efe07   [5]             LDHX  7,SP
  00fd 9eff0a   [5]             STHX  10,SP
  782:             uint16_t millisecInUnit = mOneSecond_c;          
  0100 4503e8   [3]             LDHX  #1000
  0103 9eff0e   [5]             STHX  14,SP
  783:             uint16_t restTicks = restTicksForSeconds;
  0106 9efe17   [5]             LDHX  23,SP
  0109 9eff02   [5]             STHX  2,SP
  784:             
  785:             if(IsLowPowerMinuteTimer(timerType)) 
  010c 95       [2]             TSX   
  010d e608     [3]             LDA   8,X
  010f a416     [2]             AND   #22
  0111 a116     [2]             CMP   #22
  0113 2612     [3]             BNE   L127 ;abs = 0127
  786:             {
  787:              spentUnits = spentMinutes;
  0115 9efe0c   [5]             LDHX  12,SP
  0118 9eff0a   [5]             STHX  10,SP
  788:              millisecInUnit = mOneMinute_c;
  011b 45ea60   [3]             LDHX  #-5536
  011e 9eff0e   [5]             STHX  14,SP
  789:              restTicks = restTicksForMinutes;
  0121 9efe15   [5]             LDHX  21,SP
  0124 9eff02   [5]             STHX  2,SP
  0127          L127:   
  0127 ac00025a [8]             CALL  TMR_SyncLpmTimers:602
  790:             }           
  791:                                   
  792:             /* Timer expired while MCU was in sleep mode??? */
  793:             /* SleepUnits + SleepMilliseconds <> RemainingUnits + RemainingMiliseconds */
  794:             
  795:             /* currentTimer->intervalInTicks is decremented only after the countdown has expired */
  796:             
  797:             if(currentTimer->intervalInTicks < (spentUnits + 1)) 
  012b 9eae     [5]             LDHX  ,X
  012d 89       [2]             PSHX  
  012e 8b       [2]             PSHH  
  012f 95       [2]             TSX   
  0130 ee02     [3]             LDX   2,X
  0132 cd0000   [6]             JSR   _ICMP
  0135 221b     [3]             BHI   L152 ;abs = 0152
  0137 ac00025a [8]             CALL  TMR_SyncLpmTimers:602
  798:             {
  799:                /* More units spent in sleep mode than remaining timer units */
  800:                timerExpired = TRUE;
  801:             } 
  802:             else            
  803:             {
  804:               
  805:               if( currentTimer->intervalInTicks  == (spentUnits + 1))
  013b 9eae     [5]             LDHX  ,X
  013d 89       [2]             PSHX  
  013e 8b       [2]             PSHH  
  013f 95       [2]             TSX   
  0140 ee02     [3]             LDX   2,X
  0142 cd0000   [6]             JSR   _ICMP
  0145 2615     [3]             BNE   L15C ;abs = 015c
  806:               {            
  807:                  /* Same units in sleep mode as remaing timer units */
  808:                  if((uint32_t)currentTimer->countDown <= restTicks) 
  0147 9efe05   [5]             LDHX  5,SP
  014a 9ece02   [5]             LDHX  2,X
  014d 9ef302   [6]             CPHX  2,SP
  0150 2202     [3]             BHI   L154 ;abs = 0154
  0152          L152:   
  809:                  {                                
  810:                    /* Remaining milliseconds are grater than the remaining timer ticks */
  811:                    timerExpired = TRUE;
  812:                  }
  0152 2075     [3]             BRA   L1C9 ;abs = 01c9
  0154          L154:   
  813:                  else 
  814:                  {
  815:                   currentTimer->intervalInTicks = 0;
  0154 9efe05   [5]             LDHX  5,SP
  0157 7f       [4]             CLR   ,X
  0158 6f01     [5]             CLR   1,X
  015a 201a     [3]             BRA   L176 ;abs = 0176
  015c          L15C:   
  816:                   currentTimer->countDown -= restTicks;
  817:                  }              
  818:               } 
  819:               else 
  820:               {
  821:                 /* Less units spent in sleep mode than remaining timer units */
  822:                 currentTimer->intervalInTicks -= spentUnits;
  015c 9efe05   [5]             LDHX  5,SP
  015f e601     [3]             LDA   1,X
  0161 9ee00b   [4]             SUB   11,SP
  0164 e701     [3]             STA   1,X
  0166 f6       [3]             LDA   ,X
  0167 9ee20a   [4]             SBC   10,SP
  016a f7       [2]             STA   ,X
  823:                 
  824:                 
  825:                 if(currentTimer->countDown >=  restTicks) 
  016b 9ece02   [5]             LDHX  2,X
  016e 9ef302   [6]             CPHX  2,SP
  0171 2513     [3]             BCS   L186 ;abs = 0186
  826:                 {                
  827:                  currentTimer->countDown -= restTicks;
  0173 9efe05   [5]             LDHX  5,SP
  0176          L176:   
  0176 e603     [3]             LDA   3,X
  0178 9ee003   [4]             SUB   3,SP
  017b e703     [3]             STA   3,X
  017d e602     [3]             LDA   2,X
  017f 9ee202   [4]             SBC   2,SP
  0182 e702     [3]             STA   2,X
  828:                 } 
  0184 203e     [3]             BRA   L1C4 ;abs = 01c4
  0186          L186:   
  829:                 else 
  830:                 {
  831:                   /* Remaining milliseconds are grater than remaining timer ticks */
  832:                   /* Decrement the number of units and recalculate the timer ticks */
  833:                   currentTimer->intervalInTicks--;
  0186 9efe05   [5]             LDHX  5,SP
  0189 6d01     [4]             TST   1,X
  018b 2601     [3]             BNE   L18E ;abs = 018e
  018d 7a       [4]             DEC   ,X
  018e          L18E:   
  018e 6a01     [5]             DEC   1,X
  834:                   currentTimer->countDown += (uint16_t)(TmrTicksFromMilliseconds(millisecInUnit) - restTicks);
  0190 9efe0e   [5]             LDHX  14,SP
  0193 4f       [1]             CLRA  
  0194 89       [2]             PSHX  
  0195 8b       [2]             PSHH  
  0196 87       [2]             PSHA  
  0197 87       [2]             PSHA  
  0198 95       [2]             TSX   
  0199 cd0000   [6]             JSR   _LMUL_RC
  019c 00000139         DC.L  313
  01a0 95       [2]             TSX   
  01a1 cd0000   [6]             JSR   _LDIVU_RC
  01a4 00000500         DC.L  1280
  01a8 95       [2]             TSX   
  01a9 e603     [3]             LDA   3,X
  01ab e00e     [3]             SUB   14,X
  01ad 87       [2]             PSHA  
  01ae e602     [3]             LDA   2,X
  01b0 e20d     [3]             SBC   13,X
  01b2 9efe12   [5]             LDHX  18,SP
  01b5 87       [2]             PSHA  
  01b6 9ee602   [4]             LDA   2,SP
  01b9 eb03     [3]             ADD   3,X
  01bb e703     [3]             STA   3,X
  01bd 86       [3]             PULA  
  01be e902     [3]             ADC   2,X
  01c0 e702     [3]             STA   2,X
  01c2 a70d     [2]             AIS   #13
  01c4          L1C4:   
  835:                 }
  836:                 
  837:               }                           
  838:             }
  839:             
  840:             if(timerExpired) 
  01c4 95       [2]             TSX   
  01c5 6d13     [4]             TST   19,X
  01c7 2763     [3]             BEQ   L22C ;abs = 022c
  01c9          L1C9:   
  841:             {
  842:                currentTimer->intervalInTicks = 0;
  01c9 9efe05   [5]             LDHX  5,SP
  01cc 7f       [4]             CLR   ,X
  01cd 6f01     [5]             CLR   1,X
  01cf 2027     [3]             BRA   L1F8 ;abs = 01f8
  01d1          L1D1:   
  843:                currentTimer->countDown = 0;
  844:             }
  845:           }
  846:           /* here the timer is a millisecond one (single shot or interval)*/
  847:           else 
  848:  #endif  /* gTMR_EnableMinutesSecondsTimers_d */
  849:           {
  850:             /* how many millisecond counts the timer */
  851:             durationMillis = TmrMillisecondsFromTicks(currentTimer->countDown);
  01d1 9efe05   [5]             LDHX  5,SP
  01d4 9ece02   [5]             LDHX  2,X
  01d7 4f       [1]             CLRA  
  01d8 89       [2]             PSHX  
  01d9 8b       [2]             PSHH  
  01da 87       [2]             PSHA  
  01db 87       [2]             PSHA  
  01dc 95       [2]             TSX   
  01dd a602     [2]             LDA   #2
  01df cd0000   [6]             JSR   _LLSL
  01e2 af13     [2]             AIX   #19
  01e4 cd0000   [6]             JSR   _POP32
  852:             /* Timer expired when MCU was in sleep mode??? */
  853:             if(durationMillis <= sleepDurationMillisec) 
  01e7 95       [2]             TSX   
  01e8 af13     [2]             AIX   #19
  01ea 89       [2]             PSHX  
  01eb 8b       [2]             PSHH  
  01ec af0c     [2]             AIX   #12
  01ee cd0000   [6]             JSR   _LCMP
  01f1 a704     [2]             AIS   #4
  01f3 2509     [3]             BCS   L1FE ;abs = 01fe
  854:             {
  855:              currentTimer->countDown = 0;
  01f5 9efe05   [5]             LDHX  5,SP
  01f8          L1F8:   
  01f8 6f02     [5]             CLR   2,X
  01fa 6f03     [5]             CLR   3,X
  01fc          L1FC:   
  856:             } 
  01fc 202e     [3]             BRA   L22C ;abs = 022c
  01fe          L1FE:   
  857:             else 
  858:             {
  859:               /* calculate remaining tick to count after wake up */
  860:               durationMillis -= sleepDurationMillisec;
  01fe 95       [2]             TSX   
  01ff af1b     [2]             AIX   #27
  0201 89       [2]             PSHX  
  0202 8b       [2]             PSHH  
  0203 aff4     [2]             AIX   #-12
  0205 cd0000   [6]             JSR   _LSUB
  0208 cd0000   [6]             JSR   _POP32
  861:               currentTimer->countDown = TmrTicksFromMilliseconds(durationMillis);
  020b 95       [2]             TSX   
  020c af0f     [2]             AIX   #15
  020e cd0000   [6]             JSR   _LMUL_RC
  0211 00000139         DC.L  313
  0215 95       [2]             TSX   
  0216 cd0000   [6]             JSR   _LDIVU_RC
  0219 00000500         DC.L  1280
  021d 9efe0d   [5]             LDHX  13,SP
  0220 9ee603   [4]             LDA   3,SP
  0223 e702     [3]             STA   2,X
  0225 9ee604   [4]             LDA   4,SP
  0228 e703     [3]             STA   3,X
  022a a708     [2]             AIS   #8
  022c          L22C:   
  022c 95       [2]             TSX   
  022d 6c03     [5]             INC   3,X
  022f e603     [3]             LDA   3,X
  0231 a122     [2]             CMP   #34
  0233 2403     [3]             BCC   L238 ;abs = 0238
  0235 cc00b5   [4]             JMP   LB5 ;abs = 00b5
  0238          L238:   
  862:             }
  863:  
  864:             
  865:           } /* end if (IsLowPowerSecondTimer(timerType) || IsLowPowerMinuteTimer(timerType)) */
  866:          
  867:     }
  868:  
  869:  }/* end for (timerID = 0;.... */
  870:  
  871:  TpmStartTimerHardware();
  0238 b608     [3]             LDA   8
  023a aa1f     [2]             ORA   #31
  023c b708     [3]             STA   8
  872:  TpmReadCNTRegister(previousTimeInTicks);
  023e b609     [3]             LDA   9
  0240 450000   [3]             LDHX  @mTmrRead16bitReg
  0243 f7       [2]             STA   ,X
  0244 b60a     [3]             LDA   10
  0246 e701     [3]             STA   1,X
  0248 9eae     [5]             LDHX  ,X
  024a 960000   [5]             STHX  previousTimeInTicks
  873:  
  874:  TS_SendEvent(gTimerTaskID, mTMR_Event_c);
  024d c60000   [4]             LDA   gTimerTaskID
  0250 ae01     [2]             LDX   #1
  0252 8c       [1]             CLRH  
  0253 ac000000 [8]             CALL  TS_SendEvent
  0257          L257:   
  875:  }
  0257 a718     [2]             AIS   #24
  0259 8d       [7]             RTC   
  025a          L25A:   
  025a 9efe0d   [5]             LDHX  13,SP
  025d af01     [2]             AIX   #1
  025f 9f       [1]             TXA   
  0260 87       [2]             PSHA  
  0261 8b       [2]             PSHH  
  0262 86       [3]             PULA  
  0263 95       [2]             TSX   
  0264 e704     [3]             STA   4,X
  0266 86       [3]             PULA  
  0267 9efe08   [5]             LDHX  8,SP
  026a 8d       [7]             RTC   
  876:  
  877:  /*****************************************************************************
  878:  ******************************************************************************
  879:  * Private functions
  880:  ******************************************************************************
  881:  *****************************************************************************/
  882:  
  883:  static tmrStatus_t TMR_GetTimerStatus
  884:  (
  885:  tmrTimerID_t timerID
  886:  )
  887:  {
  888:    return maTmrTimerStatusTable[timerID] & mTimerStatusMask_c;
  0000 8c       [1]             CLRH  
  0001 97       [1]             TAX   
  0002 d60000   [4]             LDA   @maTmrTimerStatusTable,X
  0005 a4e0     [2]             AND   #-32
  889:  }
  0007 8d       [7]             RTC   
  890:  
  891:  static void TMR_SetTimerStatus
  892:  (
  893:  tmrTimerID_t timerID, 
  894:  tmrStatus_t status
  895:  )
  896:  {
  0000 87       [2]             PSHA  
  897:    maTmrTimerStatusTable[timerID] = (maTmrTimerStatusTable[timerID] & ~mTimerStatusMask_c) | status;
  0001 8c       [1]             CLRH  
  0002 d60000   [4]             LDA   @maTmrTimerStatusTable,X
  0005 a41f     [2]             AND   #31
  0007 9eea01   [4]             ORA   1,SP
  000a d70000   [4]             STA   @maTmrTimerStatusTable,X
  898:  }
  000d 8a       [3]             PULH  
  000e 8d       [7]             RTC   
  899:  
  900:  /*****************************************************************************/
  901:  
  902:  static tmrTimerType_t TMR_GetTimerType
  903:  (
  904:  tmrTimerID_t timerID
  905:  )
  906:  {
  907:    return maTmrTimerStatusTable[timerID] & mTimerType_c;
  0000 8c       [1]             CLRH  
  0001 97       [1]             TAX   
  0002 d60000   [4]             LDA   @maTmrTimerStatusTable,X
  0005 a41f     [2]             AND   #31
  908:  }
  0007 8d       [7]             RTC   
  909:  
  910:  static void TMR_SetTimerType
  911:  (
  912:  tmrTimerID_t timerID, 
  913:  tmrTimerType_t type
  914:  )
  915:  {
  0000 87       [2]             PSHA  
  916:    maTmrTimerStatusTable[timerID] = (maTmrTimerStatusTable[timerID] & ~mTimerType_c) | type;
  0001 8c       [1]             CLRH  
  0002 d60000   [4]             LDA   @maTmrTimerStatusTable,X
  0005 a4e0     [2]             AND   #-32
  0007 9eea01   [4]             ORA   1,SP
  000a d70000   [4]             STA   @maTmrTimerStatusTable,X
  917:  }
  000d 8a       [3]             PULH  
  000e 8d       [7]             RTC   
  918:  
  919:  
