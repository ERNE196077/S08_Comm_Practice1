ANSI-C/cC++ Compiler for HC08 V-5.0.45 Build 14019, Jan 20 2014

    1:  /*****************************************************************************
    2:  * Non-volatile storage module local implementation.
    3:  *
    4:  * Copyright (c) 2006, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "EmbeddedTypes.h"
   14:  #include "TS_Interface.h"
   15:  
   16:  #include "NV_FlashHAL.h"
   17:  #include "NV_Flash.h"
   18:  #include "FunctionLib.h"
   19:  
   20:  /*****************************************************************************
   21:  ******************************************************************************
   22:  * Private macros
   23:  ******************************************************************************
   24:  *****************************************************************************/
   25:  
   26:  /* Size of a member of a struct. */
   27:  #ifndef MbrSizeof
   28:  #define MbrSizeof(type, member)     (sizeof(((type *) 0)->member))
   29:  #endif
   30:  
   31:  #define  gNVPageMaxOffset_c  (NvSize_t)( sizeof(NvRawPage_t) - sizeof(NvStructuredPageHeader_t))
   32:  
   33:  /* There must be at least one more flash page than there are data sets, to */
   34:  /* allow for one copy of each data set plus a page for a new copy of one */
   35:  /* data set. */
   36:  #if gNvNumberOfRawPages_c <= gNvNumberOfDataSets_c
   37:  #error
   38:  #endif
   39:  
   40:  /* this macro must reflect the bit used for the idle task defined in BeeApp.c */
   41:  #define gIdleTaskNVIntervalEvent_c  ( 1 << 0 )
   42:  
   43:  
   44:  /*****************************************************************************
   45:  ******************************************************************************
   46:  * Private prototypes
   47:  ******************************************************************************
   48:  *****************************************************************************/
   49:  #if gNvStorageIncluded_d
   50:  static index_t NvDataSetIndexFromID(NvDataSetID_t dataSetID);
   51:  static index_t NvFindDataSet(NvDataSetID_t dataSetID);
   52:  static bool_t NvIsValidDataSet(index_t pageIndex);
   53:  static void NvSaveDataSet(index_t dataSetIndex);
   54:   #if gNvMultiStorageIncluded_d
   55:   static bool_t NvInPageMultiSave( index_t dataSetIndex );
   56:   #endif
   57:  static bool_t NvOnePageErase(void); 
   58:  #else
   59:  #define NvDataSetIndexFromID(dataSetID)  0
   60:  #define NvFindDataSet(dataSetID)  0
   61:  #define NvIsValidDataSet(pageIndex)  FALSE
   62:  #define NvSaveDataSet(dataSetIndex)
   63:  #endif /* gNvStorageIncluded_d */
   64:  
   65:  #if gNvSelfTest_d
   66:  static void NvSelfTest(void);
   67:  #endif
   68:  
   69:  /*****************************************************************************
   70:  ******************************************************************************
   71:  * Private type definitions
   72:  ******************************************************************************
   73:  *****************************************************************************/
   74:  
   75:  /* One entry per data set. */
   76:  typedef struct NvDataSetInfo_tag {
   77:    bool_t saveNextInterval;
   78:    NvSaveInterval_t ticksToNextSave;
   79:    NvSaveCounter_t countsToNextSave;
   80:  } NvDataSetInfo_t;
   81:  
   82:  typedef struct NvMultiSavedDataInfo_tag {
   83:    void * pSource;
   84:    NvSize_t sourceLength;
   85:  } NvMultiSavedDataInfo_t;
   86:  
   87:  typedef struct msMarker_tag {
   88:    uint8_t header;
   89:    uint8_t trailer;
   90:  } msMarker_t;
   91:  
   92:  
   93:  /*****************************************************************************
   94:  ******************************************************************************
   95:  * Private memory declarations
   96:  ******************************************************************************
   97:  *****************************************************************************/
   98:  
   99:  #if gNvStorageIncluded_d
  100:  /* Table of dirty flags, one per dataset in NvDataSetDescriptionTable[]. */
  101:  static NvDataSetInfo_t maNvDirtyFlags[gNvNumberOfDataSets_c];
  102:  
  103:  #if gNvMultiStorageIncluded_d
  104:  static  NvMultiSavedDataInfo_t maNvMultiSavedDataInfo[gNvNumberOfDataSets_c];
  105:  #endif
  106:  
  107:  /* Minimum number of calls to NvTimerTick() between saves of a given dataset. */
  108:  NvSaveInterval_t gNvMinimumTicksBetweenSaves = gNvMinimumTicksBetweenSaves_c;
  109:  /* Minimum number of calls to NvSaveOnIdle() between saves of a given dataset. */
  110:  static NvSaveCounter_t gNvCountsBetweenSaves = gNvCountsBetweenSaves_c;
  111:  
  112:  /* If this counter is != 0, do not save to NV Storage. */
  113:  static uint8_t mNvCriticalSectionFlag = 0;
  114:  
  115:  /* The index of the page to be erased in the idle task */
  116:  static uint8_t pageToEraseIdle = gNvInvalidPageIndex_c;
  117:  
  118:  #endif                                  /* gNvStorageIncluded_d */
  119:  
  120:  /* Scratch data sets used by the internal unit test. */
  121:  #if gNvSelfTest_d
  122:  
  123:  #ifdef  gNvNumberOfDataSets_c
  124:  #undef  gNvNumberOfDataSets_c
  125:  #define gNvNumberOfDataSets_c   3
  126:  #endif
  127:  
  128:  /* Data set 1. */
  129:  static uint8_t NvTestDataArray1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  130:  static char NvTestDataString1[] = "For months, we have been triumphantly retreating before a demoralized enemy who is advancing in utter disorder.";
  131:  static uint8_t NvTestDataArray2[] = {222, 173, 190, 239, 0, 222, 202, 251, 173, 0};
  132:  
  133:  static NvDataItemDescription_t const gaNvDataSet01[] = {
  134:    {(void *) NvTestDataArray1,  sizeof(NvTestDataArray1)},
  135:    {(void *) NvTestDataString1, sizeof(NvTestDataString1)},
  136:    {(void *) NvTestDataArray2,  sizeof(NvTestDataArray2)},
  137:    {NULL, 0}
  138:  };
  139:  
  140:  /* Data set 2. */
  141:  static uint8_t scratchValue01 = 0x37;
  142:  static NvDataItemDescription_t const gaNvDataSet02[] = {
  143:    {(void *) &scratchValue01, sizeof(scratchValue01)},
  144:    {NULL, 0}
  145:  };
  146:  
  147:  /* Data set 3. Empty. Test this boundry case. */
  148:  static NvDataItemDescription_t const gaNvDataSet03[] = {
  149:    {NULL, 0}
  150:  };
  151:  
  152:  /* Table of data sets. Required by the NV storage module. */
  153:  /* If the NV storage module's self test flag is on, it will */
  154:  /* use it's own internal copy of this table, so it can't be */
  155:  /* defined here. */
  156:  #define gNvDataSet1ID_c     0x17
  157:  #define gNvDataSet2ID_c     0x99
  158:  #define gNvDataSet3ID_c     0x42
  159:  
  160:  static NvDataSetDescription_t const NvDataSetTable[gNvNumberOfDataSets_c] = {
  161:    { gNvDataSet1ID_c, gaNvDataSet01 },
  162:    { gNvDataSet2ID_c, gaNvDataSet02 },
  163:    { gNvDataSet3ID_c, gaNvDataSet03 }
  164:  };
  165:  #endif                                  /* gNvSelfTest_d */
  166:  
  167:  extern bool_t gNVInit;
  168:  
  169:  /*****************************************************************************
  170:  ******************************************************************************
  171:  * Public functions
  172:  ******************************************************************************
  173:  *****************************************************************************/
  174:  
  175:  /* There may be operations that take place over extended times that must
  176:   * be atomic from the point of view of NV Storage saves. These routines
  177:   * increment/decrement a counter; when the counter is non-zero, no NV
  178:   * saves will be done. Note that this does not affect NV restores.
  179:   */
  180:  
  181:  void NvClearCriticalSection(void) {
  182:  #if gNvStorageIncluded_d
  183:    if(mNvCriticalSectionFlag)  /* dg - in case of set/clear mismatch */
  184:      --mNvCriticalSectionFlag;
  185:  #endif /* gNvStorageIncluded_d */
  186:  }
  0000 8d       [7]             RTC   
  187:  
  188:  
  189:  void NvSetCriticalSection(void)
  190:  {
  191:  #if gNvStorageIncluded_d
  192:    ++mNvCriticalSectionFlag;
  193:  #endif /* gNvStorageIncluded_d */
  194:  }
  0000 8d       [7]             RTC   
  195:  
  196:  
  197:  /****************************************************************************/
  198:  
  199:  /* Called from the idle task to process save-on-next-idle and save-on-count. */
  200:  #if gNvStorageIncluded_d
  201:  void NvIdle(void)
  202:  {
  203:    index_t   i;
  204:    bool_t    bNvOperationPerformed = FALSE;
  205:  
  206:    if (mNvCriticalSectionFlag) {
  207:      return;
  208:    }
  209:    if(!NvOnePageErase())
  210:    {
  211:  	  pageToEraseIdle = gNvInvalidPageIndex_c;
  212:  	  return;
  213:    }
  214:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) 
  215:    {
  216:    #if gNvMultiStorageIncluded_d
  217:      if( (maNvMultiSavedDataInfo[i].pSource != NULL ) && maNvMultiSavedDataInfo[i].sourceLength ) 
  218:        {
  219:        bNvOperationPerformed = TRUE;
  220:        if( FALSE == NvInPageMultiSave(i) )
  221:          {
  222:          NvSaveOnIdle(NvDataSetTable[i].dataSetID) ;
  223:          maNvMultiSavedDataInfo[i].pSource = NULL;
  224:          maNvMultiSavedDataInfo[i].sourceLength = 0;
  225:          }
  226:        }
  227:     #endif  
  228:    
  229:      if (!maNvDirtyFlags[i].countsToNextSave) 
  230:      {
  231:        NvSaveDataSet(i);
  232:        bNvOperationPerformed = TRUE;
  233:        break;
  234:      }
  235:    }
  236:    
  237:    /* Restore the receiver state, if it was closed in order to write information in Flash */
  238:    if(bNvOperationPerformed)
  239:      NvOperationEnd();
  240:  }/* NvIdle() */
  241:  #endif /* gNvStorageIncluded_d */
  242:  
  243:  /****************************************************************************/
  244:  
  245:  /* Return TRUE if the given data set is dirty. */
  246:  #if gNvStorageIncluded_d
  247:  bool_t NvIsDataSetDirty
  248:    (
  249:    NvDataSetID_t dataSetID
  250:   )
  251:  {
  252:    index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
  253:    return (    maNvDirtyFlags[dataSetIndex].saveNextInterval
  254:            || (maNvDirtyFlags[dataSetIndex].countsToNextSave != gNvCountsBetweenSaves_c));
  255:  }/* NvIsDataSetDirty() */
  256:  #endif /* gNvStorageIncluded_d */
  257:  
  258:  /****************************************************************************/
  259:  
  260:  /* Call this once, before calling any other NV function.
  261:   *
  262:   * Any page that does not contain a valid, recognized data set is erased, in
  263:   * preparation for later reuse.
  264:   *
  265:   * It is unlikely, but possible, that there could be more than one copy of one
  266:   * or more data sets in NV storage. Normally the page containing the older
  267:   * version is erased after the new version is written, but a reset at just
  268:   * the wrong time could prevent the erasure.
  269:   *
  270:   * Having more than one copy of any data set is 1) unnecessary, 2) uses space
  271:   * that may be needed for future writes, and 3) would complicate other NV code.
  272:   * This function scans NV storage for alternate versions of the same data set,
  273:   * and if it finds one, erases the older copy (or copies).
  274:   */
  275:  #if gNvStorageIncluded_d
  276:  void NvModuleInit
  277:  (
  278:  	void
  279:  )
  280:  {
  281:  #if gNvDebug_d
  282:  	NvDataItemDescription_t const *pDataItemDescriptions;
  283:  	index_t dataSetIndex;
  284:  	NvSize_t dataSetSize;
  285:  #endif
  286:  	index_t i;
  287:  	index_t pageIndex;
  288:  	struct seqAndID_tag {
  289:  		NvDataSetID_t id;
  290:  		index_t pageIndex;
  291:  		NvDataSetSequenceNumber_t sequenceNumber;
  292:  	} seqAndID[gNvNumberOfRawPages_c];
  293:  	NvStructuredPageHeader_t *pThisHeader;
  294:  	index_t validDataSetsFound = 0;
  295:  #if gNvDebug_d
  296:  	/* The CodeWarrior HCS08 compiler complains about constant == constant. */
  297:  	uint16_t NvMaxDataSetSize = gNvMaxDataSetSize_c;
  298:  #endif
  299:  
  300:  	/* initialize flash layer */
  301:  	NvHalInit();
  302:  
  303:  	/* No data set starts dirty. */
  304:  	for (i = 0; i < gNvNumberOfDataSets_c; ++i)
  305:  	{
  306:  		maNvDirtyFlags[i].countsToNextSave = gNvCountsBetweenSaves;
  307:  	}
  308:  
  309:  	/* Scan for and erase duplicate copies of data sets. This code is very */
  310:  	/* slow (N^2), but it only runs once, and N is small. Data set IDs are */
  311:  	/* arbitrary values, so its necessary to search through the list. */
  312:  
  313:  	/* Visit every raw page. If it isn't a valid data set, and it isn't clean, */
  314:  	/* erase it. */
  315:  	for (pageIndex = 0; pageIndex < gNvNumberOfRawPages_c; ++pageIndex)
  316:  	{
  317:  		if (!NvIsValidDataSet(pageIndex))
  318:  		{
  319:  			NvHalErasePage(maNvRawPageAddressTable[pageIndex],mNvFlashPageEraseCmd_c);
  320:  		}
  321:  		else
  322:  		{
  323:  			/* Add this one to the list of valid pages we've visited. */
  324:  			pThisHeader = &((NvStructuredPage_t *) maNvRawPageAddressTable[pageIndex])->header;
  325:  			seqAndID[validDataSetsFound].id             = pThisHeader->dataSetID;
  326:  			seqAndID[validDataSetsFound].pageIndex      = pageIndex;
  327:  			seqAndID[validDataSetsFound].sequenceNumber = pThisHeader->sequenceNumber;
  328:  
  329:  			/* Does this page contain the same data set as a page we've already visited? */
  330:  			for (i = 0; i < validDataSetsFound; ++i)
  331:  			{
  332:  				if (seqAndID[i].id == pThisHeader->dataSetID)
  333:  				{
  334:  					/* Erase whichever copy has the older sequence number. */
  335:  					/* Mark the erased page so it's ID will never be == a valid page's ID. */
  336:  					if (seqAndID[i].sequenceNumber - pThisHeader->sequenceNumber == 1)
  337:  					{
  338:  						NvHalErasePage(maNvRawPageAddressTable[pageIndex], mNvFlashPageEraseCmd_c);
  339:  						seqAndID[validDataSetsFound].id = gNvInvalidDataSetID_c;
  340:  					}
  341:  					else
  342:  					{
  343:  						NvHalErasePage(maNvRawPageAddressTable[(seqAndID[i].pageIndex)],
  344:  														mNvFlashPageEraseCmd_c);
  345:  						seqAndID[i].id = gNvInvalidDataSetID_c;
  346:  					}
  347:  				}/* if (seqAndID[i].id == ... */
  348:  			}/* for (i = 0; i < ... */
  349:  
  350:  			++validDataSetsFound;
  351:  		}/* if (!NvIsValidDataSet(... else */
  352:  	}/* for (pageIndex = 0; ... */
  353:  
  354:  #if gNvDebug_d
  355:  	/* NVM_Interface.h defines the size of the client area of a page as an */
  356:  	/* unjustified immediate integer constant. Make sure that its correct. */
  357:  	/* Assert if it isn't. */
  358:  	if (NvMaxDataSetSize != MbrSizeof(NvStructuredPage_t, clientData))
  359:  	{
  360:  		for (;;)
  361:  		{ }
  362:  	}
  363:  
  364:  	/* Verify that all of the data sets defined by the client code will */
  365:  	/* fit into the NV storage page size. Doing this once here simplifies */
  366:  	/* other code. */
  367:  	for (dataSetIndex = 0; dataSetIndex < gNvNumberOfDataSets_c; ++dataSetIndex)
  368:  	{
  369:  		pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  370:  		if (!pDataItemDescriptions)
  371:  		{
  372:  			continue;
  373:  		}
  374:  		dataSetSize = 0;
  375:  
  376:  		while (pDataItemDescriptions->length)
  377:  		{
  378:  			dataSetSize += pDataItemDescriptions->length;
  379:  			++pDataItemDescriptions;
  380:  		}
  381:  
  382:  		/* Assert if the data set is too big. */
  383:  		if (dataSetSize > MbrSizeof(NvStructuredPage_t, clientData))
  384:  		{
  385:  			for (;;)
  386:  			{ }
  387:  		}
  388:  	}
  389:  #endif   /* gNvDebug_d */
  390:  
  391:  #if gNvSelfTest_d
  392:  	NvSelfTest();
  393:  #endif
  394:  }/* NvModuleInit() */
  395:  #endif /* gNvStorageIncluded_d */
  396:  
  397:  /****************************************************************************/
  398:  
  399:  /* Search for a specific data structure in NV storage, delimited by a known
  400:   * string at the beginning and end of the struct, and a known structure length.
  401:   * The length includes both strings. The "strings" contain arbitrary bytes;
  402:   * they are not assumed to be null-terminated C strings.
  403:   *
  404:   * This function is only indended for use by by the early startup code (crt0
  405:   * and PlatformInit), which needs to find a struct containing hardware
  406:   * initialization values.
  407:   *
  408:   * At that point in the startup process, the stack is available, but no data
  409:   * in RAM has been initialized yet. ONLY const data (in ROM) is dependable.
  410:   * NvModuleInit() has not been called yet to initialize this module. Be very
  411:   * careful about calling local functions.
  412:   * NvHalInit() has not been called yet. Do not call HAL functions, directly
  413:   * or indirectly.
  414:   *
  415:   * Return a pointer to the NV storage copy of the data if found.
  416:   * Return NULL if not found.
  417:   */
  418:  
  419:  
  420:  /****************************************************************************/
  421:  
  422:  /* Copy the most recent version of a data set from NV storage to RAM. */
  423:  /* Note that the copy will succeed if a valid copy of the data set is found */
  424:  /* in NV storage, regardless of the state of the data set's dirty flag. */
  425:  /* Return TRUE if the copy is successful. */
  426:  bool_t NvRestoreDataSet(NvDataSetID_t dataSetID)
  427:  {
  428:  #if !gNvStorageIncluded_d
  429:  	(void)dataSetID;
  430:  #else	
  431:    NvDataItemDescription_t const *pDataItemDescriptions;
  432:    index_t dataSetIndex;
  433:    index_t pageIndex;
  434:    NvSize_t pageOffset;
  435:  
  436:    /* Find the data set description. */
  437:    dataSetIndex = NvDataSetIndexFromID(dataSetID);
  438:  
  439:    /* Find the data set in NV storage. */
  440:    pageIndex = NvFindDataSet(dataSetID);
  441:    if (pageIndex == gNvInvalidPageIndex_c) {
  442:      return FALSE;
  443:    }
  444:  
  445:    pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  446:  
  447:    /* Start reading just after the page header. */
  448:    pageOffset = sizeof(NvStructuredPageHeader_t);
  449:  
  450:    /* Copy data from the NV storage page to the destination data set. */
  451:    while (pDataItemDescriptions->length) {
  452:      NvHalRead(maNvRawPageAddressTable[pageIndex], pageOffset, pDataItemDescriptions->pointer, pDataItemDescriptions->length);
  453:      pageOffset += pDataItemDescriptions->length;
  454:      ++pDataItemDescriptions;
  455:    }
  456:  
  457:    maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
  458:    maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
  459:  #endif /* gNvStorageIncluded_d */
  460:    return TRUE;
  0000 a601     [2]             LDA   #1
  461:  }/* NvRestoreDataSet() */
  0002 8d       [7]             RTC   
  462:  
  463:  
  464:  /****************************************************************************/
  465:  
  466:  /* Return TRUE if the copy is successful. */
  467:  bool_t NvRestoreMultiSavedData
  468:    (
  469:                                                                                       
  470:    NvDataSetID_t dataSetID , void * pDest , uint16_t destLength
  471:    )
  472:  {
  473:  #if !(gNvStorageIncluded_d && gNvMultiStorageIncluded_d )
  474:      (void)dataSetID;
  475:      (void)pDest;
  476:      (void)destLength;
  477:  #else	
  478:    NvDataItemDescription_t const *pDataItemDescriptions;
  479:    index_t dataSetIndex;
  480:    index_t pageIndex;
  481:    NvSize_t pageOffset, dataOffset;
  482:    uint8_t  *pPageAddress;
  483:      
  484:    dataSetIndex = NvDataSetIndexFromID(dataSetID);
  485:    pageIndex = NvFindDataSet(dataSetID);
  486:  	if (pageIndex == gNvInvalidPageIndex_c)
  487:  	{
  488:  		return FALSE;
  489:  	}
  490:    pPageAddress = maNvRawPageAddressTable[pageIndex];
  491:    pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  492:    pageOffset = sizeof(NvStructuredPageHeader_t);
  493:  
  494:    while (pDataItemDescriptions->length) {
  495:      pageOffset += pDataItemDescriptions->length;
  496:      ++pDataItemDescriptions;
  497:    }
  498:    dataOffset = 0;
  499:   
  500:   while(pageOffset + destLength + sizeof(msMarker_t) <= gNVPageMaxOffset_c ) 
  501:   {
  502:    if( pPageAddress[pageOffset] == 0xff ) 
  503:      {
  504:      break;
  505:      }
  506:    if(*((uint16_t*)(pPageAddress + pageOffset)) == 0x0f0f )
  507:      {
  508:      dataOffset = pageOffset;
  509:      }
  510:    pageOffset += destLength + sizeof(msMarker_t);
  511:   }
  512:   if(dataOffset) 
  513:   {
  514:    NvHalRead(pPageAddress, dataOffset + sizeof(msMarker_t) ,	(uint8_t*)pDest,destLength) ;
  515:   }
  516:  #endif /* (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )*/ 
  517:   return TRUE;
  0000 a601     [2]             LDA   #1
  518:  
  519:    ////////////////////////////////////////////////
  520:  
  521:  }/* NvRestoreMultiSavedData*/
  0002 8d       [7]             RTC   
  522:  
  523:  
  524:  /****************************************************************************/
  525:  
  526:  /* Save the data set on the next call to NvIdle(). */
  527:  /* Use the save-on-count mechanism. */
  528:  void NvSaveOnIdle
  529:  (
  530:  	NvDataSetID_t dataSetID
  531:  )
  532:  {
  533:  #if !gNvStorageIncluded_d
  534:  (void)dataSetID;
  535:  #else
  536:    maNvDirtyFlags[NvDataSetIndexFromID(dataSetID)].countsToNextSave = 0;
  537:  #endif /* gNvStorageIncluded_d */
  538:  }
  0000 8d       [7]             RTC   
  539:  
  540:  
  541:  /****************************************************************************/
  542:  
  543:  void NvInPageMultiSaveOnIdle
  544:  (
  545:  	NvDataSetID_t dataSetID , void * pSource , uint16_t sourceLength
  546:  )
  547:  {
  548:  #if (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )  
  549:    index_t index;
  550:    index = NvDataSetIndexFromID(dataSetID);
  551:    maNvMultiSavedDataInfo[index].pSource = pSource;
  552:    maNvMultiSavedDataInfo[index].sourceLength = sourceLength;  
  553:  #else 
  554:    (void)dataSetID;
  555:    (void)pSource;
  556:    (void)sourceLength; 
  557:    return; 
  558:  #endif
  559:  }
  0000 8d       [7]             RTC   
  560:  
  561:  
  562:  /****************************************************************************/
  563:  void NvSaveOnInterval
  564:    (
  565:    NvDataSetID_t dataSetID
  566:   )
  567:  {
  568:  #if !gNvStorageIncluded_d
  569:  (void)dataSetID;
  570:  #else
  571:    index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
  572:  
  573:    if (!maNvDirtyFlags[dataSetIndex].saveNextInterval)
  574:  	{
  575:      maNvDirtyFlags[dataSetIndex].ticksToNextSave  = gNvMinimumTicksBetweenSaves_c;
  576:      maNvDirtyFlags[dataSetIndex].saveNextInterval = TRUE;
  577:      TS_SendEvent(gIdleTaskID, gIdleTaskNVIntervalEvent_c);
  578:    }
  579:  #endif /* gNvStorageIncluded_d */
  580:  }/* NvSaveOnInterval() */
  0000 8d       [7]             RTC   
  581:  
  582:  
  583:  /****************************************************************************/
  584:  
  585:  /* Decrement the counter. Once it reaches 0, the next call to NvIdle() will */
  586:  /* save the data set. */
  587:  void NvSaveOnCount
  588:    (
  589:    NvDataSetID_t dataSetID
  590:   )
  591:  {
  592:  #if !gNvStorageIncluded_d
  593:  (void)dataSetID;
  594:  #else
  595:    index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
  596:  
  597:    if (maNvDirtyFlags[dataSetIndex].countsToNextSave) {
  598:      --maNvDirtyFlags[dataSetIndex].countsToNextSave;
  599:    }
  600:  #endif /* gNvStorageIncluded_d */
  601:  }/* NvSaveOnCount() */
  0000 8d       [7]             RTC   
  602:  
  603:  /****************************************************************************/
  604:  
  605:  /* Set the timer used by NvSaveOnInterval(). Takes effect after the next */
  606:  /* save. */
  607:  void NvSetMinimumTicksBetweenSaves
  608:    (
  609:    NvSaveInterval_t newInterval
  610:   )
  611:  {
  612:  #if !gNvStorageIncluded_d	
  613:     (void)newInterval;
  614:  #else
  615:     gNvMinimumTicksBetweenSaves = newInterval;
  616:  #endif  
  617:  }/* NvSetMinimumTicksBetweenSaves() */
  0000 8d       [7]             RTC   
  618:  
  619:  /****************************************************************************/
  620:  
  621:  /* Set the counter trigger value used by NvSaveOnCount(). Takes effect */
  622:  /* after the next save. */
  623:  void NvSetCountsBetweenSaves
  624:    (
  625:    NvSaveCounter_t newCounter
  626:   )
  627:  {
  628:  #if !gNvStorageIncluded_d
  629:    (void)newCounter;
  630:  #else 	
  631:    gNvCountsBetweenSaves = newCounter;
  632:  #endif /* gNvStorageIncluded_d */  
  633:  }/* NvSetCountsBetweenSaves() */
  0000 8d       [7]             RTC   
  634:  
  635:  /****************************************************************************/
  636:  /* Called from the idle task to process save-on-interval requests. */
  637:  /* Returns FALSE if the timer tick counters for all data sets have reached */
  638:  /* zero. In this case, the timer can be turned off. */
  639:  /* Returns TRUE if any of the data sets' timer tick counters have not yet */
  640:  /* counted down to zero. In this case, the timer should be active. */
  641:  bool_t NvTimerTick(bool_t countTick)
  642:  {
  643:  #if !gNvStorageIncluded_d
  644:    (void)countTick;
  645:    return 0;
  0000 4f       [1]             CLRA  
  646:  #else	
  647:    index_t i;
  648:    bool_t fTicksLeft = FALSE;
  649:    NvDataSetInfo_t *pDirtyFlags;
  650:  
  651:    if (countTick) {
  652:      pDirtyFlags = maNvDirtyFlags;
  653:      for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
  654:        
  655:        if(pDirtyFlags->ticksToNextSave)
  656:          --(pDirtyFlags->ticksToNextSave);
  657:        if(pDirtyFlags->ticksToNextSave)
  658:          fTicksLeft = TRUE;
  659:        if (pDirtyFlags->saveNextInterval && !pDirtyFlags->ticksToNextSave)
  660:        {       
  661:            pDirtyFlags->countsToNextSave = 0;       
  662:        }
  663:  
  664:        ++pDirtyFlags;
  665:      }
  666:    }
  667:    return fTicksLeft;
  668:  #endif /* gNvStorageIncluded_d */
  669:  }/* NvTimerTick() */
  0001 8d       [7]             RTC   
  670:  
  671:  /*****************************************************************************
  672:  ******************************************************************************
  673:  * Private functions
  674:  ******************************************************************************
  675:  *****************************************************************************/
  676:  
  677:  /* Compare two data set sequence numbers. */
  678:  /* Return   -1 if left  < right */
  679:  /*           0 if left == right */
  680:  /*           1 if left  > right */
  681:  /* Data set sequence numbers are unsigned, and modulo a power of two. Thus, */
  682:  /* 0 > (unsigned) -1. */
  683:  /* #if gNvStorageIncluded_d */
  684:  /* int8_t NvCmpSequenceNumbers */
  685:  /*   (*/
  686:  /*   uint8_t left, */
  687:  /*   uint8_t right */
  688:  /*  ) */
  689:  /* { */
  690:  /*   if (left == right) { */
  691:  /*     return 0; */
  692:  /*   } */
  693:  
  694:  /*   if ((left - right) & 0x80) { */
  695:  /*     return -1; */
  696:  /*   } */
  697:  
  698:  /*   return 1; */
  699:  /* }                                       /\* NvCmpSequenceNumbers() *\/ */
  700:  /* #endif                                  /\* #if gNvStorageIncluded_d *\/ */
  701:  
  702:  /****************************************************************************/
  703:  
  704:  /* Given a data set ID, return it's index in the NvDataSetTable[].
  705:   * Data set IDs are arbitrary values, so they have to be searched for.
  706:   */
  707:  #if gNvStorageIncluded_d
  708:  static index_t NvDataSetIndexFromID
  709:    (
  710:    NvDataSetID_t dataSetID
  711:   )
  712:  {
  713:    index_t i;
  714:  
  715:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
  716:      if (NvDataSetTable[i].pItemDescriptions
  717:           && (NvDataSetTable[i].dataSetID == dataSetID)) {
  718:        return i;
  719:      }
  720:    }
  721:  
  722:    /* Can't find it. Must be a programming error in the caller. There's */
  723:    /* no good way to handle errors, but at least this makes it obvious */
  724:    /* during debugging. */
  725:    for (;;) { }
  726:  }/* NvDataSetIndexFromID() */
  727:  #endif /* gNvStorageIncluded_d */
  728:  
  729:  /****************************************************************************/
  730:  
  731:  /* Search NV storage for a given data set. Return it's index if it is found */
  732:  /* and is valid. Return gNvInvalidPageIndex_c otherwise. */
  733:  #if gNvStorageIncluded_d
  734:  static index_t NvFindDataSet
  735:    (
  736:    NvDataSetID_t dataSetID
  737:   )
  738:  {
  739:    index_t i;
  740:  
  741:    for (i = 0; i < gNvNumberOfRawPages_c; ++i) {
  742:      if (((NvStructuredPage_t *) maNvRawPageAddressTable[i])->header.dataSetID == dataSetID) {
  743:        return i;
  744:      }
  745:    }
  746:  
  747:    return gNvInvalidPageIndex_c;
  748:  }/* NvFindDataSet() */
  749:  #endif                                  /* gNvStorageIncluded_d */
  750:  
  751:  /****************************************************************************/
  752:  
  753:  /* Examine an NV storage page. Check the magic number, check that the header
  754:   * and trailer match, and check that the data set ID is recognized by the
  755:   * application's table of data set descriptions.
  756:   * Return TRUE if it looks legit; FALSE otherwise.
  757:   */
  758:  #if gNvStorageIncluded_d
  759:  static bool_t NvIsValidDataSet
  760:    (
  761:    index_t pageIndex
  762:   )
  763:  {
  764:    bool_t legitDataSetID;
  765:    index_t i;
  766:    NvStructuredPage_t *pPage = ((NvStructuredPage_t *) maNvRawPageAddressTable[pageIndex]);
  767:  
  768:    /* Is the data set ID legit? */
  769:    for (legitDataSetID = FALSE, i = 0; i < gNvNumberOfDataSets_c; ++i) {
  770:      if (NvDataSetTable[i].dataSetID
  771:           && (NvDataSetTable[i].dataSetID == pPage->header.dataSetID)) {
  772:        legitDataSetID = TRUE;
  773:        break;
  774:      }
  775:    }
  776:  
  777:    /* Do the header and trailer match? */
  778:    /* Is the magic number legit? */
  779:    if (legitDataSetID
  780:         && FLib_MemCmp(&pPage->header, &pPage->trailer, sizeof(pPage->header))
  781:         && (pPage->header.magicNumber == mNvMagicNumber_c)) {
  782:      return TRUE;
  783:    }
  784:  
  785:    return FALSE;
  786:  }                                       /* NvIsValidDataSet() */
  787:  #endif                                  /* gNvStorageIncluded_d */
  788:  
  789:  /****************************************************************************/
  790:  /*
  791:  Save the contents of a data set, regardless of the state of the set's
  792:   * dirty flag. Always writes a full page.
  793:   *
  794:   * Retry if the HAL reports an error. There isn't anything that the caller
  795:   * can do about errors, so reporting one would be pointless.
  796:   *
  797:   * The flash controller reports errors that it detects, but power supply
  798:   * fluctuations may still cause undetected errors. Its tempting to compute
  799:   * some kind of checksum, and verify it after write, and also when a data
  800:   * set is restored. This would complicate the code somewhat, and may not
  801:   * be a common enough problem to be worth the extra code space.
  802:   */
  803:  #if gNvStorageIncluded_d
  804:  static void NvSaveDataSet
  805:    (
  806:    index_t dataSetIndex
  807:   )
  808:  {
  809:    NvDataItemDescription_t const *pDataItemDescriptions;
  810:    NvDataSetID_t dataSetID;
  811:  
  812:    index_t oldDataSetPageIndex;
  813:    NvStructuredPageHeader_t pageHeader;
  814:    index_t pageIndex;
  815:    NvSize_t pageOffset;
  816:    uint8_t retries;
  817:    bool_t status;                        /* FALSE on HAL error. */
  818:    unsigned char hexFF = 0xff;
  819:    
  820:    pageToEraseIdle=gNvInvalidPageIndex_c;
  821:    /* Search for an unused page. Almost as fast as keeping an array of */
  822:    /* page status flags, and uses less RAM. */
  823:  	for (pageIndex = 0; pageIndex < gNvNumberOfRawPages_c; ++pageIndex)
  824:  	{
  825:  		if (!NvIsValidDataSet(pageIndex))
  826:  			break;
  827:  	}
  828:  
  829:    /* There should always be an available page. If there isn't, there is */
  830:    /* either an internal error in this code or the application, or there's */
  831:    /* hardware failure. Either way, there's nothing that can be done about */
  832:    /* it except to ignore the attempted write. */
  833:    if(pageIndex >= gNvNumberOfRawPages_c)
  834:      return;
  835:  
  836:    dataSetID = NvDataSetTable[dataSetIndex].dataSetID;
  837:  
  838:    /* Set up the page header/trailer. */
  839:    pageHeader.magicNumber = mNvMagicNumber_c;
  840:    pageHeader.dataSetID = dataSetID;
  841:  
  842:    oldDataSetPageIndex = NvFindDataSet(dataSetID);
  843:  	if (oldDataSetPageIndex == gNvInvalidPageIndex_c)
  844:  	{
  845:  		pageHeader.sequenceNumber = 0;
  846:  	}
  847:  	else
  848:  	{
  849:  		pageHeader.sequenceNumber =
  850:  		((NvStructuredPage_t *) maNvRawPageAddressTable[oldDataSetPageIndex])->header.sequenceNumber + 1;
  851:  	}
  852:  
  853:    /* Keep trying until either it works, or it fails often enough that */
  854:    /* it is unlikely to ever work. */
  855:    NvOperationStart();
  856:    retries = mNvFlashCmdRetries_c;
  857:  	while (retries--)
  858:  	{
  859:  		pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  860:  		pageOffset = 0;
  861:  
  862:  		/* Write the page header to the beginning of the page. */
  863:  		status = NvHalWrite(maNvRawPageAddressTable[pageIndex],
  864:  												pageOffset,
  865:  												(unsigned char *) &pageHeader,
  866:  												sizeof(pageHeader));
  867:  		pageOffset += sizeof(pageHeader);
  868:  
  869:  		/* Write the client data to the page. Note that the sizes of all of the
  870:  			data sets in NvDataSetTable[] were validated in NvModuleInit(), so it
  871:  			isn't necesary to check it here. */
  872:  		while (status && pDataItemDescriptions->length)
  873:  		{
  874:  			status = NvHalWrite(maNvRawPageAddressTable[pageIndex],
  875:  			pageOffset, pDataItemDescriptions->pointer, pDataItemDescriptions->length);
  876:  			pageOffset += pDataItemDescriptions->length;
  877:  			++pDataItemDescriptions;
  878:  		}
  879:  
  880:  		/* Pad to the end of the page's data field. The HAL does not allow writing
  881:  			partial pages, but it doesn't check. */
  882:  		while (status && (pageOffset < sizeof(NvRawPage_t) - sizeof(pageHeader)))
  883:  		{
  884:  			status = NvHalWrite(maNvRawPageAddressTable[pageIndex],
  885:  													pageOffset,
  886:  													&hexFF,
  887:  													sizeof(hexFF));
  888:  			pageOffset += sizeof(hexFF);
  889:  		}
  890:  
  891:  		/* Write the terminal copy of the header. If this works, we're done. */
  892:  		if (status && NvHalWrite(maNvRawPageAddressTable[pageIndex], pageOffset,
  893:  														(unsigned char *) &pageHeader, sizeof(pageHeader)))
  894:  		{
  895:  			break;
  896:  		}
  897:  
  898:  		/* Something didn't work. Erase the page and try again. */
  899:  		NvHalErasePage(maNvRawPageAddressTable[pageIndex],mNvFlashPageEraseCmd_c);
  900:  	}/* while (retries--) */
  901:  
  902:  	/* If it didn't work, don't update anything. */
  903:  	if (status)
  904:  	{
  905:  		/* The new copy is safe. Erase the old one. Rereading the data set to
  906:  			verify that it wrote correctly would be safer, but it would also be
  907:  			slower and would take more code. */
  908:  		if (oldDataSetPageIndex != gNvInvalidPageIndex_c)
  909:  		{
  910:  			pageToEraseIdle = oldDataSetPageIndex;			
  911:  		}
  912:  		maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
  913:      maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
  914:  	}/* if (status) */	
  915:  }/* NvSaveDataSet() */
  916:  #endif                                  /* gNvStorageIncluded_d */
  917:  
  918:  /****************************************************************************/
  919:  #if gNvStorageIncluded_d
  920:  static bool_t NvOnePageErase(void)
  921:  {
  922:  	if (pageToEraseIdle != gNvInvalidPageIndex_c)
  923:  	{
  924:  		NvHalErasePage(maNvRawPageAddressTable[pageToEraseIdle], mNvFlashPageEraseCmd_c);
  925:  		return FALSE;
  926:  	}
  927:  	return TRUE;
  928:  }
  929:  #endif /* gNvStorageIncluded_d */
  930:  /****************************************************************************/
  931:  
  932:  #if (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )
  933:  
  934:  static bool_t NvInPageMultiSave
  935:    (
  936:    index_t dataSetIndex
  937:    )
  938:  {
  939:    NvDataItemDescription_t const *pDataItemDescriptions;
  940:    NvDataSetID_t dataSetID;
  941:    uint8_t  *pPageAddress;
  942:    msMarker_t msMarker;
  943:    index_t pageIndex;
  944:    NvSize_t pageOffset;
  945:    
  946:    dataSetID = NvDataSetTable[dataSetIndex].dataSetID;
  947:    pageIndex = NvFindDataSet(dataSetID);
  948:  	if (pageIndex == gNvInvalidPageIndex_c)
  949:  	{
  950:  	//	return FALSE;
  951:  	// there is no saved page with this ID  
  952:  	for(;;){}
  953:  	  //  for debug purposes 
  954:  	}
  955:    pPageAddress = maNvRawPageAddressTable[pageIndex];
  956:    pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  957:    pageOffset = sizeof(NvStructuredPageHeader_t);
  958:  
  959:    while (pDataItemDescriptions->length) {
  960:      pageOffset += pDataItemDescriptions->length;
  961:      ++pDataItemDescriptions;
  962:    }
  963:  
  964:  NvOperationStart();
  965:  for(;;)
  966:  {
  967:    if ((pageOffset + maNvMultiSavedDataInfo[dataSetIndex].sourceLength + sizeof(msMarker_t)) > gNVPageMaxOffset_c ) 
  968:      {
  969:       return FALSE;
  970:      }
  971:    if(pPageAddress[pageOffset] == 0xff ) 
  972:      {
  973:      msMarker.header = 0xf;
  974:      msMarker.trailer = 0xf;
  975:      if(TRUE == NvHalUnbufferedWrite( pPageAddress , pageOffset , &msMarker.header , 1) )
  976:        {
  977:        if(TRUE == NvHalUnbufferedWrite( pPageAddress , pageOffset + sizeof(msMarker_t) , (uint8_t*)maNvMultiSavedDataInfo[dataSetIndex].pSource , maNvMultiSavedDataInfo[dataSetIndex].sourceLength )) 
  978:          {
  979:           if(TRUE == NvHalUnbufferedWrite( pPageAddress , pageOffset + sizeof(msMarker.header) , &msMarker.trailer , 1)) 
  980:           {
  981:            maNvMultiSavedDataInfo[dataSetIndex].pSource = NULL;
  982:            maNvMultiSavedDataInfo[dataSetIndex].sourceLength = 0;
  983:            
  984:            return TRUE;
  985:           }
  986:          }
  987:        } 
  988:      else 
  989:       {
  990:        if(pPageAddress[pageOffset] == 0xff ) 
  991:          {
  992:           return FALSE;
  993:          }
  994:       }
  995:        
  996:      }
  997:    pageOffset += maNvMultiSavedDataInfo[dataSetIndex].sourceLength + sizeof(msMarker_t);
  998:   }
  999:   
 1000:  
 1001:  }/* NvInPageMultiSave */
 1002:  #endif                                  /* (gNvStorageIncluded_d && gNvMultiStorageIncluded_d ) */
 1003:  
 1004:  
 1005:  /****************************************************************************/
 1006:  
 1007:  /* Unit test. This is a debugging aid; it isn't intended to test every */
 1008:  /* possible case. It isn't even a good smoke test. It doesn't try to */
 1009:  /* insure completely correct operation; the calls to NvSelfTestError() are */
 1010:  /* only intended to provide convenient places to put debugger breakpoints. */
 1011:  
 1012:  #if gNvSelfTest_d
 1013:  
 1014:  uint8_t NvSelfTestErrors = 0;
 1015:  static void NvSelfTestError(void)
 1016:  {
 1017:    NvSelfTestErrors++;
 1018:  }
 1019:  
 1020:  static void NvSelfTest()
 1021:  {
 1022:    uint8_t buf[16];
 1023:    index_t i;
 1024:    unsigned char const *p = NULL;
 1025:  
 1026:    /* Test valid page recognition for invalid pages. */
 1027:    for (i = 0; i < gNvNumberOfRawPages_c; ++i) {
 1028:      if (NvIsValidDataSet(i)) {
 1029:        NvSelfTestError();
 1030:      }
 1031:    }
 1032:  
 1033:    /* Write some data sets. */
 1034:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
 1035:      NvSaveDataSet(NvDataSetTable[i].dataSetID);
 1036:    }
 1037:  
 1038:  
 1039:    /* Copy some data, change it, and restore the data set. */
 1040:  
 1041:    for (i = 0; i < sizeof(NvTestDataArray2); ++i) {
 1042:      buf[i] = NvTestDataArray2[i];
 1043:      NvTestDataArray2[i] = 0;
 1044:    }
 1045:  
 1046:    if (!NvRestoreDataSet(gNvDataSet1ID_c)) {
 1047:      NvSelfTestError();
 1048:    }
 1049:  
 1050:    for (i = 0; i < sizeof(NvTestDataArray2); ++i) {
 1051:      if (buf[i] != NvTestDataArray2[i]) {
 1052:        NvSelfTestError();
 1053:      }
 1054:    }
 1055:  
 1056:    /* Try writing a new version of each data set. */
 1057:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
 1058:      NvSaveDataSet(NvDataSetTable[i].dataSetID);
 1059:    }
 1060:  }                                       /* NvSelfTest() */
 1061:  #endif                                  /* #if gNvSelfTest_d */
 1062:  
