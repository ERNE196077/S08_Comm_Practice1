ANSI-C/cC++ Compiler for HC08 V-5.0.45 Build 14019, Jan 20 2014

    1:  /*****************************************************************************
    2:  * Touchpad Hardware Abstraction Layer
    3:  *
    4:  * Copyright (c) 2010, Freescale, Inc. All rights reserved
    5:  *
    6:  * No part of this document must be reproduced in any form - including copied,
    7:  * transcribed, printed or by any electronic means, - without specific written 
    8:  * permission from Freescale Semiconductor
    9:  * 
   10:  *****************************************************************************/
   11:  
   12:  #include "EmbeddedTypes.h"
   13:  #include "IrqControlLib.h"
   14:  #include "IoConfig.h"
   15:  #include "TS_Interface.h"
   16:  #include "Touchpad_Interface.h"
   17:  #include "Touchpad.h"
   18:  #include "IIC_Interface.h"
   19:  #include "FunctionLib.h"
   20:  
   21:  
   22:  
   23:  #pragma MESSAGE DISABLE C4001 // Warning C4001: Condition always FALSE
   24:  
   25:  
   26:  /*****************************************************************************
   27:  ******************************************************************************
   28:  * Private macros 
   29:  ******************************************************************************
   30:  *****************************************************************************/
   31:  /* Touchpad events */
   32:  #define gTP_Event_WriteBlockSuccess_c       (1<<1)
   33:  #define gTP_Event_WriteBlockFail_c          (1<<2)
   34:  #define gTP_Event_ReadBlockSuccess_c        (1<<3)
   35:  #define gTP_Event_ReadBlockFail_c           (1<<4)
   36:  #define gTP_Event_ISR_c                     (1<<5)
   37:  
   38:  #define gTP_I2cTransfOperMaxSize_c          (8)
   39:  #define gTP_DataTableMaxSize_c              (20) 
   40:  #define gTP_RmiAddrByteSize_c               (1)
   41:  
   42:  #define gWriteBlockMaxSize_c                (16)
   43:  /* In debug mode some table's elements are automatically cleared for more readability */                                          
   44:  #define DEBUG_MODE_ENABLE                   (0)  
   45:  
   46:  /* Table operations sizes for each touchpad process */
   47:  #define gTP_DevRestart_TransfOperNo_c       (1)
   48:  #define gTP_GetDevInfo_TransfOperNo_c       (4)
   49:  #define gTP_GetDevConfig_TransfOperNo_c     (2)
   50:  #define gTP_SetDevConfig_TransfOperNo_c     (5)
   51:  #define gTP_Isr_TransfOperNo_c              (2)
   52:  
   53:  /*****************************************************************************
   54:  ******************************************************************************
   55:  * Private type definitions 
   56:  ******************************************************************************
   57:  *****************************************************************************/
   58:  
   59:  /* Type of operation */
   60:  typedef enum
   61:  {
   62:    mTP_OperType_Read_c  = 0,     
   63:    mTP_OperType_Write_c  
   64:  } tpOperType_t;
   65:               
   66:  /* Structure used to define the entry element in the table of operations */
   67:  typedef struct tpI2cTransfOper_tag  
   68:  {   
   69:    uint8_t             regAddr;
   70:    uint8_t*            pBuff;
   71:    uint8_t             buffLength;     
   72:    tpOperType_t        tpOperType;
   73:  } tpI2cTransfOper_t;
   74:    
   75:               
   76:  /* Structure to control the RMI operation over the IIC */
   77:  typedef struct 
   78:  {   
   79:    bool_t                accessLock;
   80:    tpI2cTransfOper_t     rmiBlockAccess;    
   81:  } rmiBlockAccess_t;
   82:  
   83:  /*****************************************************************************
   84:  ******************************************************************************
   85:  * Private memory declaration 
   86:  ******************************************************************************
   87:  *****************************************************************************/
   88:  #if(gTouchpadIncluded_d == 1)
   89:  
   90:  /* Id for the Touchpad task */
   91:  static tsTaskID_t             gTP_TaskId;
   92:  
   93:  static  uint8_t               gTP_IntStatus;
   94:  static  uint8_t               gTP_DevStatus;
   95:  
   96:  /* Variables associated with I2C communication */
   97:  static tpI2cTransfOper_t      maTP_I2cTransfOperTable[gTP_I2cTransfOperMaxSize_c];
   98:  static volatile index_t       maTP_I2cTransfOperNo;             
   99:  static volatile index_t       maTP_I2cOperCurrIndex;
  100:  
  101:  static uint8_t                maDataTable[gTP_DataTableMaxSize_c];
  102:  static rmiBlockAccess_t       gRmiBlockAccess; 
  103:      
  104:  /* Structure containing all information required by the application's callback function */
  105:  tpCallbackInfo_t              gTP_CallbackInfo;
  106:  
  107:  static uint8_t                gWriteBlock[gWriteBlockMaxSize_c]; 
  108:  
  109:  /* Block size used to be read by the touchpad task */
  110:  static uint8_t gBlockSize;    /* However the global variables are cleared at initialization */
  111:  
  112:  /* Variable counting the number of ISR passing during reset operation */
  113:  static volatile uint8_t       gTP_DevResetIdx;
  114:                   
  115:  #endif
  116:  
  117:  /*****************************************************************************
  118:  ******************************************************************************
  119:  * Private function prototypes 
  120:  ******************************************************************************
  121:  *****************************************************************************/
  122:  
  123:  /* TP Task; Process the TP events in interrupt-driven context */
  124:  void TP_Task(event_t events);
  125:  #if(gTouchpadIncluded_d == 1)
  126:    /* TP callback function */
  127:    static void (*pfTpCallback)(tpCallbackInfo_t tpCallbackInfo);
  128:  
  129:    /*****************************************************************************/
  130:    static void TP_SaveDevInfo(void);
  131:    static void TP_SaveDevConfig(void);
  132:    static void TP_UpdateDevConfig(uint8_t mIntEn0Reg, uint8_t mGestEn1Reg); 
  133:    static statusCode_t TP_GetFingerInfo(uint8_t mFingerNum);
  134:    static void TP_GestureRecognition(void);
  135:    static bool_t TP_ReadBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pRxBuff);       
  136:    static bool_t TP_WriteBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pTxBuff);
  137:    static void RmiWriteAddrCallback(bool_t status);
  138:    static void RmiCompleteAccessCallback(bool_t status);
  139:  #endif //(gTouchpadIncluded_d == 1)
  140:  
  141:  /*****************************************************************************
  142:  ******************************************************************************
  143:  * Private functions 
  144:  ******************************************************************************
  145:  *****************************************************************************/
  146:  
  147:  /*****************************************************************************
  148:  * TP_Init
  149:  * 
  150:  * Interface assumption:
  151:  *
  152:  * Return value: generic status code
  153:  *
  154:  * Initialize the touchpad sensor, IIC communication, global variables
  155:  *****************************************************************************/
  156:  statusCode_t TP_Init(void)
  157:  {
  158:  #if(gTouchpadIncluded_d == 1)
  159:    uint8_t retStatus = TP_OK;
  160:  
  161:    if(FALSE == IIC_SetBaudRate(gTP_Default_IIC_CommRate_c))
  162:    {
  163:      retStatus = TP_ERR_IIC_COMM;     
  164:    }
  165:    else
  166:    {
  167:      /* Create the touchpad task */
  168:      gTP_TaskId = TS_CreateTask(gTP_TaskPriority_c, TP_Task); 
  169:      
  170:      if(gTsInvalidTaskID_c != gTP_TaskId)
  171:      {
  172:        /* Set the pointer callback to NULL */
  173:        pfTpCallback = NULL; 
  174:        
  175:        #if(gTP_Mode_c == gTP_IrqIsrMode_c)
  176:          /* IRQ pin settings */
  177:          m_IRQSC_c =(mIRQSC_IRQPE_c | mIRQSC_IRQIE_c | mIRQ_FallingEdge_Sense_c);
  178:        #endif
  179:        #if(gTP_Mode_c == gTP_KbiIsrMode_c)
  180:          /* KBI2P0 pin setting */
  181:          m_KBI2PE_c |= mKBI2PE_KBIPE0_c;
  182:          
  183:          m_KBI2SC_c = mKBI2SC_KBIE_c;
  184:        #endif
  185:        
  186:        /* Initialize the block access flag */
  187:        gRmiBlockAccess.accessLock = FALSE;
  188:        
  189:        /* Clear all values from the global variable responsible for passing the 
  190:           information to the callback */
  191:        FLib_MemSet(&gTP_CallbackInfo, 0, sizeof(tpCallbackInfo_t));
  192:        
  193:        /* Reset the variable which detect the reset operation */
  194:        gTP_DevResetIdx = 0;      
  195:      }
  196:      else
  197:      {
  198:        retStatus = TP_ERR_INVALID_PARAM;
  199:      }
  200:    } 
  201:           
  202:    return retStatus; 
  203:  #else    
  204:    return  TP_OK;
  0000 4f       [1]             CLRA  
  205:  #endif    
  206:  }
  0001 8d       [7]             RTC   
  207:  
  208:  /*****************************************************************************
  209:  * TP_Uninit
  210:  *
  211:  * Interface assumption:
  212:  *
  213:  * Return value: None
  214:  * 
  215:  * Uninit the touchpad sensor, IIC communication, disallocates the memory for 
  216:  * global variable
  217:  *****************************************************************************/
  218:  void TP_Uninit(void)
  219:  {
  220:  #if(gTouchpadIncluded_d == 1)   
  221:    /* Destroy the touchpad task if there is a valid ID */
  222:    if(gTsInvalidTaskID_c != gTP_TaskId)
  223:    {
  224:      TS_DestroyTask(gTP_TaskId);  
  225:    }
  226:    
  227:    #if(gTP_Mode_c == gTP_IrqIsrMode_c)
  228:      /* IRQ pin disable */
  229:      m_IRQSC_c = mIRQSC_Reset_c;
  230:    #endif
  231:    #if(gTP_Mode_c == gTP_KbiIsrMode_c)
  232:      /* KBI2P0 pin disable */
  233:      m_KBI2PE_c &= ~mKBI2PE_KBIPE0_c;
  234:      m_KBI2SC_c = mKBI2SC_Reset_c;
  235:    #endif
  236:  #endif
  237:  }
  0000 8d       [7]             RTC   
  238:  
  239:      
  240:  /*****************************************************************************
  241:  * TP_DevRestart
  242:  * 
  243:  * Interface assumption:
  244:  *
  245:  * Return value: generic status code
  246:  *
  247:  * Reset the touchpad sensor
  248:  * 
  249:  *****************************************************************************/
  250:  statusCode_t TP_DevRestart(void)            
  251:  {    
  252:  #if(gTouchpadIncluded_d == 1)  
  253:    uint8_t retStatus = TP_OK;
  254:    tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  255:               
  256:    /* Store the function id */
  257:    gTP_CallbackInfo.funcId = gTP_DevRestartId_c;
  258:    
  259:    /* Reset the variable counting the External ISR occurence; during reset the 
  260:       external pin interrupt is going twice */
  261:    gTP_DevResetIdx = 0;     
  262:    
  263:    /* Reset the current transfer count */
  264:    maTP_I2cTransfOperNo = gTP_DevRestart_TransfOperNo_c;
  265:   
  266:    /* Prepare the first entry into the action table: Reset sensor */
  267:    *maDataTable = gTP_DevReset_c;   
  268:    pTransfOper->regAddr    = PDT_F01_RMI_COMMAND_BASE + mRMI_DeviceCommand_Offset_c;
  269:    pTransfOper->pBuff      = maDataTable;
  270:    pTransfOper->buffLength = 1;
  271:    pTransfOper->tpOperType = mTP_OperType_Write_c;
  272:      
  273:    /* Prepare the second entry to be read: Interrupt status: this is necessary to deassert the ATTN line again */
  274:    (++pTransfOper)->regAddr  = PDT_F01_RMI_DATA_BASE + mRMI_InterruptStatus_Offset_c; 
  275:    pTransfOper->pBuff        = maDataTable + 1;
  276:    pTransfOper->buffLength   = 1;
  277:    pTransfOper->tpOperType   = mTP_OperType_Read_c;        
  278:    
  279:    #if(DEBUG_MODE_ENABLE == 1)
  280:      /* Clear the remaining entries in the action table after filling with necessary actions */
  281:      FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));     
  282:  
  283:      /* Keep clear the data table */
  284:      FLib_MemSet((maDataTable + maTP_I2cTransfOperNo + 1), 0, (gTP_DataTableMaxSize_c - maTP_I2cTransfOperNo - 1));
  285:    #endif  
  286:    
  287:    /* Prepare one IIC Write operation */
  288:    maTP_I2cOperCurrIndex = 0;
  289:    
  290:    pTransfOper = maTP_I2cTransfOperTable;     
  291:    if(FALSE == TP_WriteBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))      
  292:    {
  293:      retStatus = TP_ERR_IIC_COMM;
  294:    }
  295:     
  296:    return retStatus;
  297:  #else
  298:    return  TP_OK;
  0000 4f       [1]             CLRA  
  299:  #endif   
  300:  }
  0001 8d       [7]             RTC   
  301:  
  302:  
  303:  /*****************************************************************************
  304:  * TP_GetDevInfo
  305:  * 
  306:  * Interface assumption:   This function should be called after calling the 
  307:  *                         TP_DevRestart() in order to get the correct information 
  308:  *
  309:  * Return value: generic status code
  310:  *
  311:  * Collects the information about the device configuration
  312:  *****************************************************************************/
  313:  statusCode_t TP_GetDevInfo(void)
  314:  {                    
  315:  #if(gTouchpadIncluded_d == 1)  
  316:    uint8_t retStatus = TP_OK;
  317:    tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  318:   
  319:    if(gTP_DevResetIdx != 2)
  320:    {
  321:      retStatus = TP_ERR_DEVICE_NOT_READY;
  322:    }
  323:    else
  324:    {
  325:      /* Store the function id */
  326:      gTP_CallbackInfo.funcId = gTP_GetDevInfoId_c;
  327:      
  328:      /* Reset the block size */
  329:      gBlockSize = 0;
  330:      
  331:      /* Fill the array with further operations to be accomplished in the TP_Task */
  332:      maTP_I2cTransfOperNo = gTP_GetDevInfo_TransfOperNo_c;    
  333:      
  334:      /* Prepare the first entry to be read: No of fingers, finger's absolute values, 
  335:      finger's relative values, gesture, sensor adjustement capabilities */
  336:      pTransfOper->regAddr      = PDT_F11_2D_QUERY_BASE + m2D_ReportingMode_Offset_c;  
  337:      pTransfOper->pBuff        = maDataTable;      
  338:      pTransfOper->buffLength   = 1;
  339:      pTransfOper->tpOperType   = mTP_OperType_Read_c;
  340:      
  341:      /* Prepare the second entry to be read: gesture types */
  342:      (++pTransfOper)->regAddr  = PDT_F11_2D_QUERY_BASE + m2D_GestureQuery_Offset_c; 
  343:      pTransfOper->pBuff        = maDataTable + 1;      
  344:      pTransfOper->buffLength   = 2;
  345:      pTransfOper->tpOperType   = mTP_OperType_Read_c;    
  346:       
  347:      /* Prepare the third entry to be read: reporting mode */
  348:      (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_ReportMode_Offset_c; 
  349:      pTransfOper->pBuff        = maDataTable + 3;      
  350:      pTransfOper->buffLength   = 1;
  351:      pTransfOper->tpOperType   = mTP_OperType_Read_c;               
  352:  
  353:      /* Prepare the fourth entry to be read: product id string */   
  354:      (++pTransfOper)->regAddr  = PDT_F01_RMI_QUERY_BASE + mRMI_ProductIdQuery0_Offset_c;
  355:      pTransfOper->pBuff        = maDataTable + 4;       
  356:      pTransfOper->buffLength   = gTP_ProdIdLengthMax_c;
  357:      pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  358:      
  359:      /* Prepare the fifth entry to be read: maximum X and Y position */               
  360:      (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_MaxXPositionLow_Offset_c;
  361:      pTransfOper->pBuff        = maDataTable + 4 + gTP_ProdIdLengthMax_c;
  362:      pTransfOper->buffLength   = 4;
  363:      pTransfOper->tpOperType   = mTP_OperType_Read_c;             
  364:      
  365:      #if(DEBUG_MODE_ENABLE == 1)
  366:        /* Clear the left entries in the action table */
  367:        FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));
  368:                 
  369:        /* Keep clear the data table */
  370:        FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);       
  371:      #endif  
  372:                       
  373:      /* Prepare the first IIC read operation */
  374:      maTP_I2cOperCurrIndex = 0;
  375:       
  376:      pTransfOper = maTP_I2cTransfOperTable;     
  377:      if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))     
  378:      {
  379:        retStatus = TP_ERR_IIC_COMM;
  380:      }    
  381:    }  
  382:     
  383:    return retStatus;
  384:  #else
  385:    return  TP_OK;
  0000 4f       [1]             CLRA  
  386:  #endif   
  387:  }
  0001 8d       [7]             RTC   
  388:  
  389:  
  390:  /*****************************************************************************
  391:  * TP_GetDevConfig
  392:  * 
  393:  * Interface assumption:
  394:  *
  395:  * Return value: generic status code
  396:  *
  397:  * Configure the list of gestures to be identified together with their 
  398:  * associated parameters
  399:  *****************************************************************************/
  400:  statusCode_t TP_GetDevConfig(void)     
  401:  {
  402:  #if(gTouchpadIncluded_d == 1)
  403:    uint8_t retStatus         = TP_OK;
  404:    uint8_t maDataTableIndex  = 0;
  405:    tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  406:    
  407:    if(FALSE == gTP_CallbackInfo.devInfo.mHasGesture)
  408:    {
  409:      retStatus = TP_ERR_INVALID_PARAM;  
  410:    }
  411:    else
  412:    {    
  413:      /* Store the function id */
  414:      gTP_CallbackInfo.funcId = gTP_GetDevConfigId_c; 
  415:      
  416:      /* Fill the array with further operations to be accomplished in the TP_Task */       
  417:      maTP_I2cTransfOperNo = gTP_GetDevConfig_TransfOperNo_c;
  418:      if((TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap) || 
  419:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap) || 
  420:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold))
  421:      {        
  422:        /* Prepare the current entry into the action table: maximum tap time */
  423:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_MaxTapTime_Offset_c;  
  424:        pTransfOper->pBuff        = maDataTable;
  425:        pTransfOper->buffLength   = 1;
  426:        pTransfOper->tpOperType   = mTP_OperType_Read_c;
  427:  
  428:        /* Prepare the current entry into the action table: maximum tap distance */      
  429:        (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_MaxTapDistance_Offset_c; 
  430:        pTransfOper->pBuff        = maDataTable + 1;
  431:        pTransfOper->buffLength   = 1;
  432:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  433:        
  434:        /* Update the table index and transfer number */
  435:        maDataTableIndex +=2;          
  436:        maTP_I2cTransfOperNo +=2;
  437:        pTransfOper++;
  438:      }
  439:  
  440:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasFlick)
  441:      {
  442:        /* Prepare two entries into the action table: minimum flick distance and speed */      
  443:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_MinFlickDistance_Offset_c;  
  444:        pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  445:        pTransfOper->buffLength   = 2;
  446:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  447:        
  448:        /* Update the table index */
  449:        maDataTableIndex +=2; 
  450:        maTP_I2cTransfOperNo++;
  451:        pTransfOper++;         
  452:      }
  453:      
  454:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPress)
  455:      {
  456:        /* Prepare the current entry into the action table: minimum press time */      
  457:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_MinPressTime_Offset_c;  
  458:        pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  459:        pTransfOper->buffLength   = 1;
  460:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  461:        
  462:        /* Update the table index and number of transfers */
  463:        maDataTableIndex++;  
  464:        maTP_I2cTransfOperNo++;
  465:        pTransfOper++;            
  466:      }
  467:      
  468:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPalm)
  469:      {     
  470:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_PalmReject_Offset_c;  
  471:        pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  472:        pTransfOper->buffLength   = 1;
  473:        pTransfOper->tpOperType   = mTP_OperType_Read_c;  
  474:  
  475:        /* Update the table index and number of transfers */
  476:        maDataTableIndex++;  
  477:        maTP_I2cTransfOperNo++;
  478:        pTransfOper++;      
  479:      }       
  480:      
  481:      /* Prepare the read of functions supported by the device */  
  482:      pTransfOper->regAddr      = PDT_F01_RMI_CONTROL_BASE + mRMI_InterruptEnable0_Offset_c;  
  483:      pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  484:      pTransfOper->buffLength   = 1;
  485:      pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  486:      
  487:      /* Update the table index */    
  488:      maDataTableIndex++;
  489:     
  490:      /* Prepare the read of gesture enabled by the device */
  491:      (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_GestureEnable1_Offset_c;  
  492:      pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  493:      pTransfOper->buffLength   = 1;
  494:      pTransfOper->tpOperType   = mTP_OperType_Read_c;
  495:      
  496:      #if(DEBUG_MODE_ENABLE == 1)
  497:        /* Clear the remaining entries in the action table */
  498:        FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));
  499:        
  500:        /* Clear the data table before reading from it */      
  501:        FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);     
  502:      #endif    
  503:        
  504:      /* Prepare the first IIC read operation */
  505:      maTP_I2cOperCurrIndex = 0;
  506:      
  507:      pTransfOper = maTP_I2cTransfOperTable;     
  508:      if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))      
  509:      {
  510:        retStatus = TP_ERR_IIC_COMM;
  511:      }                              
  512:    }
  513:    
  514:    return retStatus; 
  515:  #else
  516:    return  TP_OK;
  0000 4f       [1]             CLRA  
  517:  #endif    
  518:  }
  0001 8d       [7]             RTC   
  519:  
  520:  
  521:  
  522:  /*****************************************************************************
  523:  * TP_SetDevConfig
  524:  * 
  525:  * Interface assumption:
  526:  *
  527:  * Return value: generic status code
  528:  *
  529:  * Configure the list of gestures to be identified together with their 
  530:  * associated parameters
  531:  *****************************************************************************/
  532:  statusCode_t TP_SetDevConfig (devConfig_t mDevConfig)
  533:  {      
  534:  #if(gTouchpadIncluded_d == 1)  
  535:    uint8_t retStatus = TP_OK;
  536:    bool_t  nextStep  = TRUE;
  537:    uint8_t dummy;
  538:    tpI2cTransfOper_t*  pTransfOper = maTP_I2cTransfOperTable;  
  539:         
  540:    if(FALSE == gTP_CallbackInfo.devInfo.mHasGesture)
  541:    {
  542:      retStatus =  TP_ERR_INVALID_PARAM;
  543:    }
  544:    else
  545:    {     
  546:      /* Store the function id */
  547:      gTP_CallbackInfo.funcId = gTP_SetDevConfigId_c;
  548:                      
  549:      /* Clear the data table */
  550:      FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);
  551:         
  552:      /* Prepare the function to be available */ 
  553:      dummy = 0;               
  554:      if(TRUE == mDevConfig.mFuncIntEn.mGpioEn)
  555:      {
  556:        dummy |= gTP_GpioIntMask_c;    
  557:      } 
  558:  
  559:      if(TRUE == mDevConfig.mFuncIntEn.mDevStatusEn)
  560:      {
  561:        dummy |= gTP_StatusIntMask_c;       
  562:      }
  563:      #pragma MESSAGE DISABLE C5917               
  564:      if(TRUE == mDevConfig.mFuncIntEn.mSelfTestEn)
  565:      {          
  566:        dummy |= gTP_BistIntMask_c;                        
  567:      }
  568:           
  569:      if(TRUE == mDevConfig.mFuncIntEn.mFlashEn)
  570:      {
  571:        dummy |= gTP_FlashIntMask_c;       
  572:      }                      
  573:          
  574:      if(TRUE == mDevConfig.mFuncIntEn.mSensorEn)
  575:      {
  576:        dummy |= gTP_Abs0IntMask_c;                  
  577:      }
  578:        
  579:      /* Update the maDataTable[1] */
  580:      maDataTable[1] = dummy;
  581:               
  582:      /* Prepare the gestures available */
  583:      dummy = 0;
  584:      /* Single tap */    
  585:      if(TRUE == mDevConfig.mGestIntEn.mSingleTapIntEn)
  586:      {
  587:        if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap)
  588:        {
  589:          /* Add the 'single tap' to the gesture list */         
  590:          dummy |= gTP_SingleTapMask_c;        
  591:        }
  592:        else
  593:        {
  594:          retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  595:          nextStep = FALSE;        
  596:        }
  597:      }     
  598:      
  599:      /* Double tap */
  600:      if(TRUE == nextStep)
  601:      {       
  602:        if(TRUE == mDevConfig.mGestIntEn.mDoubleTapIntEn)
  603:        {
  604:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap)
  605:          {
  606:            /* Add the 'double tap' to the gesture list */            
  607:            dummy |= gTP_DoubleTapMask_c;               
  608:          }
  609:          else
  610:          {
  611:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  612:            nextStep = FALSE;          
  613:          }
  614:        }                  
  615:      }    
  616:           
  617:      /* Tap and hold */
  618:      if(TRUE == nextStep)
  619:      {         
  620:        if(TRUE == mDevConfig.mGestIntEn.mTapAndHoldIntEn)
  621:        {
  622:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold)
  623:          {
  624:            /* Add the 'tap and hold' to the gesture list */            
  625:            dummy |= gTP_TapAndHoldMask_c;           
  626:          }
  627:          else
  628:          {
  629:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  630:            nextStep = FALSE;           
  631:          }
  632:        }                            
  633:      }        
  634:            
  635:      /* Flick */
  636:      if(TRUE == nextStep)
  637:      {
  638:        if(TRUE == mDevConfig.mGestIntEn.mFlickIntEn)
  639:        {
  640:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasFlick)
  641:          {
  642:            /* Add the 'flick' to the gesture list */            
  643:            dummy |= gTP_FlickMask_c;              
  644:          }
  645:          else
  646:          {
  647:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  648:            nextStep = FALSE;         
  649:          }
  650:        }      
  651:      }
  652:                
  653:      /* Press */
  654:      if(TRUE == nextStep)
  655:      {
  656:        if(TRUE == mDevConfig.mGestIntEn.mPressIntEn)
  657:        {
  658:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPress)
  659:          {
  660:            /* Add the 'press' to the gesture list */               
  661:            dummy |= gTP_PressMask_c;          
  662:          }
  663:          else
  664:          {
  665:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  666:            nextStep = FALSE;          
  667:          }
  668:        }            
  669:      }
  670:      
  671:      /* Pinch */
  672:      if(TRUE == nextStep)
  673:      {
  674:        if(TRUE == mDevConfig.mGestIntEn.mPinchIntEn)
  675:        {
  676:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPinch)
  677:          {
  678:            /* Add the 'pinch' to the gesture list */           
  679:            dummy |= gTP_PinchMask_c;            
  680:          }
  681:          else
  682:          {
  683:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  684:            nextStep = FALSE;          
  685:          }
  686:        }      
  687:      }       
  688:      
  689:      /* Store the configuration to the data table entry 2 */
  690:      maDataTable[2] = dummy; 
  691:      
  692:      /* Prepare for the next config update */
  693:      dummy = 0;    
  694:      /* Palm */
  695:      if(TRUE == nextStep)
  696:      {
  697:        if(TRUE == mDevConfig.mGestIntEn.mPalmIntEn)
  698:        {
  699:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPalm)
  700:          {
  701:            /* Add the 'palm' to the gesture list */            
  702:            dummy |= gTP_PalmMask_c;             
  703:          }
  704:          else
  705:          {
  706:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  707:            nextStep = FALSE;           
  708:          }
  709:        }               
  710:      }
  711:    
  712:      /* Rotate */
  713:      if(TRUE == nextStep)
  714:      {
  715:        if(TRUE == mDevConfig.mGestIntEn.mRotateIntEn)
  716:        {
  717:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasRotate)
  718:          {
  719:            /* Add the 'rotate' to the gesture list */            
  720:            dummy |= gTP_RotateMask_c;          
  721:          }
  722:          else
  723:          {
  724:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  725:            nextStep = FALSE;           
  726:          }
  727:        }                  
  728:      }    
  729:      
  730:      /* Store the remaining of configuration to the data table */
  731:      maDataTable[3] = dummy; 
  732:      
  733:      if(TRUE == nextStep)     
  734:      {             
  735:        /* Fill the table with appropriate operations */
  736:        /* Store the number of operations */
  737:        maTP_I2cTransfOperNo = gTP_SetDevConfig_TransfOperNo_c;
  738:        
  739:        *maDataTable = gTP_Configured_c;
  740:        /* Prepare the first entry into the action table: write the Configure bit in the Device Control Register */
  741:        pTransfOper->regAddr      = PDT_F01_RMI_CONTROL_BASE + mRMI_DeviceControl_Offset_c;  
  742:        pTransfOper->pBuff        = maDataTable;
  743:        pTransfOper->buffLength   = 1;
  744:        pTransfOper->tpOperType   = mTP_OperType_Write_c;
  745:               
  746:        /* Prepare the second entry into the action table: write the list of function to be available */   
  747:        (++pTransfOper)->regAddr  = PDT_F01_RMI_CONTROL_BASE + mRMI_InterruptEnable0_Offset_c; 
  748:        pTransfOper->pBuff        = maDataTable + 1;
  749:        pTransfOper->buffLength   = 1;
  750:        pTransfOper->tpOperType   = mTP_OperType_Write_c;              
  751:        
  752:        /* Prepare the third entry into the action table: write the list of gestures to be enabled */
  753:        (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_GestureEnable1_Offset_c;
  754:        pTransfOper->pBuff        = maDataTable + 2;        
  755:        if(!(*(maDataTable + 3)))           
  756:        {
  757:          pTransfOper->buffLength   = 1;        
  758:        }
  759:        else
  760:        {
  761:          pTransfOper->buffLength   = 2;             
  762:        }
  763:        pTransfOper->tpOperType   = mTP_OperType_Write_c;
  764:                                           
  765:        /* Prepare the fourth entry into the action table: read the Device status in order to check if configuration has done */
  766:        (++pTransfOper)->regAddr  = PDT_F01_RMI_DATA_BASE + mRMI_DeviceStatus_Offset_c; 
  767:        pTransfOper->pBuff        = maDataTable + 4;
  768:        pTransfOper->buffLength   = 1;
  769:        pTransfOper->tpOperType   = mTP_OperType_Read_c;             
  770:        
  771:        /* Prepare the fifth entry into the action table: read the Interrupt enable register to check if configuration has done */
  772:        (++pTransfOper)->regAddr  = PDT_F01_RMI_CONTROL_BASE + mRMI_InterruptEnable0_Offset_c;
  773:        pTransfOper->pBuff        = maDataTable + 5;  
  774:        pTransfOper->buffLength   = 1;
  775:        pTransfOper->tpOperType   = mTP_OperType_Read_c;
  776:        
  777:        /* Prepare the fifth entry into the action table:  read the Gesture Interrupt enable register to check if configuration has done */
  778:        (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_GestureEnable1_Offset_c;
  779:        pTransfOper->pBuff        = maDataTable + 6;  
  780:        pTransfOper->buffLength   = 1;
  781:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  782:                
  783:        #if(DEBUG_MODE_ENABLE == 1) 
  784:          /* Clear the rest of the entries in the action table */
  785:          FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));                                                 
  786:        #endif
  787:        
  788:        /* Prepare the first IIC Write operation */
  789:        maTP_I2cOperCurrIndex = 0;
  790:        
  791:        pTransfOper = maTP_I2cTransfOperTable; 
  792:        if(FALSE == TP_WriteBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  793:        {
  794:          retStatus = TP_ERR_IIC_COMM;     
  795:        }    
  796:      }
  797:    }
  798:     
  799:    return retStatus; 
  800:  #else
  801:    (void)  mDevConfig;
  802:    return  TP_OK;
  0000 4f       [1]             CLRA  
  803:  #endif  
  804:  }
  0001 8d       [7]             RTC   
  805:  
  806:  
  807:  /*****************************************************************************
  808:  * TP_SetCallback
  809:  * 
  810:  * Interface assumption:
  811:  *
  812:  * Return value: generic status code
  813:  *
  814:  * Provides a pointer to the callback function for any touchpad event
  815:  *****************************************************************************/
  816:  statusCode_t TP_SetCallback(tpCallback_t callback)
  817:  {  
  818:  #if(gTouchpadIncluded_d == 1)  
  819:    uint8_t retStatus = TP_OK;
  820:  
  821:    if(NULL == callback)
  822:    {
  823:      retStatus = TP_ERR_INVALID_PARAM;
  824:    }
  825:    else
  826:    {
  827:      pfTpCallback = callback;    
  828:    }
  829:    
  830:    return retStatus;
  831:  #else
  832:    (void) callback;
  833:    return TP_OK;     
  0000 4f       [1]             CLRA  
  834:  #endif    
  835:  }
  0001 8d       [7]             RTC   
  836:  
  837:  
  838:  /****************************************************************************/
  839:  /* Place it in NON_BANKED memory */
  840:  #ifdef MEMORY_MODEL_BANKED
  841:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
  842:  #else
  843:  #pragma CODE_SEG DEFAULT
  844:  #endif  /* MEMORY_MODEL_BANKED */
  845:  /* TP Interrupt Service Routine */
  846:  
  847:  #if(gTP_Mode_c == gTP_PollingMode_c)
  848:  /* When touchpad is used in polling mode, TP_InterruptHandler
  849:  should be called periodically by the application and is not 
  850:  an interrupt handler */
  851:  void TP_InterruptHandler(void)  
  852:  #else
  853:  INTERRUPT_KEYWORD void TP_InterruptHandler(void)
  854:  #endif
  855:  {
  856:  #if(gTouchpadIncluded_d == 1)  
  857:    #if(gTP_Mode_c == gTP_IrqIsrMode_c)
  858:      /* Acknowledge the external IRQ interrupt event */
  859:      m_IRQSC_c |= mIRQSC_IRQACK_c;
  860:    #endif
  861:    #if(gTP_Mode_c == gTP_KbiIsrMode_c)
  862:      /* Acknowledge the KBI2P0 interrupt event */
  863:      m_KBI2SC_c |= mKBI2SC_KBACK_c;
  864:    #endif
  865:    
  866:    if(gTP_CallbackInfo.funcId)
  867:    {
  868:      if(gTP_CallbackInfo.funcId != gTP_DevRestartId_c) 
  869:      {
  870:        /* Store the function identifier */ 
  871:        gTP_CallbackInfo.funcId = gTP_IsrId_c;                                
  872:      }
  873:      else
  874:      {
  875:        gTP_DevResetIdx++;
  876:      }
  877:      
  878:      /* Send event to the TP_Task */
  879:      TS_SendEvent(gTP_TaskId, gTP_Event_ISR_c);                            
  880:    }
  881:          
  882:  #endif    
  883:  }
  0000 81       [6]             RTS   
  884:  #pragma CODE_SEG DEFAULT
  885:  
  886:  #if(gTouchpadIncluded_d == 1) 
  887:    /*****************************************************************************
  888:    * TP_Task
  889:    * 
  890:    * Interface assumption:
  891:    *
  892:    * Return value: generic status code
  893:    *
  894:    * 
  895:    *****************************************************************************/
  896:    void TP_Task(event_t events)  
  897:    { 
  898:      volatile uint8_t iFingerNum;
  899:      uint8_t operType; 
  900:      tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  901:                    
  902:      if(events & gTP_Event_ISR_c)
  903:      { /* Events from the TP_ISR */
  904:        if(gTP_CallbackInfo.funcId == gTP_IsrId_c) 
  905:        {                   
  906:          maTP_I2cTransfOperNo = gTP_Isr_TransfOperNo_c;     
  907:          
  908:          /* Prepare the first entry in the table of actions: Device Status */
  909:          pTransfOper->regAddr      = PDT_F01_RMI_DATA_BASE + mRMI_DeviceStatus_Offset_c;
  910:          pTransfOper->pBuff        = maDataTable;
  911:          pTransfOper->buffLength   = 1;
  912:          pTransfOper->tpOperType   = mTP_OperType_Read_c;         
  913:          
  914:          /* Prepare the second entry in the table of actions: Interrupt status: this should deassert the ATTN line */
  915:          (++pTransfOper)->regAddr  = PDT_F01_RMI_DATA_BASE + mRMI_InterruptStatus_Offset_c;
  916:          pTransfOper->pBuff        = maDataTable + 1;
  917:          pTransfOper->buffLength   = 1;
  918:          pTransfOper->tpOperType   = mTP_OperType_Read_c;        
  919:          
  920:          /* Prepare the third entry into the table of operation: finger info and gestures status */
  921:          (++pTransfOper)->regAddr  = PDT_F11_2D_DATA_BASE + m2D_FingerState_Offset_c;
  922:          pTransfOper->pBuff        = maDataTable + 2;
  923:          pTransfOper->buffLength   = gBlockSize;
  924:          pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  925:  
  926:          #if(DEBUG_MODE_ENABLE == 1)
  927:            /* Clear all entries in the action table before filling with necessary actions */
  928:            FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));
  929:  
  930:            /* Keep clear the data table */
  931:            FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);     
  932:          #endif      
  933:          
  934:          /* Prepare the first IIC read operation */
  935:          maTP_I2cOperCurrIndex = 0;
  936:          
  937:          pTransfOper = maTP_I2cTransfOperTable;
  938:          if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  939:          {
  940:            /* Call the application callback with the error status of the initial function */
  941:            gTP_CallbackInfo.status = FALSE;
  942:            
  943:            pfTpCallback(gTP_CallbackInfo);  
  944:          }           
  945:        }
  946:        else
  947:        {
  948:          if((gTP_CallbackInfo.funcId == gTP_DevRestartId_c) && (gTP_DevResetIdx == 2))      
  949:          {
  950:            /* Send event to the TP_Task */
  951:            TS_SendEvent(gTP_TaskId, gTP_Event_WriteBlockSuccess_c);         
  952:          }
  953:        }
  954:      }
  955:      else if((events & gTP_Event_ReadBlockSuccess_c) || (events & gTP_Event_WriteBlockSuccess_c))
  956:      {
  957:        uint8_t functId = gTP_CallbackInfo.funcId; 
  958:        
  959:        /* The following operations are valid only for 'GetDevInfo()', 'GetGesturesConfig()', 'TP_ISR()', 'SetGesturesList()', 'TP_RestartDevice()' functions */
  960:        if(functId && (functId <= gTP_DevRestartId_c))
  961:        {
  962:          /* Check if the operation is the last one in the list */
  963:          if(++maTP_I2cOperCurrIndex <= maTP_I2cTransfOperNo)
  964:          {
  965:            /* For the device restart function if the reset didn't finished, then take no action */
  966:            if((maTP_I2cOperCurrIndex == 1) && (functId == gTP_DevRestartId_c))
  967:            {
  968:              if(gTP_DevResetIdx < 2) 
  969:              {
  970:                /* Decrement the current transfer (previously incremented in the condition) because the action should not be taken, then leaves the function */
  971:                maTP_I2cOperCurrIndex--;
  972:                return; 
  973:              }
  974:            }
  975:                    
  976:            /* Check the type of the next transfer over the I2C: read or write */
  977:            pTransfOper = maTP_I2cTransfOperTable + maTP_I2cOperCurrIndex;
  978:            operType = pTransfOper->tpOperType;        
  979:            
  980:            if(mTP_OperType_Read_c == operType)
  981:            {                 
  982:              /* Prepare the next transfer over the I2C */
  983:              if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  984:              {
  985:                /* Call the application callback with the error status of the initial function */
  986:                gTP_CallbackInfo.status = FALSE;
  987:              
  988:                pfTpCallback(gTP_CallbackInfo);      
  989:              }               
  990:            }
  991:            else if(mTP_OperType_Write_c == operType)
  992:            {                                                       
  993:              /* Prepare the next transfer over the I2C */
  994:              if(FALSE == TP_WriteBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  995:              {
  996:                /* Call the application callback with the error status of the initial function */        
  997:                gTP_CallbackInfo.status = FALSE;
  998:              
  999:                pfTpCallback(gTP_CallbackInfo);     
 1000:              }          
 1001:            }               
 1002:          }
 1003:          else
 1004:          {     
 1005:            switch(functId)
 1006:            {
 1007:              case gTP_GetDevInfoId_c:
 1008:                      TP_SaveDevInfo();                      
 1009:                                                
 1010:                      /* Update the status of the callback */  
 1011:                      gTP_CallbackInfo.status = TRUE;                                                              
 1012:                      break;
 1013:                
 1014:              case gTP_GetDevConfigId_c:
 1015:                      TP_SaveDevConfig();
 1016:                                                           
 1017:                      /* Update the status of the callback */ 
 1018:                      gTP_CallbackInfo.status = TRUE;                                                                         
 1019:                      break;
 1020:              
 1021:              case gTP_SetDevConfigId_c:                              
 1022:                      /* Call the application callback with the success status of the initial function */                     
 1023:                      gTP_DevStatus = *(maDataTable + 4);
 1024:                      
 1025:                      /* Set the returned status of the function */
 1026:                      if((!(gTP_DevStatus & gTP_Unconfigured_c)) && (*(maDataTable + 1) == *(maDataTable + 5)) && (*(maDataTable + 2) == *(maDataTable + 6)))
 1027:                      {
 1028:                        gTP_CallbackInfo.status = TRUE; 
 1029:                      }
 1030:                      else
 1031:                      {
 1032:                        gTP_CallbackInfo.status = FALSE;
 1033:                      }
 1034:                                       
 1035:                      /* Updates the available function and gesture list */
 1036:                      TP_UpdateDevConfig(*(maDataTable + 5), *(maDataTable + 6)); 
 1037:                      break;
 1038:                
 1039:              case gTP_IsrId_c:
 1040:                      /* Get the Interrupt and Device Status registers information */                                     
 1041:                      gTP_DevStatus = *maDataTable;
 1042:                      gTP_IntStatus = *(maDataTable + 1);
 1043:                      
 1044:                      /* Check if interrupt has occured due to finger presence on the sensor surface */
 1045:                      if(gTP_IntStatus & gTP_Abs0IntMask_c)
 1046:                      {
 1047:                        /* Process information about fingers position */
 1048:                        for(iFingerNum = 0; iFingerNum < gTP_MaxNoOfFingers; iFingerNum++)
 1049:                        {                       
 1050:                          
 1051:                          if(TP_OK != TP_GetFingerInfo(iFingerNum))              
 1052:                          {
 1053:                            /* Call the application callback with the error status of the initial function */   
 1054:                            gTP_CallbackInfo.status = FALSE;
 1055:                          
 1056:                            pfTpCallback(gTP_CallbackInfo);
 1057:                            return;                                        
 1058:                          }                                           
 1059:                        }
 1060:                          
 1061:                        /* Process information about gesture status */
 1062:                        TP_GestureRecognition();                          
 1063:                                                                                           
 1064:                        /* Prepare the status of the callback */             
 1065:                        gTP_CallbackInfo.status = TRUE;
 1066:                      }
 1067:                      else
 1068:                      {
 1069:                        /* Prepare the status of the callback */
 1070:                        gTP_CallbackInfo.status = FALSE;                    
 1071:                      }                                                                                       
 1072:                      break;
 1073:              
 1074:              case gTP_DevRestartId_c:                                    
 1075:                      /* Update the status of the callback */                
 1076:                      gTP_CallbackInfo.status = TRUE;                                                                                                               
 1077:                      break;
 1078:            }
 1079:            
 1080:            /* Call the application callback with the parameters updated */
 1081:            pfTpCallback(gTP_CallbackInfo);
 1082:          }      
 1083:        }   
 1084:      }
 1085:      else if(events & (gTP_Event_ReadBlockFail_c | gTP_Event_WriteBlockFail_c))
 1086:      {
 1087:        uint8_t functId = gTP_CallbackInfo.funcId;
 1088:        
 1089:        /* The following operations are valid only for 'GetDeviceInfo()', 'GetGesturesConfig()', 'TP_ISR()', 'SetGesturesList()', 'TP_RestartDevice()' functions */
 1090:        if(functId && (functId <= gTP_DevRestartId_c))
 1091:        {
 1092:          /* Call the application callback with the error status of the initial function */   
 1093:          gTP_CallbackInfo.status = FALSE;
 1094:              
 1095:          pfTpCallback(gTP_CallbackInfo);       
 1096:        }                        
 1097:      }         
 1098:    }
 1099:  
 1100:  
 1101:    /*****************************************************************************
 1102:    * TP_SaveDevInfo
 1103:    * 
 1104:    * Interface assumption:
 1105:    *
 1106:    * Return value: None
 1107:    *
 1108:    * 
 1109:    *****************************************************************************/
 1110:    static void TP_SaveDevInfo(void)
 1111:    {    
 1112:      uint8_t dummy;
 1113:           
 1114:      /* Fill the appropriate structure of type 'devInfo' with the default values */
 1115:      FLib_MemSet(&(gTP_CallbackInfo.devInfo), 0, sizeof(devInfo_t));
 1116:           
 1117:      /* Save the number of finger and other parameters (abs, rel values, gesture and sensitivity) */
 1118:      gTP_CallbackInfo.devInfo.mNoOfFingers  = (*maDataTable & gTP_NoOfFingersMask_c) + 1;  
 1119:      
 1120:      dummy = *maDataTable;  
 1121:      if(dummy & gTP_AbsModeMask_c)
 1122:      {
 1123:        gTP_CallbackInfo.devInfo.mHasAbs = TRUE;     
 1124:      }  
 1125:      if(dummy & gTP_RelModeMask_c)
 1126:      {
 1127:        gTP_CallbackInfo.devInfo.mHasRel = TRUE;
 1128:      }
 1129:      if(dummy & gTP_GestureMask_c)
 1130:      {
 1131:        gTP_CallbackInfo.devInfo.mHasGesture = TRUE;
 1132:      }
 1133:      if(dummy & gTP_SensAdjMask_c)
 1134:      {
 1135:        gTP_CallbackInfo.devInfo.mHasSensAdj = TRUE;
 1136:      }
 1137:               
 1138:      /* Save the gesture suite supported by the sensor */
 1139:      if(TRUE == gTP_CallbackInfo.devInfo.mHasGesture)
 1140:      {
 1141:        dummy = *(maDataTable + 1);
 1142:        if(dummy & gTP_SingleTapMask_c)
 1143:        {
 1144:          gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap = TRUE;
 1145:        }
 1146:        if(dummy & gTP_DoubleTapMask_c)
 1147:        {
 1148:          gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap = TRUE; 
 1149:        }
 1150:        if(dummy & gTP_TapAndHoldMask_c)
 1151:        {
 1152:          gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold  = TRUE;
 1153:        }
 1154:        if(dummy & gTP_FlickMask_c)
 1155:        {
 1156:          gTP_CallbackInfo.devInfo.mGestList.mHasFlick = TRUE;
 1157:        }
 1158:        if(dummy & gTP_PressMask_c)
 1159:        {
 1160:          gTP_CallbackInfo.devInfo.mGestList.mHasPress = TRUE; 
 1161:        }
 1162:        if(dummy & gTP_PinchMask_c)
 1163:        {
 1164:          gTP_CallbackInfo.devInfo.mGestList.mHasPinch = TRUE; 
 1165:        }
 1166:        
 1167:        dummy = *(maDataTable + 2);
 1168:        if(dummy & gTP_RotateMask_c)
 1169:        {
 1170:          gTP_CallbackInfo.devInfo.mGestList.mHasRotate = TRUE; 
 1171:        }
 1172:        if(dummy & gTP_PalmMask_c)
 1173:        {
 1174:          gTP_CallbackInfo.devInfo.mGestList.mHasPalm = TRUE; 
 1175:        }                              
 1176:      }
 1177:      
 1178:      /* Save the reported mode */
 1179:      gTP_CallbackInfo.devInfo.mReportedMode  = *(maDataTable + 3)  & gTP_ReportingModeMask_c;
 1180:            
 1181:      /* Save the product id string */
 1182:      FLib_MemCpy(gTP_CallbackInfo.devInfo.mProdId, (maDataTable + 4), gTP_ProdIdLengthMax_c);
 1183:           
 1184:      /* Save the maximum X and Y positions */
 1185:      gTP_CallbackInfo.devInfo.mMaxXPos = (uint16_t)(*(maDataTable + gTP_ProdIdLengthMax_c + 4) + (*(maDataTable + gTP_ProdIdLengthMax_c + 5) << 8)); 
 1186:      gTP_CallbackInfo.devInfo.mMaxYPos = (uint16_t)(*(maDataTable + gTP_ProdIdLengthMax_c + 6) + (*(maDataTable + gTP_ProdIdLengthMax_c + 7) << 8)); 
 1187:            
 1188:      /* Update the 'gBlockSize' global variable further used in the TP_Task() function */
 1189:      /* Compute the block size to be read */
 1190:      if(TRUE == gTP_CallbackInfo.devInfo.mHasAbs)
 1191:      {
 1192:        gBlockSize += gTP_FingerAbsValSize_c;        
 1193:      }
 1194:      if(TRUE == gTP_CallbackInfo.devInfo.mHasRel)
 1195:      {
 1196:        gBlockSize += gTP_FingerRelValSize_c;        
 1197:      }
 1198:      /* Increase the total block size with size for each finger info block */
 1199:      gBlockSize *= gTP_CallbackInfo.devInfo.mNoOfFingers;
 1200:      
 1201:      /* Add to the total block size, the size of gesture status list and gestures parameters */
 1202:      gBlockSize += (gTP_GestureStatusSize_c + gTP_GestureInfoSize_c + TP_FingerStateSize(gTP_CallbackInfo.devInfo.mNoOfFingers));              
 1203:    }
 1204:  
 1205:  
 1206:    /*****************************************************************************
 1207:    * TP_SaveDevConfig
 1208:    * 
 1209:    * Interface assumption:
 1210:    *
 1211:    * Return value: None
 1212:    *
 1213:    * 
 1214:    *****************************************************************************/
 1215:    static void TP_SaveDevConfig(void)   
 1216:    {    
 1217:      uint8_t dummy;
 1218:      uint8_t* pDataTable = maDataTable;
 1219:      
 1220:             
 1221:      /* Fill the appropriate structure of type 'devConfig' with default values */
 1222:      FLib_MemSet(&(gTP_CallbackInfo.devConfig), 0, sizeof(devConfig_t));
 1223:      
 1224:      if((TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap) || 
 1225:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap) || 
 1226:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold))
 1227:      {
 1228:          gTP_CallbackInfo.devConfig.mGestConfigParam.mTapConfigParam.mMaximumTapTime      = *(pDataTable++);
 1229:          gTP_CallbackInfo.devConfig.mGestConfigParam.mTapConfigParam.mMaximumTapDistance  = *(pDataTable++);    
 1230:      }
 1231:       
 1232:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasFlick)
 1233:      {
 1234:          gTP_CallbackInfo.devConfig.mGestConfigParam.mFlickConfigParam.mMinimumFlickDistance  = *(pDataTable++);
 1235:          gTP_CallbackInfo.devConfig.mGestConfigParam.mFlickConfigParam.mMinimumFlickSpeed     = *(pDataTable++); 
 1236:      }
 1237:      
 1238:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPress)
 1239:      {
 1240:          gTP_CallbackInfo.devConfig.mGestConfigParam.mPressConfigParam = *(pDataTable++);
 1241:      }
 1242:      
 1243:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPalm)
 1244:      {
 1245:        gTP_CallbackInfo.devConfig.mGestConfigParam.mPalmConfigParam = *(pDataTable++);
 1246:      }
 1247:  
 1248:      /* Save the information about the function and gestures enabled */
 1249:      dummy = *(maDataTable + 6);
 1250:      
 1251:      if(dummy & gTP_FlashIntMask_c)
 1252:      {
 1253:        gTP_CallbackInfo.devConfig.mFuncIntEn.mFlashEn = TRUE;    
 1254:      }
 1255:      if(dummy & gTP_BistIntMask_c)
 1256:      {
 1257:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSelfTestEn = TRUE;
 1258:      }
 1259:      if(dummy & gTP_StatusIntMask_c)
 1260:      {
 1261:        gTP_CallbackInfo.devConfig.mFuncIntEn.mDevStatusEn = TRUE;
 1262:      }
 1263:      if(dummy & gTP_Abs0IntMask_c)
 1264:      {
 1265:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSensorEn = TRUE;
 1266:      }  
 1267:      if(dummy & gTP_GpioIntMask_c)
 1268:      {
 1269:        gTP_CallbackInfo.devConfig.mFuncIntEn.mGpioEn = TRUE;
 1270:      }    
 1271:        
 1272:      /* Gestures enabled */   
 1273:      dummy = *(maDataTable + 7);
 1274:       
 1275:      if(dummy & gTP_PinchMask_c)
 1276:      {
 1277:        gTP_CallbackInfo.devConfig.mGestIntEn.mPinchIntEn = TRUE;    
 1278:      }
 1279:      if(dummy & gTP_PressMask_c)
 1280:      {
 1281:        gTP_CallbackInfo.devConfig.mGestIntEn.mPressIntEn = TRUE;    
 1282:      }
 1283:      if(dummy & gTP_FlickMask_c)
 1284:      {
 1285:        gTP_CallbackInfo.devConfig.mGestIntEn.mFlickIntEn = TRUE;     
 1286:      }
 1287:      if(dummy & gTP_DoubleTapMask_c)
 1288:      {
 1289:        gTP_CallbackInfo.devConfig.mGestIntEn.mDoubleTapIntEn = TRUE;     
 1290:      }
 1291:      if(dummy & gTP_TapAndHoldMask_c)
 1292:      {
 1293:        gTP_CallbackInfo.devConfig.mGestIntEn.mTapAndHoldIntEn = TRUE;     
 1294:      }
 1295:      if(dummy & gTP_SingleTapMask_c)
 1296:      {
 1297:        gTP_CallbackInfo.devConfig.mGestIntEn.mSingleTapIntEn = TRUE;     
 1298:      }                      
 1299:    }
 1300:  
 1301:  
 1302:    /*****************************************************************************
 1303:    * TP_UpdateDevConfig
 1304:    * 
 1305:    * Interface assumption:
 1306:    *
 1307:    * Return value: generic status code
 1308:    *
 1309:    * 
 1310:    *****************************************************************************/
 1311:    static void TP_UpdateDevConfig(uint8_t mIntEn0Reg, uint8_t mGestEn1Reg)   
 1312:    {
 1313:      uint8_t dummy;
 1314:      
 1315:      /* Fill the appropriate structures of types 'funcIntEn_t' and 'gestIntEn_t' with default values */
 1316:      FLib_MemSet(&(gTP_CallbackInfo.devConfig), 0, sizeof(funcIntEn_t) + sizeof(gestIntEn_t));
 1317:        
 1318:      /* Update the function enable interrupt list */
 1319:      dummy = mIntEn0Reg;    
 1320:      if(dummy & gTP_FlashIntMask_c)
 1321:      {
 1322:        gTP_CallbackInfo.devConfig.mFuncIntEn.mFlashEn = TRUE;   
 1323:      }
 1324:      if(dummy & gTP_BistIntMask_c)
 1325:      {
 1326:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSelfTestEn = TRUE;       
 1327:      }
 1328:      if(dummy & gTP_StatusIntMask_c)
 1329:      {
 1330:        gTP_CallbackInfo.devConfig.mFuncIntEn.mDevStatusEn = TRUE;       
 1331:      }
 1332:      if(dummy & gTP_Abs0IntMask_c)
 1333:      {
 1334:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSensorEn = TRUE;       
 1335:      }
 1336:      if(dummy & gTP_GpioIntMask_c)
 1337:      {
 1338:        gTP_CallbackInfo.devConfig.mFuncIntEn.mGpioEn = TRUE;      
 1339:      } 
 1340:      
 1341:      /* Update the gesture enable interrupt list */
 1342:      dummy = mGestEn1Reg; 
 1343:      if(dummy & gTP_PinchMask_c)
 1344:      {
 1345:        gTP_CallbackInfo.devConfig.mGestIntEn.mPinchIntEn = TRUE;    
 1346:      }
 1347:      if(dummy & gTP_PressMask_c)
 1348:      {
 1349:        gTP_CallbackInfo.devConfig.mGestIntEn.mPressIntEn = TRUE;        
 1350:      }
 1351:      if(dummy & gTP_FlickMask_c)
 1352:      {
 1353:        gTP_CallbackInfo.devConfig.mGestIntEn.mFlickIntEn = TRUE;        
 1354:      }
 1355:      if(dummy & gTP_DoubleTapMask_c)
 1356:      {
 1357:        gTP_CallbackInfo.devConfig.mGestIntEn.mDoubleTapIntEn = TRUE;        
 1358:      }
 1359:      if(dummy & gTP_TapAndHoldMask_c)
 1360:      {
 1361:        gTP_CallbackInfo.devConfig.mGestIntEn.mTapAndHoldIntEn = TRUE;        
 1362:      } 
 1363:      if(dummy & gTP_SingleTapMask_c)
 1364:      {
 1365:        gTP_CallbackInfo.devConfig.mGestIntEn.mSingleTapIntEn = TRUE;        
 1366:      }                    
 1367:    }
 1368:  
 1369:  
 1370:    /*****************************************************************************
 1371:    * TP_GetFingerInfo
 1372:    * 
 1373:    * Interface assumption:
 1374:    *
 1375:    * Return value: generic status code
 1376:    *
 1377:    * 
 1378:    *****************************************************************************/
 1379:    static statusCode_t TP_GetFingerInfo(uint8_t mFingerNum)
 1380:    {  
 1381:      statusCode_t  retStatus = TP_OK;
 1382:      uint8_t       mFingerShift, mFingerStateSize;
 1383:      uint8_t       maDataTableIndex;
 1384:      uint8_t*      pDataTable; 
 1385:      fingerInfo_t* pFingerInfo = &gTP_CallbackInfo.fingerInfo[mFingerNum];
 1386:      
 1387:      /* Input parameters checking */  
 1388:      if(mFingerNum > gTP_CallbackInfo.devInfo.mNoOfFingers)
 1389:      {
 1390:        retStatus = TP_ERR_INVALID_PARAM;   
 1391:      }
 1392:      else
 1393:      {
 1394:        mFingerStateSize =(uint8_t) TP_FingerStateSize(gTP_CallbackInfo.devInfo.mNoOfFingers);
 1395:        maDataTableIndex = mFingerStateSize - 1;
 1396:        mFingerShift = (uint8_t)((2*mFingerNum) % 8);    
 1397:           
 1398:        /* Get the status finger */    
 1399:        pFingerInfo->mFingerStatus = (*(maDataTable + maDataTableIndex + 2) >> mFingerShift) & gTP_FingerStateMask_c; 
 1400:        
 1401:        if(TRUE == gTP_CallbackInfo.devInfo.mHasAbs)
 1402:        {
 1403:          if(TRUE == gTP_CallbackInfo.devInfo.mHasRel)
 1404:          {
 1405:            /* Compute the current index in the data table where info about finger are */
 1406:            maDataTableIndex = (mFingerNum * gTP_MaxFingerInfoSize_c) + mFingerStateSize;
 1407:            /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1408:            maDataTableIndex += 2;         
 1409:            
 1410:            /* Update the pointer to the data table */
 1411:            pDataTable = maDataTable + maDataTableIndex + gTP_FingerAbsValSize_c;
 1412:            
 1413:            /* Get the relative values */
 1414:            pFingerInfo->mDeltaX = *(pDataTable);
 1415:            pFingerInfo->mDeltaY = *(pDataTable + 1);
 1416:          }
 1417:          else
 1418:          {
 1419:            /* Compute the current index in the data table where info about finger are */
 1420:            maDataTableIndex = (mFingerNum * gTP_FingerAbsValSize_c) + mFingerStateSize;         
 1421:            /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1422:            maDataTableIndex += 2; 
 1423:            
 1424:            /* Put the relative values to zero */
 1425:            pFingerInfo->mDeltaX = 0;        
 1426:            pFingerInfo->mDeltaY = 0;          
 1427:          }
 1428:          
 1429:          /* Update the pointer to the data table */
 1430:          pDataTable = maDataTable + maDataTableIndex;
 1431:          
 1432:          /* Get the absolute values */
 1433:          /* Get the X, Y position */
 1434:          pFingerInfo->mPosX = ((uint16_t)(*(pDataTable) << 4) + (*(pDataTable + 2) & gTP_LowNibbleMask_c));
 1435:          pFingerInfo->mPosY = ((uint16_t)(*(pDataTable + 1) << 4) + ((*(pDataTable + 2) & gTP_HighNibbleMask_c) >> 4));          
 1436:                         
 1437:          /* Get the finger width for X and Y */
 1438:          pFingerInfo->mWidthX = *(pDataTable + 3) & gTP_LowNibbleMask_c;
 1439:          pFingerInfo->mWidthY = *(pDataTable + 3) >> 4;       
 1440:             
 1441:          /* Get the finger strength */
 1442:          pFingerInfo->mFingerStrength = *(pDataTable + 4);           
 1443:        }
 1444:        else
 1445:        {
 1446:          maDataTableIndex = (mFingerNum * gTP_FingerRelValSize_c) + mFingerStateSize;          
 1447:          /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1448:          maDataTableIndex += 2; 
 1449:          
 1450:          /* Put absolute values to zero */ 
 1451:          pFingerInfo->mPosX = 0;
 1452:          pFingerInfo->mPosY = 0;
 1453:          pFingerInfo->mWidthX = 0;
 1454:          pFingerInfo->mFingerStrength = 0;       
 1455:                
 1456:          /* Get the relative values */ 
 1457:          pFingerInfo->mDeltaX = *(maDataTable + maDataTableIndex);
 1458:          pFingerInfo->mDeltaY = *(maDataTable + maDataTableIndex + 1);             
 1459:        }  
 1460:      }
 1461:                             
 1462:      return retStatus;    
 1463:    }
 1464:  
 1465:    /*****************************************************************************
 1466:    * TP_GestureRecognition
 1467:    * 
 1468:    * Interface assumption:
 1469:    *
 1470:    * Return value: generic status code
 1471:    *
 1472:    * 
 1473:    *****************************************************************************/
 1474:    static void TP_GestureRecognition(void)
 1475:    {    
 1476:      uint8_t maDataTableIndex = 0;
 1477:      uint8_t dummy;
 1478:      uint8_t *pDataTable;
 1479:      
 1480:      /* Fill the appropriate structures of type 'gestStatusList_t' and 'gestInfo_t' with default values */
 1481:      FLib_MemSet(&(gTP_CallbackInfo.gestStatusList), 0, sizeof(gestStatusList_t) + sizeof(gestInfo_t));
 1482:        
 1483:      /* Compute the current index in the data table where info about gesture are */
 1484:      if(TRUE == gTP_CallbackInfo.devInfo.mHasAbs)
 1485:      {
 1486:        maDataTableIndex = gTP_FingerAbsValSize_c;
 1487:      }
 1488:      if(TRUE == gTP_CallbackInfo.devInfo.mHasRel)
 1489:      {
 1490:        maDataTableIndex += gTP_FingerRelValSize_c; 
 1491:      }
 1492:      /* Update the position with the number of fingers */
 1493:      maDataTableIndex *= gTP_CallbackInfo.devInfo.mNoOfFingers;
 1494:      maDataTableIndex += TP_FingerStateSize(gTP_CallbackInfo.devInfo.mNoOfFingers); 
 1495:      /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1496:      maDataTableIndex += 2;
 1497:          
 1498:      /* Update the pointer to the data table then the gesture status list */
 1499:      pDataTable = maDataTable + maDataTableIndex;   
 1500:      dummy = *pDataTable; 
 1501:      /* Update again the pointer to the data table in orde to point to the gestures parameters */
 1502:      pDataTable += 2;
 1503:      
 1504:      if(dummy & gTP_PinchMask_c)
 1505:      {
 1506:        gTP_CallbackInfo.gestStatusList.mPinch      = TRUE;        
 1507:        gTP_CallbackInfo.gestInfo.mPinchGestureInfo = *(pDataTable);     
 1508:      }
 1509:      if(dummy & gTP_PressMask_c)
 1510:      {
 1511:        gTP_CallbackInfo.gestStatusList.mPress = TRUE;     
 1512:      }
 1513:      if(dummy & gTP_FlickMask_c)
 1514:      { 
 1515:        gTP_CallbackInfo.gestStatusList.mFlick = TRUE;
 1516:        gTP_CallbackInfo.gestInfo.mFlickGestureInfo.mFlickDistanceX = *(pDataTable); 
 1517:        gTP_CallbackInfo.gestInfo.mFlickGestureInfo.mFlickDistanceY = *(pDataTable + 1); 
 1518:        gTP_CallbackInfo.gestInfo.mFlickGestureInfo.mFlickTime      = *(pDataTable + 2);                
 1519:      }
 1520:      if(dummy & gTP_SingleTapMask_c)
 1521:      {
 1522:        gTP_CallbackInfo.gestStatusList.mSingleTap  = TRUE;     
 1523:      }
 1524:      if(dummy & gTP_DoubleTapMask_c)
 1525:      {
 1526:        gTP_CallbackInfo.gestStatusList.mDoubleTap  = TRUE;     
 1527:      }
 1528:      if(dummy & gTP_TapAndHoldMask_c)
 1529:      {
 1530:        gTP_CallbackInfo.gestStatusList.mTapAndHold = TRUE;     
 1531:      }
 1532:      
 1533:      /* Get palm and rotate status */
 1534:      dummy = *(maDataTable + maDataTableIndex + 1); 
 1535:      if(dummy & gTP_RotateMask_c)
 1536:      {
 1537:        gTP_CallbackInfo.gestStatusList.mRotate  = TRUE; 
 1538:        gTP_CallbackInfo.gestInfo.mRotateGestureInfo.mRotateMotion    = *(pDataTable + 1);
 1539:        gTP_CallbackInfo.gestInfo.mRotateGestureInfo.mFingersDistance = *(pDataTable + 2);    
 1540:      }
 1541:      if(dummy & gTP_PalmMask_c)
 1542:      {
 1543:        gTP_CallbackInfo.gestStatusList.mPalm = TRUE;        
 1544:      }     
 1545:    }
 1546:     
 1547:  
 1548:    /*****************************************************************************
 1549:    * TP_ReadBlock
 1550:    * 
 1551:    * Interface assumption:
 1552:    *
 1553:    * Return value: generic status code
 1554:    *
 1555:    * 
 1556:    *****************************************************************************/
 1557:    static bool_t TP_ReadBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pRxBuff)
 1558:    {     
 1559:      bool_t retStatus = FALSE;
 1560:           
 1561:      if(gRmiBlockAccess.accessLock == FALSE)
 1562:      {
 1563:        /* Prepare the structure to be used by the RmiWriteAddrCallback */
 1564:        gRmiBlockAccess.rmiBlockAccess.regAddr      = startAddr;
 1565:        gRmiBlockAccess.rmiBlockAccess.buffLength   = blockLength;
 1566:        gRmiBlockAccess.rmiBlockAccess.tpOperType   = mTP_OperType_Read_c;
 1567:        gRmiBlockAccess.rmiBlockAccess.pBuff        = pRxBuff;
 1568:        gRmiBlockAccess.accessLock                  = TRUE; 
 1569:        
 1570:        /* Transmit the start address of the RMI registers block */
 1571:        retStatus = IIC_Transmit_Master(&gRmiBlockAccess.rmiBlockAccess.regAddr, 
 1572:                                        gTP_RmiAddrByteSize_c, 
 1573:                                        gTP_SlaveAddress_c, 
 1574:                                        RmiWriteAddrCallback); 
 1575:        if(retStatus == FALSE)
 1576:        {
 1577:          gRmiBlockAccess.accessLock = FALSE; 
 1578:        }
 1579:      }
 1580:           
 1581:      return retStatus;  
 1582:    }
 1583:  
 1584:    /*****************************************************************************
 1585:    * TP_WriteBlock
 1586:    * 
 1587:    * Interface assumption:
 1588:    *
 1589:    * Return value: generic status code
 1590:    *
 1591:    * 
 1592:    *****************************************************************************/
 1593:    static bool_t TP_WriteBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pTxBuff)
 1594:    {    
 1595:      rmiBlockAccess_t* pRmiBlockAccess = &gRmiBlockAccess;
 1596:      bool_t            retStatus       = FALSE;
 1597:         
 1598:      if((pRmiBlockAccess->accessLock == FALSE) && (blockLength < gWriteBlockMaxSize_c))
 1599:      {  
 1600:        /* Prepare the structure to be used by the RmiCompleteAccessCallback */
 1601:        pRmiBlockAccess->rmiBlockAccess.regAddr      = startAddr; 
 1602:        pRmiBlockAccess->rmiBlockAccess.buffLength   = blockLength;
 1603:        pRmiBlockAccess->rmiBlockAccess.tpOperType   = mTP_OperType_Write_c;
 1604:        pRmiBlockAccess->rmiBlockAccess.pBuff        = pTxBuff;
 1605:        pRmiBlockAccess->accessLock                  = TRUE;   
 1606:                    
 1607:        *gWriteBlock = pRmiBlockAccess->rmiBlockAccess.regAddr; 
 1608:        FLib_MemCpy((gWriteBlock + 1), pTxBuff, blockLength);
 1609:                                                                      
 1610:        /* Start transmission over the IIC */
 1611:        retStatus = IIC_Transmit_Master(gWriteBlock, 
 1612:                                        blockLength + 1, 
 1613:                                        gTP_SlaveAddress_c, 
 1614:                                        RmiCompleteAccessCallback); 
 1615:        
 1616:        if(retStatus == FALSE)
 1617:        {
 1618:          pRmiBlockAccess->accessLock = FALSE; 
 1619:        }                                                                       
 1620:      }
 1621:      
 1622:      return retStatus;  
 1623:    } 
 1624:      
 1625:  
 1626:    /*****************************************************************************
 1627:    * RmiWriteAddrCallback
 1628:    * 
 1629:    * Interface assumption:
 1630:    *
 1631:    * Return value: none
 1632:    *
 1633:    * 
 1634:    *****************************************************************************/
 1635:    static void RmiWriteAddrCallback(bool_t status)
 1636:    {         
 1637:      if(gRmiBlockAccess.rmiBlockAccess.tpOperType  == mTP_OperType_Read_c)
 1638:      {
 1639:        if(FALSE == status)
 1640:        {
 1641:          /* Release the access to the 'gRmiBlockAccess' variable */
 1642:          gRmiBlockAccess.accessLock = FALSE;
 1643:                
 1644:          /* Send event to the TP_Task */
 1645:          TS_SendEvent(gTP_TaskId, gTP_Event_ReadBlockFail_c);  
 1646:        }
 1647:        else
 1648:        {
 1649:          if(FALSE == IIC_Receive_Master((uint8_t*)gRmiBlockAccess.rmiBlockAccess.pBuff, 
 1650:                                         gRmiBlockAccess.rmiBlockAccess.buffLength, 
 1651:                                         gTP_SlaveAddress_c, 
 1652:                                         RmiCompleteAccessCallback))        
 1653:          {
 1654:            /* Release the access to the 'gRmiBlockAccess' variable */
 1655:            gRmiBlockAccess.accessLock = FALSE;
 1656:                       
 1657:            /* Send event to the TP_Task */
 1658:            TS_SendEvent(gTP_TaskId, gTP_Event_ReadBlockFail_c);    
 1659:          }
 1660:        }
 1661:      }
 1662:    }
 1663:  
 1664:  
 1665:    /*****************************************************************************
 1666:    * RmiCompleteAccessCallback
 1667:    * 
 1668:    * Interface assumption:
 1669:    *
 1670:    * Return value: none
 1671:    *
 1672:    * 
 1673:    *****************************************************************************/
 1674:    static void RmiCompleteAccessCallback(bool_t status)
 1675:    {       
 1676:      event_t dummyEvent;
 1677:          
 1678:      if(gRmiBlockAccess.rmiBlockAccess.tpOperType == mTP_OperType_Read_c)
 1679:      {
 1680:        dummyEvent = (FALSE == status) ?  gTP_Event_ReadBlockFail_c : gTP_Event_ReadBlockSuccess_c; 
 1681:      }
 1682:      else
 1683:      { /* Write RMI block */            
 1684:        if(gRmiBlockAccess.rmiBlockAccess.tpOperType == mTP_OperType_Write_c)
 1685:        {
 1686:          dummyEvent = (FALSE == status) ?  gTP_Event_WriteBlockFail_c : gTP_Event_WriteBlockSuccess_c;     
 1687:        }
 1688:      }
 1689:      
 1690:      /* Release the access to the 'gRmiBlockAccess' variable */
 1691:      gRmiBlockAccess.accessLock = FALSE;
 1692:      
 1693:      /* Send event to the TP_Task */
 1694:      TS_SendEvent(gTP_TaskId, dummyEvent);  
 1695:    }
 1696:  #endif
 1697:   
 1698:  
