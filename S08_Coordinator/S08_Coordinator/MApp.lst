ANSI-C/cC++ Compiler for HC08 V-5.0.45 Build 14019, Jan 20 2014

    1:  /*****************************************************************************
    2:  *  MyWirelessApp Demo Non Beacon Coordinator application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  
   17:  /************************************************************************************
   18:  *************************************************************************************
   19:  * Private macros
   20:  *************************************************************************************
   21:  ************************************************************************************/
   22:  
   23:  /* If there are too many pending packets to be send over the air, */
   24:  /* receive mMaxKeysToReceive_c chars. */
   25:  /* The chars will be send over the air when there are no pending packets*/
   26:  #define mMaxKeysToReceive_c 32
   27:  
   28:  /************************************************************************************
   29:  *************************************************************************************
   30:  * Private prototypes
   31:  *************************************************************************************
   32:  ************************************************************************************/
   33:  
   34:  /* Forward declarations of helper functions */
   35:  static void    App_CommRxCallBack(void);
   36:  static uint8_t App_StartScan(uint8_t scanType);
   37:  static void    App_HandleScanEdConfirm(nwkMessage_t *pMsg);
   38:  static uint8_t App_StartCoordinator(void);
   39:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   40:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn);
   41:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   42:  static void    App_TransmitCommData(void);
   43:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   44:  #if (gMC1323xMatrixKBD_d == TRUE)
   45:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   46:  #else
   47:  static void    App_HandleKeys(key_event_t events);
   48:  #endif //gMC1323xMatrixKBD_d
   49:  
   50:  
   51:  /************************************************************************************
   52:  *************************************************************************************
   53:  * Private type definitions
   54:  *************************************************************************************
   55:  ************************************************************************************/
   56:  
   57:  
   58:  /************************************************************************************
   59:  *************************************************************************************
   60:  * Private memory declarations
   61:  *************************************************************************************
   62:  ************************************************************************************/
   63:  
   64:  /* The short address and PAN ID of the coordinator*/
   65:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
   66:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   67:  
   68:  
   69:  /* The current logical channel (frequency band) */
   70:  static uint8_t mLogicalChannel;
   71:  
   72:  /* Data request packet for sending serial input to the coordinator */
   73:  static nwkToMcpsMessage_t *mpPacket;
   74:  
   75:  /* The MSDU handle is a unique data packet identifier */
   76:  static uint8_t mMsduHandle;
   77:  
   78:  /* NEWCODE: Pointer to Package Button State */
   79:  static nwkToMcpsMessage_t *mpGenericPkg;
   80:  /* NEWCODE: Pointer to Package Button State */
   81:  static uint8_t maDeviceShortAddress[2];
   82:  
   83:  /* Number of pending data packets */
   84:  static uint8_t mcPendingPackets;
   85:  
   86:  /* Application input queues */
   87:  static anchor_t mMlmeNwkInputQueue;
   88:  static anchor_t mMcpsNwkInputQueue;
   89:  
   90:  static EndDevListItem_t AssociatedDevices[5];
   91:  static uint16_t AssocDevCounter;
   92:  
   93:  
   94:  /************************************************************************************
   95:  *************************************************************************************
   96:  * Public memory declarations
   97:  *************************************************************************************
   98:  ************************************************************************************/
   99:  
  100:  /* The current state of the applications state machine */
  101:  uint8_t gState;
  102:  
  103:  /* This data set contains application variables to be preserved across resets */
  104:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  105:    {NULL, 0}       /* Required end-of-table marker. */
  106:  };
  107:  
  108:  /************************************************************************************
  109:  *************************************************************************************
  110:  * Public functions
  111:  *************************************************************************************
  112:  ************************************************************************************/
  113:  
  114:  void DeepSleepWakeupStackProc(void);
  115:  
  116:  /*****************************************************************************
  117:  * Initialization function for the App Task. This is called during
  118:  * initialization and should contain any application specific initialization
  119:  * (ie. hardware initialization/setup, table initialization, power up
  120:  * notificaiton.
  121:  *
  122:  * Interface assumptions: None
  123:  *
  124:  * Return value: None
  125:  *
  126:  *****************************************************************************/
  127:  
  128:  void MApp_init(void)
  129:  { 
  130:    
  131:    /* The initial application state */
  132:    gState = stateInit;
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  133:    /* Reset number of pending packets */
  134:    mcPendingPackets = 0;   
  0004 c70000   [4]             STA   mcPendingPackets
  135:    /* Number of devices associated - Max 5 */
  136:    AssocDevCounter = 0; 
  0007 8c       [1]             CLRH  
  0008 5f       [1]             CLRX  
  0009 960000   [5]             STHX  AssocDevCounter
  137:  
  138:    /* Initialize the MAC 802.15.4 extended address */
  139:    Init_MacExtendedAddress();
  000c ac000000 [8]             CALL  Init_MacExtendedAddress
  140:    /* register keyboard callback function */
  141:    KBD_Init(App_HandleKeys);
  0010 450000   [3]             LDHX  @App_HandleKeys
  0013 89       [2]             PSHX  
  0014 8b       [2]             PSHH  
  0015 a600     [2]             LDA   @App_HandleKeys:PAGE
  0017 87       [2]             PSHA  
  0018 ac000000 [8]             CALL  KBD_Init
  001c a703     [2]             AIS   #3
  142:    /* Initialize SPI Module */
  143:    SPI_Init();
  001e ac000000 [8]             CALL  SPI1_Init
  144:    /* initialize LCD Module */
  145:    LCD_Init();
  146:    /* initialize LED Module */
  147:    LED_Init();
  0022 ac000000 [8]             CALL  LED_Init
  148:    /* Initialize the LPM module */
  149:    PWRLib_Init();
  0026 ac000000 [8]             CALL  PWRLib_Init
  150:    /* Initialize the serial terminal interface so that we can print out status messages */
  151:    Comm_SetBaud(gUartDefaultBaud_c);
  002a ae08     [2]             LDX   #8
  002c 8c       [1]             CLRH  
  002d ac000000 [8]             CALL  Uart1_SetBaud
  152:    Comm_SetRxCallBack(App_CommRxCallBack);
  0031 450000   [3]             LDHX  @App_CommRxCallBack
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 a600     [2]             LDA   @App_CommRxCallBack:PAGE
  0038 87       [2]             PSHA  
  0039 ac000000 [8]             CALL  Uart1_SetRxCallBack
  003d a703     [2]             AIS   #3
  153:    
  154:    /* initialize buzzer (NCB, SRB only) */  
  155:    BuzzerInit();  
  156:    /* Prepare input queues.*/
  157:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  003f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0042 ac000000 [8]             CALL  List_ClearAnchor
  158:    MSG_InitQueue(&mMcpsNwkInputQueue);
  0046 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  159:    /* Enable MCU interrupts */
  160:    IrqControlLib_EnableAllIrqs();
  004d 9a       [1]             CLI   
  161:    /*signal app ready*/  
  162:    Led1Flashing();
  004e a601     [2]             LDA   #1
  0050 ac000000 [8]             CALL  LED_StartFlash
  163:    Led2Flashing();
  0054 a602     [2]             LDA   #2
  0056 ac000000 [8]             CALL  LED_StartFlash
  164:    Led3Flashing();
  005a a604     [2]             LDA   #4
  005c ac000000 [8]             CALL  LED_StartFlash
  165:    Led4Flashing();
  0060 a608     [2]             LDA   #8
  0062 ac000000 [8]             CALL  LED_StartFlash
  166:      
  167:    CommUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  0066 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0069 a601     [2]             LDA   #1
  006b ac000000 [8]             CALL  CommUtil_Print
  168:    LCD_ClearDisplay();
  169:    LCD_WriteString(1,"Press any key");
  170:    LCD_WriteString(2,"to start.");
  171:  }
  006f 8d       [7]             RTC   
  172:  
  173:  /*****************************************************************************
  174:  *Mac Application Task event processor.  This function is called to
  175:  * process all events for the task. Events include timers, messages and any
  176:  * other user defined events
  177:  *
  178:  * Interface assumptions: None
  179:  *
  180:  * Return value: None
  181:  *****************************************************************************/
  182:  /* The Application Task */
  183:  void AppTask(event_t events)
  184:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  185:    /* Pointer for storing the messages from MLME */
  186:    void *pMsgIn;
  187:    /* Stores the error/success code returned by some functions. */
  188:    uint8_t ret;  
  189:    pMsgIn = NULL;
  0004 9e6f02   [6]             CLR   2,SP
  0007 9e6f01   [6]             CLR   1,SP
  190:    
  191:    /* Dequeue the MLME message */
  192:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  193:    {
  194:      /* Get the message from MLME */
  195:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff01   [5]             STHX  1,SP
  196:      
  197:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  198:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  199:      {               
  200:        ret = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  201:        if(ret == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  202:        {
  203:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  204:          /* ALSO the application can use the beacon payload.*/
  205:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe01   [5]             LDHX  1,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  206:          CommUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac000165 [8]             CALL  AppTask:357
  0035          L35:    
  207:        }
  208:      }
  209:    }
  210:    /* The application state machine */
  211:    switch(gState)
  0035 ce0000   [4]             LDX   gState
  0038 a305     [2]             CPX   #5
  003a 2225     [3]             BHI   L61 ;abs = 0061
  003c 4f       [1]             CLRA  
  003d cd0000   [6]             JSR   _Jump_Table_Header_Offset
  0040 06               DC.B  6
  0041 d7               DC.B  L119
  0042 05               DC.B  L48
  0043 10               DC.B  L54
  0044 22               DC.B  L67
  0045 49               DC.B  L8F
  0046 79               DC.B  LC0
  0047 c1               DC.B  L109
  0048          L48:    
  212:    {
  213:    case stateInit:    
  214:      /* Print a welcome message to the serial terminal interface */
  215:      CommUtil_Print("\n\rMyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  0048 450000   [3]             LDHX  @"\012\015MyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\012\015\012\015"
  004b ac000165 [8]             CALL  AppTask:357
  216:      /* Goto Energy Detection state. */
  217:      gState = stateScanEdStart;
  004f a601     [2]             LDA   #1
  218:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  219:      break;
  0051 cc00fa   [4]             JMP   LFA ;abs = 00fa
  0054          L54:    
  220:      
  221:    case stateScanEdStart:
  222:      /* Start the Energy Detection scan, and goto wait for confirm state. */
  223:      CommUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
  0054 450000   [3]             LDHX  @"Initiating the Energy Detection Scan\012\015"
  0057 ac000165 [8]             CALL  AppTask:357
  224:      /*Print the message on the LCD also*/
  225:      LCD_ClearDisplay();
  226:      LCD_WriteString(1,"Starting Energy");
  227:      LCD_WriteString(2,"Detection Scan");  
  228:      ret = App_StartScan(gScanModeED_c);
  005b 4f       [1]             CLRA  
  005c ac000000 [8]             CALL  App_StartScan
  229:      if(ret == errorNoError)
  0060 4d       [1]             TSTA  
  0061          L61:    
  0061 265b     [3]             BNE   LBE ;abs = 00be
  230:      {
  231:        gState = stateScanEdWaitConfirm;
  0063 a602     [2]             LDA   #2
  0065 2054     [3]             BRA   LBB ;abs = 00bb
  0067          L67:    
  232:      }
  233:      break;
  234:      
  235:    case stateScanEdWaitConfirm:
  236:      /* Stay in this state until the MLME Scan confirm message arrives,
  237:         and has been processed. Then goto Start Coordinator state. */
  238:      if (events & gAppEvtMessageFromMLME_c)
  0067 95       [2]             TSX   
  0068 e603     [3]             LDA   3,X
  006a a504     [2]             BIT   #4
  006c 2750     [3]             BEQ   LBE ;abs = 00be
  239:      {
  240:        if (pMsgIn)
  006e 9efe01   [5]             LDHX  1,SP
  0071 274b     [3]             BEQ   LBE ;abs = 00be
  241:        {
  242:          ret = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  0073 a60b     [2]             LDA   #11
  0075 ac000000 [8]             CALL  App_WaitMsg
  243:          if(ret == errorNoError)
  0079 4d       [1]             TSTA  
  007a 2642     [3]             BNE   LBE ;abs = 00be
  244:          {
  245:            /* Process the ED scan confirm. The logical
  246:               channel is selected by this function. */
  247:            App_HandleScanEdConfirm(pMsgIn);
  007c 9efe01   [5]             LDHX  1,SP
  007f ac000000 [8]             CALL  App_HandleScanEdConfirm
  248:            /* Go to the Start Coordinator state */
  249:            gState = stateStartCoordinator;
  0083 a603     [2]             LDA   #3
  0085 c70000   [4]             STA   gState
  250:            TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
  0088 c60000   [4]             LDA   gAppTaskID_c
  008b ae10     [2]             LDX   #16
  008d 2073     [3]             BRA   L102 ;abs = 0102
  008f          L8F:    
  251:          }
  252:        }      
  253:      }        
  254:      break;
  255:      
  256:  
  257:    case stateStartCoordinator:
  258:      if (events & gAppEvtStartCoordinator_c)
  008f 95       [2]             TSX   
  0090 e603     [3]             LDA   3,X
  0092 a510     [2]             BIT   #16
  0094 2728     [3]             BEQ   LBE ;abs = 00be
  259:      {
  260:        /* Start up as a PAN Coordinator on the selected channel. */
  261:        CommUtil_Print("\n\rStarting as PAN coordinator on channel 0x", gAllowToBlock_d);
  0096 450000   [3]             LDHX  @"\012\015Starting as PAN coordinator on channel 0x"
  0099 ac000165 [8]             CALL  AppTask:357
  262:        CommUtil_PrintHex(&mLogicalChannel, 1, FALSE);
  009d 450000   [3]             LDHX  @mLogicalChannel
  00a0 89       [2]             PSHX  
  00a1 8b       [2]             PSHH  
  00a2 ae01     [2]             LDX   #1
  00a4 4f       [1]             CLRA  
  00a5 ac000000 [8]             CALL  CommUtil_PrintHex
  00a9 a702     [2]             AIS   #2
  263:        CommUtil_Print("\n\r", gAllowToBlock_d);
  00ab 450000   [3]             LDHX  @"\012\015"
  00ae ac000165 [8]             CALL  AppTask:357
  264:        /*print a message on the LCD also*/
  265:        LCD_ClearDisplay();
  266:        LCD_WriteString(1,"Starting");
  267:        LCD_WriteString(2,"PAN coordinator");    
  268:      
  269:        ret = App_StartCoordinator();
  00b2 ac000000 [8]             CALL  App_StartCoordinator
  270:        if(ret == errorNoError)
  00b6 4d       [1]             TSTA  
  00b7 2660     [3]             BNE   L119 ;abs = 0119
  271:        {
  272:          /* If the Start request was sent successfully to
  273:             the MLME, then goto Wait for confirm state. */
  274:          gState = stateStartCoordinatorWaitConfirm;
  00b9 a604     [2]             LDA   #4
  00bb          LBB:    
  00bb c70000   [4]             STA   gState
  00be          LBE:    
  00be 2059     [3]             BRA   L119 ;abs = 0119
  00c0          LC0:    
  275:        }
  276:      }
  277:      break; 
  278:  
  279:    case stateStartCoordinatorWaitConfirm:
  280:      /* Stay in this state until the Start confirm message
  281:             arrives, and then goto the Listen state. */
  282:      if (events & gAppEvtMessageFromMLME_c)
  00c0 95       [2]             TSX   
  00c1 e603     [3]             LDA   3,X
  00c3 a504     [2]             BIT   #4
  00c5 2752     [3]             BEQ   L119 ;abs = 0119
  283:      {
  284:        if (pMsgIn)
  00c7 9efe01   [5]             LDHX  1,SP
  00ca 274d     [3]             BEQ   L119 ;abs = 0119
  285:        {        
  286:          ret = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
  00cc a60e     [2]             LDA   #14
  00ce ac000000 [8]             CALL  App_WaitMsg
  287:          if(ret == errorNoError)
  00d2 4d       [1]             TSTA  
  00d3 2644     [3]             BNE   L119 ;abs = 0119
  288:          {
  289:            CommUtil_Print("Started the coordinator with PAN ID 0x", gAllowToBlock_d);
  00d5 450000   [3]             LDHX  @"Started the coordinator with PAN ID 0x"
  00d8 ac000165 [8]             CALL  AppTask:357
  290:            CommUtil_PrintHex((uint8_t *)maPanId, 2, 0);
  00dc 450000   [3]             LDHX  @maPanId
  00df ac00016c [8]             CALL  AppTask:364
  291:            CommUtil_Print(", and short address 0x", gAllowToBlock_d);
  00e3 450000   [3]             LDHX  @", and short address 0x"
  00e6 ac000165 [8]             CALL  AppTask:357
  292:            CommUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
  00ea 450000   [3]             LDHX  @maShortAddress
  00ed ac00016c [8]             CALL  AppTask:364
  293:            CommUtil_Print(".\n\r\n\rReady to send and receive data over the serial terminal interface.\n\r\n\r", gAllowToBlock_d);
  00f1 450000   [3]             LDHX  @".\012\015\012\015Ready to send and receive data over the serial terminal interface.\012\015\012\015"
  00f4 ac000165 [8]             CALL  AppTask:357
  294:            /*print a message on the LCD also*/
  295:            LCD_ClearDisplay();
  296:            LCD_WriteString(1,"Ready to send");
  297:            LCD_WriteString(2,"and receive data");    
  298:            gState = stateListen;
  00f8 a605     [2]             LDA   #5
  00fa          LFA:    
  00fa c70000   [4]             STA   gState
  299:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  00fd c60000   [4]             LDA   gAppTaskID_c
  0100 ae01     [2]             LDX   #1
  0102          L102:   
  0102 8c       [1]             CLRH  
  0103 ac000000 [8]             CALL  TS_SendEvent
  0107 2010     [3]             BRA   L119 ;abs = 0119
  0109          L109:   
  300:          }
  301:        }
  302:      }
  303:      break; 
  304:      
  305:    case stateListen:
  306:      /* Stay in this state forever. 
  307:         Transmit the data received on serial terminal interface */
  308:      if (events & gAppEvtMessageFromMLME_c)
  0109 95       [2]             TSX   
  010a e603     [3]             LDA   3,X
  010c a504     [2]             BIT   #4
  010e 2709     [3]             BEQ   L119 ;abs = 0119
  309:      {
  310:        /* Get the message from MLME */
  311:        if (pMsgIn)
  0110 9efe01   [5]             LDHX  1,SP
  0113 2704     [3]             BEQ   L119 ;abs = 0119
  312:        {      
  313:          /* Process it */
  314:          ret = App_HandleMlmeInput(pMsgIn);
  0115 ac000000 [8]             CALL  App_HandleMlmeInput
  0119          L119:   
  315:          /* Messages from the MLME must always be freed. */
  316:        }
  317:      }
  318:  
  319:      if (events & gAppEvtRxFromComm_c)
  320:      {      
  321:        /* get byte from serial terminal interface */
  322:        //App_TransmitCommData();       /* Commented as only APP_ACK was requested */
  323:      
  324:      }  
  325:      break;
  326:    }
  327:    
  328:    if (pMsgIn)
  0119 9efe01   [5]             LDHX  1,SP
  011c 2704     [3]             BEQ   L122 ;abs = 0122
  329:    {
  330:      /* Messages must always be freed. */ 
  331:      MSG_Free(pMsgIn);
  011e ac000000 [8]             CALL  MM_Free
  0122          L122:   
  332:    }
  333:    
  334:    if (events & gAppEvtMessageFromMCPS_c)
  0122 95       [2]             TSX   
  0123 e603     [3]             LDA   3,X
  0125 a508     [2]             BIT   #8
  0127 271b     [3]             BEQ   L144 ;abs = 0144
  335:    {      
  336:       /* Get the message from MCPS */
  337:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  0129 450000   [3]             LDHX  @mMcpsNwkInputQueue
  012c ac000000 [8]             CALL  List_RemoveHead
  338:      if (pMsgIn)
  0130 650000   [3]             CPHX  #0
  0133 270f     [3]             BEQ   L144 ;abs = 0144
  339:      {
  340:        /* Process it */
  341:        App_HandleMcpsInput(pMsgIn);
  0135 89       [2]             PSHX  
  0136 8b       [2]             PSHH  
  0137 ac000000 [8]             CALL  App_HandleMcpsInput
  342:        /* Messages from the MCPS must always be freed. */
  343:        MSG_Free(pMsgIn);
  013b 9efe01   [5]             LDHX  1,SP
  013e ac000000 [8]             CALL  MM_Free
  0142 a702     [2]             AIS   #2
  0144          L144:   
  344:      }
  345:    }  
  346:    
  347:    
  348:    /* Check for pending messages in the Queue */ 
  349:    if(MSG_Pending(&mMcpsNwkInputQueue))
  0144 320000   [5]             LDHX  mMcpsNwkInputQueue
  0147 270a     [3]             BEQ   L153 ;abs = 0153
  350:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0149 c60000   [4]             LDA   gAppTaskID_c
  014c ae08     [2]             LDX   #8
  014e 8c       [1]             CLRH  
  014f ac000000 [8]             CALL  TS_SendEvent
  0153          L153:   
  351:    if(MSG_Pending(&mMlmeNwkInputQueue))
  0153 320000   [5]             LDHX  mMlmeNwkInputQueue
  0156 270a     [3]             BEQ   L162 ;abs = 0162
  352:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0158 c60000   [4]             LDA   gAppTaskID_c
  015b ae04     [2]             LDX   #4
  015d 8c       [1]             CLRH  
  015e ac000000 [8]             CALL  TS_SendEvent
  0162          L162:   
  353:  }
  0162 a704     [2]             AIS   #4
  0164 8d       [7]             RTC   
  0165          L165:   
  0165 a601     [2]             LDA   #1
  0167 ac000000 [8]             CALL  CommUtil_Print
  016b 8d       [7]             RTC   
  016c          L16C:   
  016c 89       [2]             PSHX  
  016d 8b       [2]             PSHH  
  016e ae02     [2]             LDX   #2
  0170 4f       [1]             CLRA  
  0171 ac000000 [8]             CALL  CommUtil_PrintHex
  0175 a702     [2]             AIS   #2
  0177 8d       [7]             RTC   
  354:  
  355:  
  356:  
  357:  /************************************************************************************
  358:  *************************************************************************************
  359:  * Private functions
  360:  *************************************************************************************
  361:  ************************************************************************************/
  362:  
  363:  /*****************************************************************************
  364:  * App_CommRxCallBack
  365:  *
  366:  * This callback is triggered when a new byte is received over the Serial Interface
  367:  *
  368:  *****************************************************************************/
  369:  static void App_CommRxCallBack(void) 
  370:  {
  371:    uint8_t pressedKey;
  372:  	if(stateListen == gState){
  373:     // TS_SendEvent(gAppTaskID_c, gAppEvtRxFromComm_c);
  374:    }else{
  375:  	 // (void)Comm_GetByteFromRxBuffer(&pressedKey);
  376:    }
  377:  }
  0000 8d       [7]             RTC   
  378:  
  379:  /******************************************************************************
  380:  * The App_StartScan(scanType) function will start the scan process of the
  381:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  382:  * which is then assigned the desired scan parameters and sent to the MLME
  383:  * service access point.
  384:  * The function may return either of the following values:
  385:  *   errorNoError:          The Scan message was sent successfully.
  386:  *   errorInvalidParameter: The MLME service access point rejected the
  387:  *                          message due to an invalid parameter.
  388:  *   errorAllocFailed:      A message buffer could not be allocated.
  389:  *
  390:  ******************************************************************************/
  391:  static uint8_t App_StartScan(uint8_t scanType)
  392:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  393:    mlmeMessage_t *pMsg;
  394:    mlmeScanReq_t *pScanReq;
  395:  
  396:    CommUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000058 [8]             CALL  App_StartScan:88
  397:  
  398:    /* Allocate a message for the MLME (We should check for NULL). */
  399:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a623     [2]             LDA   #35
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  400:    if(pMsg != NULL)
  0013 2737     [3]             BEQ   L4C ;abs = 004c
  401:    {
  402:      /* This is a MLME-SCAN.req command */
  403:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  404:      /* Create the Scan request message data. */
  405:      pScanReq = &pMsg->msgData.scanReq;
  406:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  407:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  408:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  409:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  410:      /* ChannelsToScan>>8 & 0xFF  */
  411:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f 6f03     [5]             CLR   3,X
  412:      /* ChannelsToScan>>16 & 0xFF  */
  413:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0021 6f04     [5]             CLR   4,X
  414:      /* ChannelsToScan>>24 & 0xFF - MSB */
  415:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0023 a601     [2]             LDA   #1
  0025 e705     [3]             STA   5,X
  416:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  417:         A scan duration of 3 on 16 channels approximately takes 2 secs. */
  418:      pScanReq->scanDuration = 3;
  0027 a603     [2]             LDA   #3
  0029 e706     [3]             STA   6,X
  419:  #ifdef gMAC2006_d
  420:      pScanReq->securityLevel = 0;
  002b 6f07     [5]             CLR   7,X
  421:  #endif //gMAC2006_d    
  422:      
  423:      /* Send the Scan request to the MLME. */
  424:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002d 9efe01   [5]             LDHX  1,SP
  0030 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0034 4d       [1]             TSTA  
  0035 260a     [3]             BNE   L41 ;abs = 0041
  425:      {
  426:        CommUtil_Print("Done\n\r", gAllowToBlock_d);
  0037 450000   [3]             LDHX  @"Done\012\015"
  003a ac000058 [8]             CALL  App_StartScan:88
  427:        return errorNoError;
  003e 4f       [1]             CLRA  
  003f 2014     [3]             BRA   L55 ;abs = 0055
  0041          L41:    
  428:      }
  429:      else
  430:      {
  431:        CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0041 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0044 ac000058 [8]             CALL  App_StartScan:88
  432:        return errorInvalidParameter;
  0048 a605     [2]             LDA   #5
  004a 2009     [3]             BRA   L55 ;abs = 0055
  004c          L4C:    
  433:      }
  434:    }
  435:    else
  436:    {
  437:      /* Allocation of a message buffer failed. */
  438:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  004c 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004f ac000058 [8]             CALL  App_StartScan:88
  439:      return errorAllocFailed;
  0053 a604     [2]             LDA   #4
  0055          L55:    
  440:    }
  441:  }
  0055 a703     [2]             AIS   #3
  0057 8d       [7]             RTC   
  0058          L58:    
  0058 a601     [2]             LDA   #1
  005a ac000000 [8]             CALL  CommUtil_Print
  005e 8d       [7]             RTC   
  442:  
  443:  
  444:  /******************************************************************************
  445:  * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
  446:  * ED scan confirm message received from the MLME when the ED scan has completed.
  447:  * The message contains the ED scan result list. This function will search the
  448:  * list in order to select the logical channel with the least energy. The
  449:  * selected channel is stored in the global variable called 'mLogicalChannel'.
  450:  *
  451:  ******************************************************************************/
  452:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
  453:  {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
  454:    uint8_t n, minEnergy;
  455:    uint8_t *pEdList;
  456:    uint8_t ChannelMask;
  457:  
  458:    CommUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Received the MLME-Scan Confirm message from the MAC\012\015"
  0007 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  459:      
  460:    /* Get a pointer to the energy detect results */
  461:    pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
  000b 9efe06   [5]             LDHX  6,SP
  000e 9ece08   [5]             LDHX  8,X
  0011 9eff03   [5]             STHX  3,SP
  462:    
  463:    /* Set the minimum energy to a large value */
  464:    minEnergy = 0xFF;
  0014 a6ff     [2]             LDA   #-1
  0016 95       [2]             TSX   
  0017 e704     [3]             STA   4,X
  465:  
  466:    /* Select default channel */
  467:    mLogicalChannel = 11;
  0019 a60b     [2]             LDA   #11
  001b c70000   [4]             STA   mLogicalChannel
  468:   
  469:    /* Search for the channel with least energy */
  470:    for(n=0; n<16; n++)
  001e 6f01     [5]             CLR   1,X
  0020          L20:    
  471:    {
  472:      ChannelMask = n + 11;
  0020 95       [2]             TSX   
  0021 e601     [3]             LDA   1,X
  0023 ab0b     [2]             ADD   #11
  473:  	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
  0025 f7       [2]             STA   ,X
  0026 e601     [3]             LDA   1,X
  0028 eb03     [3]             ADD   3,X
  002a 87       [2]             PSHA  
  002b 4f       [1]             CLRA  
  002c e902     [3]             ADC   2,X
  002e 87       [2]             PSHA  
  002f e604     [3]             LDA   4,X
  0031 8a       [3]             PULH  
  0032 88       [3]             PULX  
  0033 f1       [3]             CMP   ,X
  0034 232e     [3]             BLS   L64 ;abs = 0064
  0036 4f       [1]             CLRA  
  0037 450100   [3]             LDHX  #256
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f e604     [3]             LDA   4,X
  0041 cd0000   [6]             JSR   _LLSR
  0044 9ee604   [4]             LDA   4,SP
  0047 a501     [2]             BIT   #1
  0049 a708     [2]             AIS   #8
  004b 2717     [3]             BEQ   L64 ;abs = 0064
  474:      {
  475:        minEnergy = pEdList[n];
  004d e605     [3]             LDA   5,X
  004f eb07     [3]             ADD   7,X
  0051 87       [2]             PSHA  
  0052 4f       [1]             CLRA  
  0053 e906     [3]             ADC   6,X
  0055 87       [2]             PSHA  
  0056 8a       [3]             PULH  
  0057 88       [3]             PULX  
  0058 fe       [3]             LDX   ,X
  0059 9eef05   [4]             STX   5,SP
  476:        /* Channel numbering is 11 to 26 both inclusive */
  477:        mLogicalChannel = n + 11; 
  005c 95       [2]             TSX   
  005d e601     [3]             LDA   1,X
  005f ab0b     [2]             ADD   #11
  0061 c70000   [4]             STA   mLogicalChannel
  0064          L64:    
  0064 95       [2]             TSX   
  0065 6c01     [5]             INC   1,X
  0067 e601     [3]             LDA   1,X
  0069 a110     [2]             CMP   #16
  006b 25b3     [3]             BCS   L20 ;abs = 0020
  478:      }
  479:    }
  480:    
  481:    /* Print out the result of the ED scan */
  482:    CommUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
  006d 450000   [3]             LDHX  @"ED scan returned the following results:\012\015  ["
  0070 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  483:    CommUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
  0074 9efe03   [5]             LDHX  3,SP
  0077 89       [2]             PSHX  
  0078 8b       [2]             PSHH  
  0079 ae10     [2]             LDX   #16
  007b a609     [2]             LDA   #9
  007d ac000000 [8]             CALL  CommUtil_PrintHex
  0081 a702     [2]             AIS   #2
  484:    CommUtil_Print("]\n\r\n\r", gAllowToBlock_d);
  0083 450000   [3]             LDHX  @"]\012\015\012\015"
  0086 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  485:    
  486:    /* Print out the selected logical channel */
  487:    CommUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
  008a 450000   [3]             LDHX  @"Based on the ED scan the logical channel 0x"
  008d ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  488:    CommUtil_PrintHex(&mLogicalChannel, 1, 0);
  0091 450000   [3]             LDHX  @mLogicalChannel
  0094 89       [2]             PSHX  
  0095 8b       [2]             PSHH  
  0096 ae01     [2]             LDX   #1
  0098 4f       [1]             CLRA  
  0099 ac000000 [8]             CALL  CommUtil_PrintHex
  009d a702     [2]             AIS   #2
  489:    CommUtil_Print(" was selected\n\r", gAllowToBlock_d);
  009f 450000   [3]             LDHX  @" was selected\012\015"
  00a2 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  490:    
  491:    /* The list of detected energies must be freed. */
  492:    MSG_Free(pEdList);
  00a6 9efe03   [5]             LDHX  3,SP
  00a9 ac000000 [8]             CALL  MM_Free
  493:  }
  00ad a707     [2]             AIS   #7
  00af 8d       [7]             RTC   
  00b0          LB0:    
  00b0 a601     [2]             LDA   #1
  00b2 ac000000 [8]             CALL  CommUtil_Print
  00b6 8d       [7]             RTC   
  494:  
  495:  /******************************************************************************
  496:  * The App_StartScan(scanType) function will start the scan process of the
  497:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  498:  * which is then assigned the desired scan parameters and sent to the MLME
  499:  * service access point. The MAC PIB attributes "macShortAddress", and 
  500:  * "macAssociatePermit" are modified.
  501:  *
  502:  * The function may return either of the following values:
  503:  *   errorNoError:          The Scan message was sent successfully.
  504:  *   errorInvalidParameter: The MLME service access point rejected the
  505:  *                          message due to an invalid parameter.
  506:  *   errorAllocFailed:      A message buffer could not be allocated.
  507:  *
  508:  ******************************************************************************/
  509:  static uint8_t App_StartCoordinator(void)
  510:  {
  0000 a7fb     [2]             AIS   #-5
  511:    /* Message for the MLME will be allocated and attached to this pointer */
  512:    mlmeMessage_t *pMsg;
  513:  
  514:    CommUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Start Request message to the MAC..."
  0005 ac0000af [8]             CALL  App_StartCoordinator:175
  515:    
  516:    /* Allocate a message for the MLME (We should check for NULL). */
  517:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a623     [2]             LDA   #35
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff01   [5]             STHX  1,SP
  518:    if(pMsg != NULL)
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00a3   [4]             JMP   LA3 ;abs = 00a3
  0017          L17:    
  519:    {
  520:      /* Pointer which is used for easy access inside the allocated message */
  521:      mlmeStartReq_t *pStartReq;
  522:      /* Return value from MSG_send - used for avoiding compiler warnings */
  523:      uint8_t ret;
  524:      /* Boolean value that will be written to the MAC PIB */
  525:      uint8_t boolFlag;
  526:      
  527:      /* Set-up MAC PIB attributes. Please note that Set, Get,
  528:         and Reset messages are not freed by the MLME. */
  529:      
  530:      /* We must always set the short address to something
  531:         else than 0xFFFF before starting a PAN. */
  532:      pMsg->msgType = gMlmeSetReq_c;
  0017 a609     [2]             LDA   #9
  0019 f7       [2]             STA   ,X
  533:      pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
  001a a653     [2]             LDA   #83
  001c e701     [3]             STA   1,X
  534:      pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
  001e a600     [2]             LDA   @maShortAddress:MSB
  0020 e703     [3]             STA   3,X
  0022 a600     [2]             LDA   @maShortAddress
  0024 e704     [3]             STA   4,X
  535:      ret = MSG_Send(NWK_MLME, pMsg);
  0026 89       [2]             PSHX  
  0027 8b       [2]             PSHH  
  0028 ac000000 [8]             CALL  NWK_MLME_SapHandler
  536:      
  537:      /* We must set the Association Permit flag to TRUE 
  538:         in order to allow devices to associate to us. */
  539:      pMsg->msgType = gMlmeSetReq_c;
  002c 9efe01   [5]             LDHX  1,SP
  002f a609     [2]             LDA   #9
  0031 f7       [2]             STA   ,X
  540:      pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
  0032 a641     [2]             LDA   #65
  0034 e701     [3]             STA   1,X
  541:      boolFlag = TRUE;
  0036 a601     [2]             LDA   #1
  0038 95       [2]             TSX   
  0039 e704     [3]             STA   4,X
  542:      pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
  003b af04     [2]             AIX   #4
  003d 8b       [2]             PSHH  
  003e 9ee602   [4]             LDA   2,SP
  0041 87       [2]             PSHA  
  0042 8a       [3]             PULH  
  0043 9f       [1]             TXA   
  0044 9eee03   [4]             LDX   3,SP
  0047 e704     [3]             STA   4,X
  0049 86       [3]             PULA  
  004a e703     [3]             STA   3,X
  543:      ret = MSG_Send(NWK_MLME, pMsg);
  004c ac000000 [8]             CALL  NWK_MLME_SapHandler
  544:      
  545:      /* This is a MLME-START.req command */
  546:      pMsg->msgType = gMlmeStartReq_c;
  0050 9efe03   [5]             LDHX  3,SP
  0053 a60a     [2]             LDA   #10
  0055 f7       [2]             STA   ,X
  547:      
  548:      /* Create the Start request message data. */
  549:      pStartReq = &pMsg->msgData.startReq;
  0056 af01     [2]             AIX   #1
  0058 9eff06   [5]             STHX  6,SP
  550:      /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
  551:      FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maPanId
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
  552:      /* Logical Channel - the default of 11 will be overridden */
  553:      pStartReq->logicalChannel = mLogicalChannel;
  0068 9efe06   [5]             LDHX  6,SP
  006b c60000   [4]             LDA   mLogicalChannel
  006e e702     [3]             STA   2,X
  554:      /* Beacon Order - 0xF = turn off beacons */
  555:      pStartReq->beaconOrder = 0x0F;  
  0070 a60f     [2]             LDA   #15
  0072 e707     [3]             STA   7,X
  556:      /* Superframe Order - 0xF = turn off beacons */
  557:      pStartReq->superFrameOrder = 0x0F;
  0074 e708     [3]             STA   8,X
  558:      /* Be a PAN coordinator */
  559:      pStartReq->panCoordinator = TRUE;
  0076 a601     [2]             LDA   #1
  0078 e709     [3]             STA   9,X
  560:      /* Dont use battery life extension */
  561:      pStartReq->batteryLifeExt = FALSE;
  007a 6f0a     [5]             CLR   10,X
  562:      /* This is not a Realignment command */
  563:      pStartReq->coordRealignment = FALSE;
  007c 6f0b     [5]             CLR   11,X
  564:      /* Dont use security */
  565:  #ifndef gMAC2006_d    
  566:      pStartReq->securityEnable = FALSE;
  567:  #else
  568:      pStartReq->coordRealignSecurityLevel = 0;
  007e 6f0c     [5]             CLR   12,X
  569:      pStartReq->beaconSecurityLevel = 0;
  0080 6f17     [5]             CLR   23,X
  570:  #endif //gMAC2006_d        
  571:        
  572:      /* Send the Start request to the MLME. */
  573:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a a702     [2]             AIS   #2
  008c 260a     [3]             BNE   L98 ;abs = 0098
  574:      {
  575:        CommUtil_Print("Done\n\r", gAllowToBlock_d);
  008e 450000   [3]             LDHX  @"Done\012\015"
  0091 ac0000af [8]             CALL  App_StartCoordinator:175
  576:        return errorNoError;
  0095 4f       [1]             CLRA  
  0096 2014     [3]             BRA   LAC ;abs = 00ac
  0098          L98:    
  577:      }
  578:      else
  579:      {
  580:        /* One or more parameters in the Start Request message were invalid. */
  581:        CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0098 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  009b ac0000af [8]             CALL  App_StartCoordinator:175
  582:        return errorInvalidParameter;
  009f a605     [2]             LDA   #5
  00a1 2009     [3]             BRA   LAC ;abs = 00ac
  00a3          LA3:    
  583:      }
  584:    }
  585:    else
  586:    {
  587:      /* Allocation of a message buffer failed. */
  588:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a3 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a6 ac0000af [8]             CALL  App_StartCoordinator:175
  589:      return errorAllocFailed;
  00aa a604     [2]             LDA   #4
  00ac          LAC:    
  590:    }
  591:  }
  00ac a705     [2]             AIS   #5
  00ae 8d       [7]             RTC   
  00af          LAF:    
  00af a601     [2]             LDA   #1
  00b1 ac000000 [8]             CALL  CommUtil_Print
  00b5 8d       [7]             RTC   
  592:  
  593:  /******************************************************************************
  594:  * The App_SendAssociateResponse(nwkMessage_t *pMsgIn) will create the response
  595:  * message to an Associate Indication (device sends an Associate Request to its
  596:  * MAC. The request is transmitted to the coordinator where it is converted into
  597:  * an Associate Indication). This function will extract the devices long address,
  598:  * and various other flags from the incoming indication message for building the
  599:  * response message.
  600:  *
  601:  * The function may return either of the following values:
  602:  *   errorNoError:          The Associate Response message was sent successfully.
  603:  *   errorInvalidParameter: The MLME service access point rejected the
  604:  *                          message due to an invalid parameter.
  605:  *   errorAllocFailed:      A message buffer could not be allocated.
  606:  *
  607:  ******************************************************************************/
  608:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn)
  609:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7f6     [2]             AIS   #-10
  610:    mlmeMessage_t *pMsg;
  611:    mlmeAssociateRes_t *pAssocRes;
  612:    uint16_t i;
  613:    uint8_t FoundFlag = 0;
  0004 95       [2]             TSX   
  0005 6f05     [5]             CLR   5,X
  614:   
  615:    CommUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0007 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  000a ac0001fe [8]             CALL  App_SendAssociateResponse:510
  616:   
  617:    /* Allocate a message for the MLME */
  618:    pMsg = MSG_AllocType(mlmeMessage_t);
  000e a623     [2]             LDA   #35
  0010 ac000000 [8]             CALL  MM_Alloc
  0014 9eff07   [5]             STHX  7,SP
  619:    if(pMsg != NULL)
  0017 2603     [3]             BNE   L1C ;abs = 001c
  0019 cc01f2   [4]             JMP   L1F2 ;abs = 01f2
  001c          L1C:    
  620:    {
  621:      /* This is a MLME-ASSOCIATE.res command */
  622:      pMsg->msgType = gMlmeAssociateRes_c;
  001c a601     [2]             LDA   #1
  001e f7       [2]             STA   ,X
  623:      
  624:      /* Create the Associate response message data. */
  625:      pAssocRes = &pMsg->msgData.associateRes;
  001f af01     [2]             AIX   #1
  0021 9eff04   [5]             STHX  4,SP
  626:      
  627:      /* Assign a short address to the device. In this example we simply
  628:         choose 0x0001. Though, all devices and coordinators in a PAN must have
  629:         different short addresses. However, if a device do not want to use 
  630:         short addresses at all in the PAN, a short address of 0xFFFE must
  631:         be assigned to it. */
  632:  
  633:        /* Check if ED requester was already registered */
  634:  
  635:        for (i = 0; i < AssocDevCounter; ++i)
  0024 95       [2]             TSX   
  0025 6f02     [5]             CLR   2,X
  0027 6f01     [5]             CLR   1,X
  0029 2029     [3]             BRA   L54 ;abs = 0054
  002b          L2B:    
  636:        {
  637:          /* If ED was already registered associate the same address and set the flag */
  638:          if(FLib_MemCmp(AssociatedDevices[i].ExtendedAddress,pMsgIn->msgData.associateInd.deviceAddress,8)){
  002b 95       [2]             TSX   
  002c e602     [3]             LDA   2,X
  002e ae0c     [2]             LDX   #12
  0030 42       [5]             MUL   
  0031 ab02     [2]             ADD   @AssociatedDevices:2
  0033 87       [2]             PSHA  
  0034 4f       [1]             CLRA  
  0035 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0037 87       [2]             PSHA  
  0038 9efe0d   [5]             LDHX  13,SP
  003b af01     [2]             AIX   #1
  003d a608     [2]             LDA   #8
  003f ac000000 [8]             CALL  FLib_MemCmp
  0043 a702     [2]             AIS   #2
  0045 4d       [1]             TSTA  
  0046 2705     [3]             BEQ   L4D ;abs = 004d
  639:            FoundFlag++;
  0048 95       [2]             TSX   
  0049 6c05     [5]             INC   5,X
  640:            break;
  004b 200f     [3]             BRA   L5C ;abs = 005c
  004d          L4D:    
  004d 95       [2]             TSX   
  004e 6c02     [5]             INC   2,X
  0050 2602     [3]             BNE   L54 ;abs = 0054
  0052 6c01     [5]             INC   1,X
  0054          L54:    
  0054 320000   [5]             LDHX  AssocDevCounter
  0057 9ef302   [6]             CPHX  2,SP
  005a 22cf     [3]             BHI   L2B ;abs = 002b
  005c          L5C:    
  641:          }
  642:        }
  643:  
  644:        if(FoundFlag){
  005c 95       [2]             TSX   
  005d 6d05     [4]             TST   5,X
  005f 2743     [3]             BEQ   LA4 ;abs = 00a4
  645:          FLib_MemCpy(pAssocRes->assocShortAddress, AssociatedDevices[i].ShortAddress, 2);
  0061 9efe04   [5]             LDHX  4,SP
  0064 af08     [2]             AIX   #8
  0066 89       [2]             PSHX  
  0067 8b       [2]             PSHH  
  0068 95       [2]             TSX   
  0069 e604     [3]             LDA   4,X
  006b ae0c     [2]             LDX   #12
  006d 42       [5]             MUL   
  006e ab00     [2]             ADD   @AssociatedDevices
  0070 95       [2]             TSX   
  0071 e702     [3]             STA   2,X
  0073 4f       [1]             CLRA  
  0074 a900     [2]             ADC   @AssociatedDevices:MSB
  0076 ee02     [3]             LDX   2,X
  0078 87       [2]             PSHA  
  0079 8a       [3]             PULH  
  007a a602     [2]             LDA   #2
  007c ac000000 [8]             CALL  FLib_MemCpy
  0080 a702     [2]             AIS   #2
  646:          FLib_MemCpy(pAssocRes->deviceAddress, AssociatedDevices[i].ExtendedAddress, 8);
  0082 9efe04   [5]             LDHX  4,SP
  0085 89       [2]             PSHX  
  0086 8b       [2]             PSHH  
  0087 95       [2]             TSX   
  0088 e604     [3]             LDA   4,X
  008a ae0c     [2]             LDX   #12
  008c 42       [5]             MUL   
  008d ab02     [2]             ADD   @AssociatedDevices:2
  008f 95       [2]             TSX   
  0090 e702     [3]             STA   2,X
  0092 4f       [1]             CLRA  
  0093 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0095 ee02     [3]             LDX   2,X
  0097 87       [2]             PSHA  
  0098 8a       [3]             PULH  
  0099 a608     [2]             LDA   #8
  009b ac000000 [8]             CALL  FLib_MemCpy
  009f a702     [2]             AIS   #2
  647:  
  648:        }else{
  00a1 cc013d   [4]             JMP   L13D ;abs = 013d
  00a4          LA4:    
  649:  
  650:  
  651:          if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  00a4 9efe0b   [5]             LDHX  11,SP
  00a7 e614     [3]             LDA   20,X
  00a9 2a1c     [3]             BPL   LC7 ;abs = 00c7
  652:          {
  653:            /* Assign a unique short address less than 0xfffe if the device requests so. */
  654:            uint16_t tmpAddr = AssocDevCounter + 1;
  00ab 320000   [5]             LDHX  AssocDevCounter
  00ae af01     [2]             AIX   #1
  00b0 9eff09   [5]             STHX  9,SP
  655:            FLib_MemCpy(pAssocRes->assocShortAddress, &tmpAddr, 2);
  00b3 9efe04   [5]             LDHX  4,SP
  00b6 af08     [2]             AIX   #8
  00b8 89       [2]             PSHX  
  00b9 8b       [2]             PSHH  
  00ba 95       [2]             TSX   
  00bb af0a     [2]             AIX   #10
  00bd a602     [2]             LDA   #2
  00bf ac000000 [8]             CALL  FLib_MemCpy
  00c3 a702     [2]             AIS   #2
  656:          }
  00c5 200a     [3]             BRA   LD1 ;abs = 00d1
  00c7          LC7:    
  657:          else
  658:          {
  659:            /* A short address of 0xfffe means that the device is granted access to
  660:               the PAN (Associate successful) but that long addressing is used.*/
  661:            pAssocRes->assocShortAddress[0] = 0xFE;
  00c7 9efe04   [5]             LDHX  4,SP
  00ca a6fe     [2]             LDA   #-2
  00cc e708     [3]             STA   8,X
  662:            pAssocRes->assocShortAddress[1] = 0xFF;
  00ce 4c       [1]             INCA  
  00cf e709     [3]             STA   9,X
  00d1          LD1:    
  663:  
  664:          }
  665:  
  666:  
  667:          /* Get the 64 bit address of the device requesting association. */
  668:          FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  00d1 9efe04   [5]             LDHX  4,SP
  00d4 89       [2]             PSHX  
  00d5 8b       [2]             PSHH  
  00d6 9efe0d   [5]             LDHX  13,SP
  00d9 af01     [2]             AIX   #1
  00db a608     [2]             LDA   #8
  00dd ac000000 [8]             CALL  FLib_MemCpy
  00e1 a702     [2]             AIS   #2
  669:  
  670:          /* Save Short and Extended address inside the local array */
  671:          FLib_MemCpy(AssociatedDevices[AssocDevCounter].ShortAddress, pAssocRes->assocShortAddress, 2);
  00e3 c60001   [4]             LDA   AssocDevCounter:1
  00e6 ae0c     [2]             LDX   #12
  00e8 42       [5]             MUL   
  00e9 ab00     [2]             ADD   @AssociatedDevices
  00eb 87       [2]             PSHA  
  00ec 4f       [1]             CLRA  
  00ed a900     [2]             ADC   @AssociatedDevices:MSB
  00ef 87       [2]             PSHA  
  00f0 9efe06   [5]             LDHX  6,SP
  00f3 af08     [2]             AIX   #8
  00f5 a602     [2]             LDA   #2
  00f7 ac000000 [8]             CALL  FLib_MemCpy
  00fb a702     [2]             AIS   #2
  672:          FLib_MemCpy(AssociatedDevices[AssocDevCounter].ExtendedAddress, pAssocRes->deviceAddress, 8);
  00fd c60001   [4]             LDA   AssocDevCounter:1
  0100 ae0c     [2]             LDX   #12
  0102 42       [5]             MUL   
  0103 ab02     [2]             ADD   @AssociatedDevices:2
  0105 87       [2]             PSHA  
  0106 4f       [1]             CLRA  
  0107 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0109 87       [2]             PSHA  
  010a 9efe06   [5]             LDHX  6,SP
  010d a608     [2]             LDA   #8
  010f ac000000 [8]             CALL  FLib_MemCpy
  0113 a702     [2]             AIS   #2
  673:          AssociatedDevices[AssocDevCounter].RxOnWhenIdle = pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoRxWhenIdle_c ? 0x1 : 0x0;
  0115 9efe0b   [5]             LDHX  11,SP
  0118 e614     [3]             LDA   20,X
  011a a508     [2]             BIT   #8
  011c 2602     [3]             BNE   L120 ;abs = 0120
  011e 4f       [1]             CLRA  
  011f 65       [3]             SKIP2 L122 ;abs = 0122
  0120          L120:   
  0120 a601     [2]             LDA   #1
  0122          L122:   
  0122 ac000205 [8]             CALL  App_SendAssociateResponse:517
  0126 d7000a   [4]             STA   @AssociatedDevices:10,X
  674:          AssociatedDevices[AssocDevCounter].DeviceType = pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoDeviceFfd_c ? 0x1 : 0x0;
  0129 9efe0b   [5]             LDHX  11,SP
  012c e614     [3]             LDA   20,X
  012e a502     [2]             BIT   #2
  0130 2602     [3]             BNE   L134 ;abs = 0134
  0132 4f       [1]             CLRA  
  0133 65       [3]             SKIP2 L136 ;abs = 0136
  0134          L134:   
  0134 a601     [2]             LDA   #1
  0136          L136:   
  0136 ac000205 [8]             CALL  App_SendAssociateResponse:517
  013a d7000b   [4]             STA   @AssociatedDevices:11,X
  013d          L13D:   
  675:          /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
  676:  
  677:        }
  678:  
  679:        pAssocRes->status = gSuccess_c;
  013d 9efe04   [5]             LDHX  4,SP
  0140 6f15     [5]             CLR   21,X
  680:        /* Do not use security */
  681:        #ifndef gMAC2006_d    
  682:            pAssocRes->securityEnable = FALSE;
  683:        #else
  684:            pAssocRes->securityLevel = 0;
  0142 6f0a     [5]             CLR   10,X
  685:        #endif //gMAC2006_d    
  686:            
  687:        
  688:        /* Send the Associate Response to the MLME. */
  689:        if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0144 9efe07   [5]             LDHX  7,SP
  0147 ac000000 [8]             CALL  NWK_MLME_SapHandler
  014b 4d       [1]             TSTA  
  014c 2703     [3]             BEQ   L151 ;abs = 0151
  014e cc01e7   [4]             JMP   L1E7 ;abs = 01e7
  0151          L151:   
  690:        {
  691:          CommUtil_Print("Done\n\r", gAllowToBlock_d);
  0151 450000   [3]             LDHX  @"Done\012\015"
  0154 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  692:          
  693:          /* Print association information */
  694:          if(FoundFlag)
  0158 95       [2]             TSX   
  0159 6d05     [4]             TST   5,X
  015b 2709     [3]             BEQ   L166 ;abs = 0166
  695:            CommUtil_Print("\n\r************************************\n\r\n\rWelcome back old friend\n\rShort Address: 0x", gAllowToBlock_d);
  015d 450000   [3]             LDHX  @"\012\015************************************\012\015\012\015Welcome back old friend\012\015Short Address: 0x"
  0160 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  0164 2012     [3]             BRA   L178 ;abs = 0178
  0166          L166:   
  696:          else{
  697:            CommUtil_Print("\n\r************************************\n\r\n\rI see you are new, welcome!\n\rShort Address: 0x", gAllowToBlock_d);
  0166 450000   [3]             LDHX  @"\012\015************************************\012\015\012\015I see you are new, welcome!\012\015Short Address: 0x"
  0169 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  698:            i = AssocDevCounter++;
  016d 320000   [5]             LDHX  AssocDevCounter
  0170 9eff02   [5]             STHX  2,SP
  0173 af01     [2]             AIX   #1
  0175 960000   [5]             STHX  AssocDevCounter
  0178          L178:   
  699:          }
  700:          CommUtil_PrintHex((uint8_t *)AssociatedDevices[i].ShortAddress, 2, 0);
  0178 95       [2]             TSX   
  0179 e602     [3]             LDA   2,X
  017b ae0c     [2]             LDX   #12
  017d 42       [5]             MUL   
  017e ab00     [2]             ADD   @AssociatedDevices
  0180 87       [2]             PSHA  
  0181 4f       [1]             CLRA  
  0182 a900     [2]             ADC   @AssociatedDevices:MSB
  0184 87       [2]             PSHA  
  0185 ae02     [2]             LDX   #2
  0187 4f       [1]             CLRA  
  0188 ac000000 [8]             CALL  CommUtil_PrintHex
  018c a702     [2]             AIS   #2
  701:          CommUtil_Print("\n\rLong Address: 0x", gAllowToBlock_d);
  018e 450000   [3]             LDHX  @"\012\015Long Address: 0x"
  0191 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  702:          CommUtil_PrintHex((uint8_t *)AssociatedDevices[i].ExtendedAddress, 8, 0);
  0195 95       [2]             TSX   
  0196 e602     [3]             LDA   2,X
  0198 ae0c     [2]             LDX   #12
  019a 42       [5]             MUL   
  019b ab02     [2]             ADD   @AssociatedDevices:2
  019d 87       [2]             PSHA  
  019e 4f       [1]             CLRA  
  019f a902     [2]             ADC   @AssociatedDevices:2:MSB
  01a1 87       [2]             PSHA  
  01a2 ae08     [2]             LDX   #8
  01a4 4f       [1]             CLRA  
  01a5 ac000000 [8]             CALL  CommUtil_PrintHex
  01a9 a702     [2]             AIS   #2
  703:          if(AssociatedDevices[i].RxOnWhenIdle)
  01ab 95       [2]             TSX   
  01ac e602     [3]             LDA   2,X
  01ae ae0c     [2]             LDX   #12
  01b0 42       [5]             MUL   
  01b1 8c       [1]             CLRH  
  01b2 97       [1]             TAX   
  01b3 de000a   [4]             LDX   @AssociatedDevices:10,X
  01b6 2705     [3]             BEQ   L1BD ;abs = 01bd
  704:            CommUtil_Print("\n\rRX On When Idle: Yes", gAllowToBlock_d);
  01b8 450000   [3]             LDHX  @"\012\015RX On When Idle: Yes"
  01bb 2003     [3]             BRA   L1C0 ;abs = 01c0
  01bd          L1BD:   
  705:          else
  706:            CommUtil_Print("\n\rRX On When Idle: No", gAllowToBlock_d);
  01bd 450000   [3]             LDHX  @"\012\015RX On When Idle: No"
  01c0          L1C0:   
  01c0 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  707:          if(AssociatedDevices[i].DeviceType)
  01c4 95       [2]             TSX   
  01c5 e602     [3]             LDA   2,X
  01c7 ae0c     [2]             LDX   #12
  01c9 42       [5]             MUL   
  01ca 8c       [1]             CLRH  
  01cb 97       [1]             TAX   
  01cc de000b   [4]             LDX   @AssociatedDevices:11,X
  01cf 2705     [3]             BEQ   L1D6 ;abs = 01d6
  708:            CommUtil_Print("\n\rDevice Type: FFD", gAllowToBlock_d);
  01d1 450000   [3]             LDHX  @"\012\015Device Type: FFD"
  01d4 2003     [3]             BRA   L1D9 ;abs = 01d9
  01d6          L1D6:   
  709:          else
  710:            CommUtil_Print("\n\rDevice Type: RFD", gAllowToBlock_d);
  01d6 450000   [3]             LDHX  @"\012\015Device Type: RFD"
  01d9          L1D9:   
  01d9 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  711:          CommUtil_Print("\n\r\n\r************************************\n\r", gAllowToBlock_d);
  01dd 450000   [3]             LDHX  @"\012\015\012\015************************************\012\015"
  01e0 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  712:          
  713:          return errorNoError;
  01e4 4f       [1]             CLRA  
  01e5 2014     [3]             BRA   L1FB ;abs = 01fb
  01e7          L1E7:   
  714:        }
  715:        else
  716:        {
  717:          /* One or more parameters in the message were invalid. */
  718:          CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  01e7 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  01ea ac0001fe [8]             CALL  App_SendAssociateResponse:510
  719:          return errorInvalidParameter;
  01ee a605     [2]             LDA   #5
  01f0 2009     [3]             BRA   L1FB ;abs = 01fb
  01f2          L1F2:   
  720:        }
  721:      
  722:    }
  723:    else
  724:    {
  725:      /* Allocation of a message buffer failed. */
  726:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  01f2 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  01f5 ac0001fe [8]             CALL  App_SendAssociateResponse:510
  727:      return errorAllocFailed;
  01f9 a604     [2]             LDA   #4
  01fb          L1FB:   
  728:    }
  729:  }
  01fb a70c     [2]             AIS   #12
  01fd 8d       [7]             RTC   
  01fe          L1FE:   
  01fe a601     [2]             LDA   #1
  0200 ac000000 [8]             CALL  CommUtil_Print
  0204 8d       [7]             RTC   
  0205          L205:   
  0205 ce0001   [4]             LDX   AssocDevCounter:1
  0208 87       [2]             PSHA  
  0209 a60c     [2]             LDA   #12
  020b 42       [5]             MUL   
  020c 8c       [1]             CLRH  
  020d 97       [1]             TAX   
  020e 86       [3]             PULA  
  020f 8d       [7]             RTC   
  730:  
  731:  /******************************************************************************
  732:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  733:  * messages from the MLME, e.g. (Dis)Associate Indication.
  734:  *
  735:  * The function may return either of the following values:
  736:  *   errorNoError:   The message was processed.
  737:  *   errorNoMessage: The message pointer is NULL.
  738:  ******************************************************************************/
  739:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  740:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  741:    if(pMsg == NULL)
  0002 650000   [3]             CPHX  #0
  0005 2604     [3]             BNE   LB ;abs = 000b
  742:      return errorNoMessage;
  0007 a603     [2]             LDA   #3
  0009 2025     [3]             BRA   L30 ;abs = 0030
  000b          LB:     
  743:    
  744:    /* Handle the incoming message. The type determines the sort of processing.*/
  745:    switch(pMsg->msgType) {
  000b f6       [3]             LDA   ,X
  000c 2706     [3]             BEQ   L14 ;abs = 0014
  000e a10c     [2]             CMP   #12
  0010 261d     [3]             BNE   L2F ;abs = 002f
  0012 2012     [3]             BRA   L26 ;abs = 0026
  0014          L14:    
  746:    case gNwkAssociateInd_c:
  747:      CommUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
  0014 450000   [3]             LDHX  @"Received an MLME-Associate Indication from the MAC\012\015"
  0017 a601     [2]             LDA   #1
  0019 ac000000 [8]             CALL  CommUtil_Print
  748:      /* A device sent us an Associate Request. We must send back a response.  */
  749:      return App_SendAssociateResponse(pMsg);
  001d 9efe01   [5]             LDHX  1,SP
  0020 ac000000 [8]             CALL  App_SendAssociateResponse
  0024 200a     [3]             BRA   L30 ;abs = 0030
  0026          L26:    
  750:      break;
  751:      
  752:    case gNwkCommStatusInd_c:
  753:      /* Sent by the MLME after the Association Response has been transmitted. */
  754:      CommUtil_Print("Received an MLME-Comm-Status Indication from the MAC\n\r", gAllowToBlock_d);
  0026 450000   [3]             LDHX  @"Received an MLME-Comm-Status Indication from the MAC\012\015"
  0029 a601     [2]             LDA   #1
  002b ac000000 [8]             CALL  CommUtil_Print
  002f          L2F:    
  755:      break;
  756:    }
  757:    return errorNoError;
  002f 4f       [1]             CLRA  
  0030          L30:    
  758:  }
  0030 a702     [2]             AIS   #2
  0032 8d       [7]             RTC   
  759:  
  760:  /******************************************************************************
  761:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
  762:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
  763:  *
  764:  ******************************************************************************/
  765:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
  766:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fc     [2]             AIS   #-4
  767:  	uint8_t i;
  768:  	uint8_t *btnValue;
  769:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2705     [3]             BEQ   LC ;abs = 000c
  0007 41010e   [4]             CBEQA #1,L18 ;abs = 0018
  000a 2009     [3]             BRA   L15 ;abs = 0015
  000c          LC:     
  770:    {
  771:      /* The MCPS-Data confirm is sent by the MAC to the network 
  772:         or application layer when data has been sent. */
  773:    case gMcpsDataCnf_c:
  774:      if(mcPendingPackets)
  000c c60000   [4]             LDA   mcPendingPackets
  000f 2704     [3]             BEQ   L15 ;abs = 0015
  775:        mcPendingPackets--;
  0011 450000   [3]             LDHX  @mcPendingPackets
  0014 7a       [4]             DEC   ,X
  0015          L15:    
  0015 cc0124   [4]             JMP   L124 ;abs = 0124
  0018          L18:    
  776:      break;
  777:    
  778:    case gMcpsDataInd_c:
  779:      /* The MCPS-Data indication is sent by the MAC to the network 
  780:         or application layer when data has been received. We simply 
  781:         copy the received data to the serial terminal interface. */
  782:  
  783:  
  784:  
  785:    /* NEWCODE: Check for Button Data */
  786:      if(FLib_MemCmp(pMsgIn->msgData.dataInd.pMsdu,"Counter:",8)){
  0018 9ece29   [5]             LDHX  41,X
  001b 89       [2]             PSHX  
  001c 8b       [2]             PSHH  
  001d 450000   [3]             LDHX  @"Counter:"
  0020 a608     [2]             LDA   #8
  0022 ac000000 [8]             CALL  FLib_MemCmp
  0026 a702     [2]             AIS   #2
  0028 4d       [1]             TSTA  
  0029 2603     [3]             BNE   L2E ;abs = 002e
  002b cc0124   [4]             JMP   L124 ;abs = 0124
  002e          L2E:    
  787:      	btnValue = (uint8_t *)pMsgIn->msgData.dataInd.pMsdu;
  002e 9efe05   [5]             LDHX  5,SP
  0031 9ece29   [5]             LDHX  41,X
  788:      	btnValue += 8;
  0034 af08     [2]             AIX   #8
  789:        TurnOffLeds();
  0036 89       [2]             PSHX  
  0037 8b       [2]             PSHH  
  0038 ac000000 [8]             CALL  LED_TurnOffAllLeds
  790:        switch(*btnValue){
  003c 8a       [3]             PULH  
  003d 88       [3]             PULX  
  003e f6       [3]             LDA   ,X
  003f a134     [2]             CMP   #52
  0041 221a     [3]             BHI   L5D ;abs = 005d
  0043 a031     [2]             SUB   #49
  0045 97       [1]             TAX   
  0046 4f       [1]             CLRA  
  0047 cd0000   [6]             JSR   _Jump_Table_Header_Offset
  004a 04               DC.B  4
  004b 11               DC.B  L5D
  004c 03               DC.B  L50
  004d 06               DC.B  L54
  004e 09               DC.B  L58
  004f 0b               DC.B  L5B
  0050          L50:    
  791:          case '1':
  792:           Led1On();
  0050 1100     [5]             BCLR  0,0
  793:          break;
  0052 2009     [3]             BRA   L5D ;abs = 005d
  0054          L54:    
  794:          case '2':
  795:           Led2On();
  0054 1900     [5]             BCLR  4,0
  796:          break;
  0056 2005     [3]             BRA   L5D ;abs = 005d
  0058          L58:    
  797:          case '3':
  798:           Led3On();
  0058 1106     [5]             BCLR  0,6
  799:          break;
  005a 65       [3]             SKIP2 L5D ;abs = 005d
  005b          L5B:    
  800:          case '4':
  801:           Led4On();
  005b 1306     [5]             BCLR  1,6
  005d          L5D:    
  802:          break;
  803:        }
  804:  
  805:        CommUtil_Print("Source Addres : 0x", gAllowToBlock_d);
  005d 450000   [3]             LDHX  @"Source Addres : 0x"
  0060 ac000127 [8]             CALL  App_HandleMcpsInput:295
  806:        CommUtil_PrintHex((uint8_t *)pMsgIn->msgData.dataInd.srcAddr, 2, 0);
  0064 9efe05   [5]             LDHX  5,SP
  0067 af0c     [2]             AIX   #12
  0069 89       [2]             PSHX  
  006a 8b       [2]             PSHH  
  006b ae02     [2]             LDX   #2
  006d 4f       [1]             CLRA  
  006e ac000000 [8]             CALL  CommUtil_PrintHex
  0072 a702     [2]             AIS   #2
  807:        CommUtil_Print("\r\n", gAllowToBlock_d);
  0074 450000   [3]             LDHX  @"\015\012"
  0077 ac000127 [8]             CALL  App_HandleMcpsInput:295
  808:        CommUtil_Print("Link Quality : 0x", gAllowToBlock_d);
  007b 450000   [3]             LDHX  @"Link Quality : 0x"
  007e ac000127 [8]             CALL  App_HandleMcpsInput:295
  809:        CommUtil_PrintHex((uint8_t *)pMsgIn->msgData.dataInd.mpduLinkQuality, 1, 0);          
  0082 9efe05   [5]             LDHX  5,SP
  0085 e618     [3]             LDA   24,X
  0087 87       [2]             PSHA  
  0088 4f       [1]             CLRA  
  0089 87       [2]             PSHA  
  008a ae01     [2]             LDX   #1
  008c ac000000 [8]             CALL  CommUtil_PrintHex
  0090 a702     [2]             AIS   #2
  810:        CommUtil_Print("\r\n", gAllowToBlock_d);
  0092 450000   [3]             LDHX  @"\015\012"
  0095 ac000127 [8]             CALL  App_HandleMcpsInput:295
  811:        CommUtil_Print("Data : ", gAllowToBlock_d);
  0099 450000   [3]             LDHX  @"Data : "
  009c ac000127 [8]             CALL  App_HandleMcpsInput:295
  812:        CommUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  00a0 9efe05   [5]             LDHX  5,SP
  00a3 9ece29   [5]             LDHX  41,X
  00a6 9eff02   [5]             STHX  2,SP
  00a9 9efe05   [5]             LDHX  5,SP
  00ac e617     [3]             LDA   23,X
  00ae 9efe02   [5]             LDHX  2,SP
  00b1 ac000000 [8]             CALL  CommUtil_Tx
  813:        CommUtil_Print("\r\n", gAllowToBlock_d);
  00b5 450000   [3]             LDHX  @"\015\012"
  00b8 ac000127 [8]             CALL  App_HandleMcpsInput:295
  814:        
  815:        for (i = 0; i < AssocDevCounter; ++i)
  00bc 95       [2]             TSX   
  00bd 6f03     [5]             CLR   3,X
  00bf 2058     [3]             BRA   L119 ;abs = 0119
  00c1          LC1:    
  816:        {
  817:          if(FLib_MemCmp(AssociatedDevices[i].ShortAddress,pMsgIn->msgData.dataInd.srcAddr,2)){
  00c1 95       [2]             TSX   
  00c2 e603     [3]             LDA   3,X
  00c4 ae0c     [2]             LDX   #12
  00c6 42       [5]             MUL   
  00c7 95       [2]             TSX   
  00c8 f7       [2]             STA   ,X
  00c9 ab00     [2]             ADD   @AssociatedDevices
  00cb 87       [2]             PSHA  
  00cc 4f       [1]             CLRA  
  00cd a900     [2]             ADC   @AssociatedDevices:MSB
  00cf 87       [2]             PSHA  
  00d0 9efe07   [5]             LDHX  7,SP
  00d3 af0c     [2]             AIX   #12
  00d5 a602     [2]             LDA   #2
  00d7 ac000000 [8]             CALL  FLib_MemCmp
  00db a702     [2]             AIS   #2
  00dd 4d       [1]             TSTA  
  00de 2736     [3]             BEQ   L116 ;abs = 0116
  818:            genericDataTransfer("APP_ACK", 7,AssociatedDevices[i] );
  00e0 450000   [3]             LDHX  @"APP_ACK"
  00e3 89       [2]             PSHX  
  00e4 8b       [2]             PSHH  
  00e5 a607     [2]             LDA   #7
  00e7 87       [2]             PSHA  
  00e8 95       [2]             TSX   
  00e9 e603     [3]             LDA   3,X
  00eb ab00     [2]             ADD   @AssociatedDevices
  00ed e703     [3]             STA   3,X
  00ef 4f       [1]             CLRA  
  00f0 a900     [2]             ADC   @AssociatedDevices:MSB
  00f2 87       [2]             PSHA  
  00f3 8a       [3]             PULH  
  00f4 a7f4     [2]             AIS   #-12
  00f6 95       [2]             TSX   
  00f7 89       [2]             PSHX  
  00f8 8b       [2]             PSHH  
  00f9 87       [2]             PSHA  
  00fa ee0f     [3]             LDX   15,X
  00fc 8a       [3]             PULH  
  00fd a60c     [2]             LDA   #12
  00ff cd0000   [6]             JSR   _COPY
  0102 ac000000 [8]             CALL  genericDataTransfer
  0106 a70f     [2]             AIS   #15
  819:            CommUtil_Print("APP_ACK Sent to Device\r\n", gAllowToBlock_d);
  0108 450000   [3]             LDHX  @"APP_ACK Sent to Device\015\012"
  010b ac000127 [8]             CALL  App_HandleMcpsInput:295
  820:            CommUtil_Print("******************************\r\n", gAllowToBlock_d);
  010f 450000   [3]             LDHX  @"******************************\015\012"
  0112 ac000127 [8]             CALL  App_HandleMcpsInput:295
  0116          L116:   
  0116 95       [2]             TSX   
  0117 6c03     [5]             INC   3,X
  0119          L119:   
  0119 95       [2]             TSX   
  011a ee03     [3]             LDX   3,X
  011c 8c       [1]             CLRH  
  011d 3e0000   [6]             CPHX  AssocDevCounter
  0120 2402     [3]             BCC   L124 ;abs = 0124
  0122 209d     [3]             BRA   LC1 ;abs = 00c1
  0124          L124:   
  821:          }
  822:        }
  823:        
  824:  
  825:      }
  826:      /* NEWCODE: Check for Button Data */
  827:      break;
  828:    }
  829:  }
  0124 a706     [2]             AIS   #6
  0126 8d       [7]             RTC   
  0127          L127:   
  0127 a601     [2]             LDA   #1
  0129 ac000000 [8]             CALL  CommUtil_Print
  012d 8d       [7]             RTC   
  830:  
  831:  /******************************************************************************
  832:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
  833:  * the name implies, wait for a message, thus blocking the execution of the
  834:  * state machine. Instead the function analyzes the supplied message to determine
  835:  * whether or not the message is of the expected type.
  836:  * The function may return either of the following values:
  837:  *   errorNoError: The message was of the expected type.
  838:  *   errorNoMessage: The message pointer is NULL.
  839:  *   errorWrongConfirm: The message is not of the expected type.
  840:  *
  841:  ******************************************************************************/
  842:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
  843:  {
  844:    /* Do we have a message? If not, the exit with error code */
  845:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  846:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  847:  
  848:    /* Is it the expected message type? If not then exit with error code */
  849:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
  850:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
  851:  
  852:    /* Found the expected message. Return with success code */
  853:    return errorNoError;
  000e 4f       [1]             CLRA  
  854:  }
  000f 8d       [7]             RTC   
  855:  
  856:  /******************************************************************************
  857:  * The App_TransmitCommData() function will perform (single/multi buffered)
  858:  * data transmissions of data received by the serial terminal interface. Data could also come from
  859:  * other sources such as sensors etc. This is completely determined by the
  860:  * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
  861:  * number of packets pending for transmission in the MAC. A global variable
  862:  * is incremented each time a data packet is sent to the MCPS, and decremented
  863:  * when the corresponding MCPS-Data Confirm message is received. If the counter
  864:  * reaches the defined maximum no more data buffers are allocated until the
  865:  * counter is decreased below the maximum number of pending packets.
  866:  *
  867:  * The function uses the device information, that was stored when the device,
  868:  * associated to us, for building an MCPS-Data Request message. The message
  869:  * is sent to the MCPS service access point in the MAC.
  870:  ******************************************************************************/
  871:  static void App_TransmitCommData(void)
  872:  {   
  0000 a7fc     [2]             AIS   #-4
  873:    static uint8_t keysBuffer[mMaxKeysToReceive_c];
  874:    static uint8_t keysReceived = 0;
  875:    static char *appAck = "APP_ACK";
  876:    uint16_t i = 0;
  877:    /* get data from serial terminal interface */
  878:    if( keysReceived < mMaxKeysToReceive_c) 
  0002 c60000   [4]             LDA   keysReceived
  0005 a120     [2]             CMP   #32
  0007 2414     [3]             BCC   L1D ;abs = 001d
  879:    { 
  880:      if(Comm_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
  0009 ab00     [2]             ADD   @keysBuffer
  000b 87       [2]             PSHA  
  000c 4f       [1]             CLRA  
  000d a900     [2]             ADC   @keysBuffer:MSB
  000f 88       [3]             PULX  
  0010 87       [2]             PSHA  
  0011 8a       [3]             PULH  
  0012 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0016 4d       [1]             TSTA  
  0017 2704     [3]             BEQ   L1D ;abs = 001d
  881:      {
  882:      keysReceived++;
  0019 450000   [3]             LDHX  @keysReceived
  001c 7c       [4]             INC   ,X
  001d          L1D:    
  883:      }
  884:    }
  885:    /* Use multi buffering for increased TX performance. It does not really
  886:       have any effect at a UART baud rate of 19200bps but serves as an
  887:       example of how the throughput may be improved in a real-world 
  888:       application where the data rate is of concern. */
  889:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  001d c60000   [4]             LDA   mcPendingPackets
  0020 a102     [2]             CMP   #2
  0022 240e     [3]             BCC   L32 ;abs = 0032
  0024 320000   [5]             LDHX  mpPacket
  0027 2609     [3]             BNE   L32 ;abs = 0032
  890:    {
  891:      /* If the maximum number of pending data buffes is below maximum limit 
  892:         and we do not have a data buffer already then allocate one. */
  893:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  0029 a69c     [2]             LDA   #-100
  002b ac000000 [8]             CALL  MM_Alloc
  002f 960000   [5]             STHX  mpPacket
  0032          L32:    
  894:    }
  895:  
  896:    if(mpPacket != NULL)
  0032 320000   [5]             LDHX  mpPacket
  0035 2603     [3]             BNE   L3A ;abs = 003a
  0037 cc0133   [4]             JMP   L133 ;abs = 0133
  003a          L3A:    
  897:    {
  898:  
  899:  
  900:        for (i = 0; i < AssocDevCounter; ++i)
  003a 95       [2]             TSX   
  003b 6f03     [5]             CLR   3,X
  003d 6f02     [5]             CLR   2,X
  003f cc0128   [4]             JMP   L128 ;abs = 0128
  0042          L42:    
  901:        {
  902:  
  903:          if(!AssociatedDevices[i].DeviceType){
  0042 95       [2]             TSX   
  0043 e603     [3]             LDA   3,X
  0045 ae0c     [2]             LDX   #12
  0047 42       [5]             MUL   
  0048 95       [2]             TSX   
  0049 f7       [2]             STA   ,X
  004a 8c       [1]             CLRH  
  004b 97       [1]             TAX   
  004c de000b   [4]             LDX   @AssociatedDevices:11,X
  004f 2628     [3]             BNE   L79 ;abs = 0079
  904:            genericDataTransfer((uint8_t *)appAck, 7,AssociatedDevices[i] );
  0051 320000   [5]             LDHX  appAck
  0054 89       [2]             PSHX  
  0055 8b       [2]             PSHH  
  0056 a607     [2]             LDA   #7
  0058 87       [2]             PSHA  
  0059 95       [2]             TSX   
  005a e603     [3]             LDA   3,X
  005c ab00     [2]             ADD   @AssociatedDevices
  005e e703     [3]             STA   3,X
  0060 4f       [1]             CLRA  
  0061 a900     [2]             ADC   @AssociatedDevices:MSB
  0063 87       [2]             PSHA  
  0064 8a       [3]             PULH  
  0065 a7f4     [2]             AIS   #-12
  0067 95       [2]             TSX   
  0068 89       [2]             PSHX  
  0069 8b       [2]             PSHH  
  006a 87       [2]             PSHA  
  006b ee0f     [3]             LDX   15,X
  006d 8a       [3]             PULH  
  006e a60c     [2]             LDA   #12
  0070 cd0000   [6]             JSR   _COPY
  0073 ac000000 [8]             CALL  genericDataTransfer
  0077 a70f     [2]             AIS   #15
  0079          L79:    
  905:          }
  906:  
  907:  
  908:                /* get data from serial terminal interface */        
  909:          mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  0079 320000   [5]             LDHX  mpPacket
  007c af27     [2]             AIX   #39
  007e 9f       [1]             TXA   
  007f 8b       [2]             PSHH  
  0080 320000   [5]             LDHX  mpPacket
  0083 e726     [3]             STA   38,X
  0085 86       [3]             PULA  
  0086 e725     [3]             STA   37,X
  910:          FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) keysBuffer, keysReceived);
  0088 9ece25   [5]             LDHX  37,X
  008b 89       [2]             PSHX  
  008c 8b       [2]             PSHH  
  008d 450000   [3]             LDHX  @keysBuffer
  0090 c60000   [4]             LDA   keysReceived
  0093 ac000000 [8]             CALL  FLib_MemCpy
  0097 a702     [2]             AIS   #2
  911:  
  912:          /* Data was available in the serial terminal interface receive buffer. Now create an
  913:             MCPS-Data Request message containing the serial terminal interface data. */
  914:          mpPacket->msgType = gMcpsDataReq_c;
  0099 320000   [5]             LDHX  mpPacket
  009c 7f       [4]             CLR   ,X
  915:          /* Create the header using device information stored when creating 
  916:             the association response. In this simple example the use of short
  917:             addresses is hardcoded. In a real world application we must be
  918:             flexible, and use the address mode required by the given situation. */
  919:          FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, AssociatedDevices[i].ShortAddress, 2);
  009d af01     [2]             AIX   #1
  009f 89       [2]             PSHX  
  00a0 8b       [2]             PSHH  
  00a1 95       [2]             TSX   
  00a2 e605     [3]             LDA   5,X
  00a4 ae0c     [2]             LDX   #12
  00a6 42       [5]             MUL   
  00a7 95       [2]             TSX   
  00a8 e702     [3]             STA   2,X
  00aa ab00     [2]             ADD   @AssociatedDevices
  00ac e703     [3]             STA   3,X
  00ae 4f       [1]             CLRA  
  00af a900     [2]             ADC   @AssociatedDevices:MSB
  00b1 ee03     [3]             LDX   3,X
  00b3 87       [2]             PSHA  
  00b4 8a       [3]             PULH  
  00b5 a602     [2]             LDA   #2
  00b7 ac000000 [8]             CALL  FLib_MemCpy
  00bb a702     [2]             AIS   #2
  920:          FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  00bd 320000   [5]             LDHX  mpPacket
  00c0 af0c     [2]             AIX   #12
  00c2 89       [2]             PSHX  
  00c3 8b       [2]             PSHH  
  00c4 450000   [3]             LDHX  @maShortAddress
  00c7 a602     [2]             LDA   #2
  00c9 ac000000 [8]             CALL  FLib_MemCpy
  00cd a702     [2]             AIS   #2
  921:          FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  00cf 320000   [5]             LDHX  mpPacket
  00d2 af09     [2]             AIX   #9
  00d4 ac000136 [8]             CALL  App_TransmitCommData:310
  922:          FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  00d8 320000   [5]             LDHX  mpPacket
  00db af14     [2]             AIX   #20
  00dd ac000136 [8]             CALL  App_TransmitCommData:310
  923:          mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  00e1 a602     [2]             LDA   #2
  00e3 320000   [5]             LDHX  mpPacket
  00e6 e70b     [3]             STA   11,X
  924:          mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  00e8 e716     [3]             STA   22,X
  925:          mpPacket->msgData.dataReq.msduLength = keysReceived;
  00ea c60000   [4]             LDA   keysReceived
  00ed e717     [3]             STA   23,X
  926:          
  927:  
  928:          /* Transfer Options in case of FFD / RFD */
  929:          if(AssociatedDevices[i].DeviceType)
  00ef 8c       [1]             CLRH  
  00f0 9eee01   [4]             LDX   1,SP
  00f3 d6000b   [4]             LDA   @AssociatedDevices:11,X
  00f6 2703     [3]             BEQ   LFB ;abs = 00fb
  930:            /* Request MAC level acknowledgement of the data packet */
  931:            mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c;         /* Direct Transfer for FFD Device */
  00f8 a601     [2]             LDA   #1
  00fa 65       [3]             SKIP2 LFD ;abs = 00fd
  00fb          LFB:    
  932:          else
  933:            /* Request MAC level acknowledgement of the data packet and transmit Indirectly */
  934:            mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c;     /* Indirect Transfer for RFD device */
  00fb a605     [2]             LDA   #5
  00fd          LFD:    
  00fd 320000   [5]             LDHX  mpGenericPkg
  0100 e719     [3]             STA   25,X
  935:  
  936:          /* Give the data packet a handle. The handle is
  937:             returned in the MCPS-Data Confirm message. */
  938:          mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0102 c60000   [4]             LDA   mMsduHandle
  0105 320000   [5]             LDHX  mpPacket
  0108 e718     [3]             STA   24,X
  010a 4c       [1]             INCA  
  010b c70000   [4]             STA   mMsduHandle
  939:          #ifdef gMAC2006_d
  940:                mpPacket->msgData.dataReq.securityLevel = 0;
  010e 6f1a     [5]             CLR   26,X
  941:          #endif //gMAC2006_d      
  942:          
  943:          /* Send the Data Request to the MCPS */
  944:          (void)MSG_Send(NWK_MCPS, mpPacket);
  0110 ac000000 [8]             CALL  NWK_MCPS_SapHandler
  945:          /* Prepare for another data buffer */
  946:          mpPacket = NULL;
  0114 5f       [1]             CLRX  
  0115 8c       [1]             CLRH  
  0116 960000   [5]             STHX  mpPacket
  947:          mcPendingPackets++;
  0119 450000   [3]             LDHX  @mcPendingPackets
  011c 7c       [4]             INC   ,X
  948:          /* Receive another pressed keys */
  949:          keysReceived = 0;
  011d 4f       [1]             CLRA  
  011e c70000   [4]             STA   keysReceived
  0121 95       [2]             TSX   
  0122 6c03     [5]             INC   3,X
  0124 2602     [3]             BNE   L128 ;abs = 0128
  0126 6c02     [5]             INC   2,X
  0128          L128:   
  0128 320000   [5]             LDHX  AssocDevCounter
  012b 9ef303   [6]             CPHX  3,SP
  012e 2303     [3]             BLS   L133 ;abs = 0133
  0130 cc0042   [4]             JMP   L42 ;abs = 0042
  0133          L133:   
  950:  
  951:  
  952:        }
  953:  
  954:  
  955:    }
  956:    
  957:    /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
  958:    /* try to send it later   */
  959:    if (keysReceived)
  960:    {
  961:    //TS_SendEvent(gAppTaskID_c, gAppEvtRxFromComm_c);
  962:    }
  963:  }
  0133 a704     [2]             AIS   #4
  0135 8d       [7]             RTC   
  0136          L136:   
  0136 89       [2]             PSHX  
  0137 8b       [2]             PSHH  
  0138 450000   [3]             LDHX  @maPanId
  013b a602     [2]             LDA   #2
  013d ac000000 [8]             CALL  FLib_MemCpy
  0141 a702     [2]             AIS   #2
  0143 8d       [7]             RTC   
  964:  
  965:  /*****************************************************************************
  966:  * Function to handle a generic key press. Called for all keys.
  967:  *****************************************************************************/
  968:  static void App_HandleGenericKey(void)
  969:  {
  970:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
  971:    {
  972:      StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
  973:      StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
  974:      StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
  975:      StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
  976:      Led1Off();
  001d 1000     [5]             BSET  0,0
  977:      Led2Off();
  001f 1800     [5]             BSET  4,0
  978:      Led3Off();
  0021 1006     [5]             BSET  0,6
  979:      Led4Off();
  0023 1206     [5]             BSET  1,6
  980:      LCD_ClearDisplay();
  981:      LCD_WriteString(1,"Application");
  982:      LCD_WriteString(2,"    started");     
  983:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
  984:    }
  985:  }
  002f 8d       [7]             RTC   
  986:  
  987:  /*****************************************************************************
  988:  * Handles all key events for this device.
  989:  * Interface assumptions: None
  990:  * Return value: None
  991:  *****************************************************************************/
  992:  #if (gMC1323xMatrixKBD_d == TRUE)
  993:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
  994:  {
  995:   (void)events;
  996:   (void)pressedKey;
  997:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
  998:  }
  0004 8d       [7]             RTC   
  999:  #else
 1000:  static void App_HandleKeys(key_event_t events)
 1001:  {
 1002:    switch ( events ) 
 1003:      { 
 1004:        case gKBD_EventSW1_c:
 1005:        case gKBD_EventSW2_c:
 1006:        case gKBD_EventSW3_c:
 1007:        case gKBD_EventSW4_c:
 1008:        case gKBD_EventLongSW1_c:
 1009:        case gKBD_EventLongSW2_c:
 1010:        case gKBD_EventLongSW3_c:
 1011:        case gKBD_EventLongSW4_c:
 1012:         App_HandleGenericKey();
 1013:         break;  
 1014:      }    
 1015:  }                                                      
 1016:  #endif //gMC1323xMatrixKBD_d
 1017:  /*****************************************************************************
 1018:  * The DeepSleepWakeupStackProc(void) function is called each time the 
 1019:  * application exits the DeepSleep mode .
 1020:  * 
 1021:  * Return value:
 1022:  *     None
 1023:  *****************************************************************************/
 1024:  void DeepSleepWakeupStackProc(void){
 1025:    return;
 1026:  }
  0000 8d       [7]             RTC   
 1027:  
 1028:  /******************************************************************************
 1029:  * The following functions are called by the MAC to put messages into the
 1030:  * Application's queue. They need to be defined even if they are not used
 1031:  * in order to avoid linker errors.
 1032:  ******************************************************************************/
 1033:  
 1034:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
 1035:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1036:    /* Put the incoming MLME message in the applications input queue. */
 1037:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1038:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1039:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1040:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1041:  
 1042:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
 1043:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1044:    /* Put the incoming MCPS message in the applications input queue. */
 1045:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1046:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1047:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1048:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1049:  
 1050:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
 1051:  {
 1052:    /* If the message is not handled anywhere it must be freed. */
 1053:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
 1054:    return gSuccess_c;
  0004 4f       [1]             CLRA  
 1055:  }
  0005 8d       [7]             RTC   
 1056:  
 1057:  /******************************************************************************/
 1058:  
 1059:  /* NEWCODE: Added function to send package over the air with the active button number */
 1060:  
 1061:  static void genericDataTransfer(uint8_t *ptrPDU, uint8_t lengthPDU, EndDevListItem_t dstDevice ){
 1062:  
 1063:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpGenericPkg == NULL) ) 
  0000 c60000   [4]             LDA   mcPendingPackets
  0003 a102     [2]             CMP   #2
  0005 240e     [3]             BCC   L15 ;abs = 0015
  0007 320000   [5]             LDHX  mpGenericPkg
  000a 2609     [3]             BNE   L15 ;abs = 0015
 1064:    {
 1065:      /* If the maximum number of pending data buffes is below maximum limit 
 1066:         and we do not have a data buffer already then allocate one. */
 1067:      mpGenericPkg = MSG_Alloc(gMaxRxTxDataLength_c);
  000c a69c     [2]             LDA   #-100
  000e ac000000 [8]             CALL  MM_Alloc
  0012 960000   [5]             STHX  mpGenericPkg
  0015          L15:    
 1068:    }
 1069:  
 1070:    if(mpGenericPkg != NULL)
  0015 320000   [5]             LDHX  mpGenericPkg
  0018 277d     [3]             BEQ   L97 ;abs = 0097
 1071:    {
 1072:      /* get data from serial terminal interface */        
 1073:        mpGenericPkg->msgData.dataReq.pMsdu = (uint8_t*)(&(mpGenericPkg->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  001a af27     [2]             AIX   #39
  001c 9f       [1]             TXA   
  001d 8b       [2]             PSHH  
  001e 320000   [5]             LDHX  mpGenericPkg
  0021 e726     [3]             STA   38,X
  0023 86       [3]             PULA  
  0024 e725     [3]             STA   37,X
 1074:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.pMsdu, (uint8_t*) ptrPDU, 9);
  0026 9ece25   [5]             LDHX  37,X
  0029 89       [2]             PSHX  
  002a 8b       [2]             PSHH  
  002b 9efe13   [5]             LDHX  19,SP
  002e a609     [2]             LDA   #9
  0030 ac000000 [8]             CALL  FLib_MemCpy
  0034 a702     [2]             AIS   #2
 1075:        /* Data was available in the serial terminal interface receive buffer. Now create an
 1076:           MCPS-Data Request message containing the serial terminal interface data. */
 1077:        mpGenericPkg->msgType = gMcpsDataReq_c;
  0036 320000   [5]             LDHX  mpGenericPkg
  0039 7f       [4]             CLR   ,X
 1078:        /* Create the header using coordinator information gained during 
 1079:           the scan procedure. Also use the short address we were assigned
 1080:           by the coordinator during association. */
 1081:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.dstAddr, dstDevice.ShortAddress, 2);
  003a af01     [2]             AIX   #1
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f af05     [2]             AIX   #5
  0041 a602     [2]             LDA   #2
  0043 ac000000 [8]             CALL  FLib_MemCpy
  0047 a702     [2]             AIS   #2
 1082:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  0049 320000   [5]             LDHX  mpGenericPkg
  004c af0c     [2]             AIX   #12
  004e 89       [2]             PSHX  
  004f 8b       [2]             PSHH  
  0050 450000   [3]             LDHX  @maShortAddress
  0053 a602     [2]             LDA   #2
  0055 ac000000 [8]             CALL  FLib_MemCpy
  0059 a702     [2]             AIS   #2
 1083:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  005b 320000   [5]             LDHX  mpGenericPkg
  005e af09     [2]             AIX   #9
  0060 ac000098 [8]             CALL  genericDataTransfer:152
 1084:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  0064 320000   [5]             LDHX  mpGenericPkg
  0067 af14     [2]             AIX   #20
  0069 ac000098 [8]             CALL  genericDataTransfer:152
 1085:        mpGenericPkg->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  006d a602     [2]             LDA   #2
  006f 320000   [5]             LDHX  mpGenericPkg
  0072 e70b     [3]             STA   11,X
 1086:        mpGenericPkg->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  0074 e716     [3]             STA   22,X
 1087:        mpGenericPkg->msgData.dataReq.msduLength = lengthPDU;
  0076 9ee610   [4]             LDA   16,SP
  0079 e717     [3]             STA   23,X
 1088:  
 1089:        /* Transfer Options in case of FFD / RFD */
 1090:        //if(dstDevice.DeviceType)
 1091:          /* Request MAC level acknowledgement of the data packet */
 1092:        //  mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c;         /* Direct Transfer for FFD Device */
 1093:       // else
 1094:          /* Request MAC level acknowledgement of the data packet and transmit Indirectly */
 1095:          mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c;     /* Indirect Transfer for RFD device */
  007b a605     [2]             LDA   #5
  007d e719     [3]             STA   25,X
 1096:  
 1097:        /* Give the data packet a handle. The handle is
 1098:           returned in the MCPS-Data Confirm message. */
 1099:        mpGenericPkg->msgData.dataReq.msduHandle = mMsduHandle++;
  007f c60000   [4]             LDA   mMsduHandle
  0082 e718     [3]             STA   24,X
  0084 4c       [1]             INCA  
  0085 c70000   [4]             STA   mMsduHandle
 1100:    #ifdef gMAC2006_d
 1101:          mpGenericPkg->msgData.dataReq.securityLevel = 0;
  0088 6f1a     [5]             CLR   26,X
 1102:    #endif //gMAC2006_d      
 1103:        
 1104:        /* Send the Data Request to the MCPS */
 1105:        (void)MSG_Send(NWK_MCPS, mpGenericPkg);
  008a ac000000 [8]             CALL  NWK_MCPS_SapHandler
 1106:        mcPendingPackets++;
  008e 450000   [3]             LDHX  @mcPendingPackets
  0091 7c       [4]             INC   ,X
 1107:        /* Prepare for another data buffer */
 1108:        mpGenericPkg = NULL;
  0092 5f       [1]             CLRX  
  0093 8c       [1]             CLRH  
  0094 960000   [5]             STHX  mpGenericPkg
  0097          L97:    
 1109:    }
 1110:  }
  0097 8d       [7]             RTC   
  0098          L98:    
  0098 89       [2]             PSHX  
  0099 8b       [2]             PSHH  
  009a 450000   [3]             LDHX  @maPanId
  009d a602     [2]             LDA   #2
  009f ac000000 [8]             CALL  FLib_MemCpy
  00a3 a702     [2]             AIS   #2
  00a5 8d       [7]             RTC   
 1111:  
 1112:  /* NEWCODE: Added function to send package over the air with the active button number */
 1113:  
