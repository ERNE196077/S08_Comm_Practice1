ANSI-C/cC++ Compiler for HC08 V-5.0.45 Build 14019, Jan 20 2014

    1:  /*****************************************************************************
    2:  *  MyWirelessApp Demo Non Beacon Coordinator application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  
   17:  /************************************************************************************
   18:  *************************************************************************************
   19:  * Private macros
   20:  *************************************************************************************
   21:  ************************************************************************************/
   22:  
   23:  /* If there are too many pending packets to be send over the air, */
   24:  /* receive mMaxKeysToReceive_c chars. */
   25:  /* The chars will be send over the air when there are no pending packets*/
   26:  #define mMaxKeysToReceive_c 32
   27:  
   28:  /************************************************************************************
   29:  *************************************************************************************
   30:  * Private prototypes
   31:  *************************************************************************************
   32:  ************************************************************************************/
   33:  
   34:  /* Forward declarations of helper functions */
   35:  static void    App_CommRxCallBack(void);
   36:  static uint8_t App_StartScan(uint8_t scanType);
   37:  static void    App_HandleScanEdConfirm(nwkMessage_t *pMsg);
   38:  static uint8_t App_StartCoordinator(void);
   39:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   40:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn);
   41:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   42:  static void    App_TransmitCommData(void);
   43:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   44:  #if (gMC1323xMatrixKBD_d == TRUE)
   45:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   46:  #else
   47:  static void    App_HandleKeys(key_event_t events);
   48:  #endif //gMC1323xMatrixKBD_d
   49:  
   50:  
   51:  /************************************************************************************
   52:  *************************************************************************************
   53:  * Private type definitions
   54:  *************************************************************************************
   55:  ************************************************************************************/
   56:  
   57:  
   58:  /************************************************************************************
   59:  *************************************************************************************
   60:  * Private memory declarations
   61:  *************************************************************************************
   62:  ************************************************************************************/
   63:  
   64:  /* The short address and PAN ID of the coordinator*/
   65:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
   66:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   67:  
   68:  
   69:  /* The current logical channel (frequency band) */
   70:  static uint8_t mLogicalChannel;
   71:  
   72:  /* Data request packet for sending serial input to the coordinator */
   73:  static nwkToMcpsMessage_t *mpPacket;
   74:  
   75:  /* The MSDU handle is a unique data packet identifier */
   76:  static uint8_t mMsduHandle;
   77:  
   78:  
   79:  static uint8_t maDeviceShortAddress[2];
   80:  
   81:  /* Number of pending data packets */
   82:  static uint8_t mcPendingPackets;
   83:  
   84:  /* Application input queues */
   85:  static anchor_t mMlmeNwkInputQueue;
   86:  static anchor_t mMcpsNwkInputQueue;
   87:  
   88:  static EndDevListItem_t AssociatedDevices[5];
   89:  static uint16_t AssocDevCounter;
   90:  
   91:  
   92:  /************************************************************************************
   93:  *************************************************************************************
   94:  * Public memory declarations
   95:  *************************************************************************************
   96:  ************************************************************************************/
   97:  
   98:  /* The current state of the applications state machine */
   99:  uint8_t gState;
  100:  
  101:  /* This data set contains application variables to be preserved across resets */
  102:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  103:    {NULL, 0}       /* Required end-of-table marker. */
  104:  };
  105:  
  106:  /************************************************************************************
  107:  *************************************************************************************
  108:  * Public functions
  109:  *************************************************************************************
  110:  ************************************************************************************/
  111:  
  112:  void DeepSleepWakeupStackProc(void);
  113:  
  114:  /*****************************************************************************
  115:  * Initialization function for the App Task. This is called during
  116:  * initialization and should contain any application specific initialization
  117:  * (ie. hardware initialization/setup, table initialization, power up
  118:  * notificaiton.
  119:  *
  120:  * Interface assumptions: None
  121:  *
  122:  * Return value: None
  123:  *
  124:  *****************************************************************************/
  125:  
  126:  void MApp_init(void)
  127:  { 
  128:    
  129:    /* The initial application state */
  130:    gState = stateInit;
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  131:    /* Reset number of pending packets */
  132:    mcPendingPackets = 0;   
  0004 c70000   [4]             STA   mcPendingPackets
  133:    /* Number of devices associated - Max 5 */
  134:    AssocDevCounter = 0; 
  0007 8c       [1]             CLRH  
  0008 5f       [1]             CLRX  
  0009 960000   [5]             STHX  AssocDevCounter
  135:  
  136:    /* Initialize the MAC 802.15.4 extended address */
  137:    Init_MacExtendedAddress();
  000c ac000000 [8]             CALL  Init_MacExtendedAddress
  138:    /* register keyboard callback function */
  139:    KBD_Init(App_HandleKeys);
  0010 450000   [3]             LDHX  @App_HandleKeys
  0013 89       [2]             PSHX  
  0014 8b       [2]             PSHH  
  0015 a600     [2]             LDA   @App_HandleKeys:PAGE
  0017 87       [2]             PSHA  
  0018 ac000000 [8]             CALL  KBD_Init
  001c a703     [2]             AIS   #3
  140:    /* Initialize SPI Module */
  141:    SPI_Init();
  001e ac000000 [8]             CALL  SPI1_Init
  142:    /* initialize LCD Module */
  143:    LCD_Init();
  144:    /* initialize LED Module */
  145:    LED_Init();
  0022 ac000000 [8]             CALL  LED_Init
  146:    /* Initialize the LPM module */
  147:    PWRLib_Init();
  0026 ac000000 [8]             CALL  PWRLib_Init
  148:    /* Initialize the serial terminal interface so that we can print out status messages */
  149:    Comm_SetBaud(gUartDefaultBaud_c);
  002a ae08     [2]             LDX   #8
  002c 8c       [1]             CLRH  
  002d ac000000 [8]             CALL  Uart1_SetBaud
  150:    Comm_SetRxCallBack(App_CommRxCallBack);
  0031 450000   [3]             LDHX  @App_CommRxCallBack
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 a600     [2]             LDA   @App_CommRxCallBack:PAGE
  0038 87       [2]             PSHA  
  0039 ac000000 [8]             CALL  Uart1_SetRxCallBack
  003d a703     [2]             AIS   #3
  151:    
  152:    /* initialize buzzer (NCB, SRB only) */  
  153:    BuzzerInit();  
  154:    /* Prepare input queues.*/
  155:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  003f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0042 ac000000 [8]             CALL  List_ClearAnchor
  156:    MSG_InitQueue(&mMcpsNwkInputQueue);
  0046 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  157:    /* Enable MCU interrupts */
  158:    IrqControlLib_EnableAllIrqs();
  004d 9a       [1]             CLI   
  159:    /*signal app ready*/  
  160:    Led1Flashing();
  004e a601     [2]             LDA   #1
  0050 ac000000 [8]             CALL  LED_StartFlash
  161:    Led2Flashing();
  0054 a602     [2]             LDA   #2
  0056 ac000000 [8]             CALL  LED_StartFlash
  162:    Led3Flashing();
  005a a604     [2]             LDA   #4
  005c ac000000 [8]             CALL  LED_StartFlash
  163:    Led4Flashing();
  0060 a608     [2]             LDA   #8
  0062 ac000000 [8]             CALL  LED_StartFlash
  164:      
  165:    CommUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  0066 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0069 a601     [2]             LDA   #1
  006b ac000000 [8]             CALL  CommUtil_Print
  166:    LCD_ClearDisplay();
  167:    LCD_WriteString(1,"Press any key");
  168:    LCD_WriteString(2,"to start.");
  169:  }
  006f 8d       [7]             RTC   
  170:  
  171:  /*****************************************************************************
  172:  *Mac Application Task event processor.  This function is called to
  173:  * process all events for the task. Events include timers, messages and any
  174:  * other user defined events
  175:  *
  176:  * Interface assumptions: None
  177:  *
  178:  * Return value: None
  179:  *****************************************************************************/
  180:  /* The Application Task */
  181:  void AppTask(event_t events)
  182:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  183:    /* Pointer for storing the messages from MLME */
  184:    void *pMsgIn;
  185:    /* Stores the error/success code returned by some functions. */
  186:    uint8_t ret;  
  187:    pMsgIn = NULL;
  0004 9e6f02   [6]             CLR   2,SP
  0007 9e6f01   [6]             CLR   1,SP
  188:    
  189:    /* Dequeue the MLME message */
  190:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  191:    {
  192:      /* Get the message from MLME */
  193:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff01   [5]             STHX  1,SP
  194:      
  195:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  196:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  197:      {               
  198:        ret = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  199:        if(ret == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  200:        {
  201:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  202:          /* ALSO the application can use the beacon payload.*/
  203:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe01   [5]             LDHX  1,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  204:          CommUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac000170 [8]             CALL  AppTask:368
  0035          L35:    
  205:        }
  206:      }
  207:    }
  208:    /* The application state machine */
  209:    switch(gState)
  0035 ce0000   [4]             LDX   gState
  0038 a305     [2]             CPX   #5
  003a 2225     [3]             BHI   L61 ;abs = 0061
  003c 4f       [1]             CLRA  
  003d cd0000   [6]             JSR   _Jump_Table_Header_Offset
  0040 06               DC.B  6
  0041 e2               DC.B  L124
  0042 05               DC.B  L48
  0043 10               DC.B  L54
  0044 22               DC.B  L67
  0045 49               DC.B  L8F
  0046 79               DC.B  LC0
  0047 c1               DC.B  L109
  0048          L48:    
  210:    {
  211:    case stateInit:    
  212:      /* Print a welcome message to the serial terminal interface */
  213:      CommUtil_Print("\n\rMyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  0048 450000   [3]             LDHX  @"\012\015MyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\012\015\012\015"
  004b ac000170 [8]             CALL  AppTask:368
  214:      /* Goto Energy Detection state. */
  215:      gState = stateScanEdStart;
  004f a601     [2]             LDA   #1
  216:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  217:      break;
  0051 cc00fa   [4]             JMP   LFA ;abs = 00fa
  0054          L54:    
  218:      
  219:    case stateScanEdStart:
  220:      /* Start the Energy Detection scan, and goto wait for confirm state. */
  221:      CommUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
  0054 450000   [3]             LDHX  @"Initiating the Energy Detection Scan\012\015"
  0057 ac000170 [8]             CALL  AppTask:368
  222:      /*Print the message on the LCD also*/
  223:      LCD_ClearDisplay();
  224:      LCD_WriteString(1,"Starting Energy");
  225:      LCD_WriteString(2,"Detection Scan");  
  226:      ret = App_StartScan(gScanModeED_c);
  005b 4f       [1]             CLRA  
  005c ac000000 [8]             CALL  App_StartScan
  227:      if(ret == errorNoError)
  0060 4d       [1]             TSTA  
  0061          L61:    
  0061 265b     [3]             BNE   LBE ;abs = 00be
  228:      {
  229:        gState = stateScanEdWaitConfirm;
  0063 a602     [2]             LDA   #2
  0065 2054     [3]             BRA   LBB ;abs = 00bb
  0067          L67:    
  230:      }
  231:      break;
  232:      
  233:    case stateScanEdWaitConfirm:
  234:      /* Stay in this state until the MLME Scan confirm message arrives,
  235:         and has been processed. Then goto Start Coordinator state. */
  236:      if (events & gAppEvtMessageFromMLME_c)
  0067 95       [2]             TSX   
  0068 e603     [3]             LDA   3,X
  006a a504     [2]             BIT   #4
  006c 2750     [3]             BEQ   LBE ;abs = 00be
  237:      {
  238:        if (pMsgIn)
  006e 9efe01   [5]             LDHX  1,SP
  0071 274b     [3]             BEQ   LBE ;abs = 00be
  239:        {
  240:          ret = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  0073 a60b     [2]             LDA   #11
  0075 ac000000 [8]             CALL  App_WaitMsg
  241:          if(ret == errorNoError)
  0079 4d       [1]             TSTA  
  007a 2642     [3]             BNE   LBE ;abs = 00be
  242:          {
  243:            /* Process the ED scan confirm. The logical
  244:               channel is selected by this function. */
  245:            App_HandleScanEdConfirm(pMsgIn);
  007c 9efe01   [5]             LDHX  1,SP
  007f ac000000 [8]             CALL  App_HandleScanEdConfirm
  246:            /* Go to the Start Coordinator state */
  247:            gState = stateStartCoordinator;
  0083 a603     [2]             LDA   #3
  0085 c70000   [4]             STA   gState
  248:            TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
  0088 c60000   [4]             LDA   gAppTaskID_c
  008b ae10     [2]             LDX   #16
  008d 2073     [3]             BRA   L102 ;abs = 0102
  008f          L8F:    
  249:          }
  250:        }      
  251:      }        
  252:      break;
  253:      
  254:  
  255:    case stateStartCoordinator:
  256:      if (events & gAppEvtStartCoordinator_c)
  008f 95       [2]             TSX   
  0090 e603     [3]             LDA   3,X
  0092 a510     [2]             BIT   #16
  0094 2728     [3]             BEQ   LBE ;abs = 00be
  257:      {
  258:        /* Start up as a PAN Coordinator on the selected channel. */
  259:        CommUtil_Print("\n\rStarting as PAN coordinator on channel 0x", gAllowToBlock_d);
  0096 450000   [3]             LDHX  @"\012\015Starting as PAN coordinator on channel 0x"
  0099 ac000170 [8]             CALL  AppTask:368
  260:        CommUtil_PrintHex(&mLogicalChannel, 1, FALSE);
  009d 450000   [3]             LDHX  @mLogicalChannel
  00a0 89       [2]             PSHX  
  00a1 8b       [2]             PSHH  
  00a2 ae01     [2]             LDX   #1
  00a4 4f       [1]             CLRA  
  00a5 ac000000 [8]             CALL  CommUtil_PrintHex
  00a9 a702     [2]             AIS   #2
  261:        CommUtil_Print("\n\r", gAllowToBlock_d);
  00ab 450000   [3]             LDHX  @"\012\015"
  00ae ac000170 [8]             CALL  AppTask:368
  262:        /*print a message on the LCD also*/
  263:        LCD_ClearDisplay();
  264:        LCD_WriteString(1,"Starting");
  265:        LCD_WriteString(2,"PAN coordinator");    
  266:      
  267:        ret = App_StartCoordinator();
  00b2 ac000000 [8]             CALL  App_StartCoordinator
  268:        if(ret == errorNoError)
  00b6 4d       [1]             TSTA  
  00b7 266b     [3]             BNE   L124 ;abs = 0124
  269:        {
  270:          /* If the Start request was sent successfully to
  271:             the MLME, then goto Wait for confirm state. */
  272:          gState = stateStartCoordinatorWaitConfirm;
  00b9 a604     [2]             LDA   #4
  00bb          LBB:    
  00bb c70000   [4]             STA   gState
  00be          LBE:    
  00be 2064     [3]             BRA   L124 ;abs = 0124
  00c0          LC0:    
  273:        }
  274:      }
  275:      break; 
  276:  
  277:    case stateStartCoordinatorWaitConfirm:
  278:      /* Stay in this state until the Start confirm message
  279:             arrives, and then goto the Listen state. */
  280:      if (events & gAppEvtMessageFromMLME_c)
  00c0 95       [2]             TSX   
  00c1 e603     [3]             LDA   3,X
  00c3 a504     [2]             BIT   #4
  00c5 275d     [3]             BEQ   L124 ;abs = 0124
  281:      {
  282:        if (pMsgIn)
  00c7 9efe01   [5]             LDHX  1,SP
  00ca 2758     [3]             BEQ   L124 ;abs = 0124
  283:        {        
  284:          ret = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
  00cc a60e     [2]             LDA   #14
  00ce ac000000 [8]             CALL  App_WaitMsg
  285:          if(ret == errorNoError)
  00d2 4d       [1]             TSTA  
  00d3 264f     [3]             BNE   L124 ;abs = 0124
  286:          {
  287:            CommUtil_Print("Started the coordinator with PAN ID 0x", gAllowToBlock_d);
  00d5 450000   [3]             LDHX  @"Started the coordinator with PAN ID 0x"
  00d8 ac000170 [8]             CALL  AppTask:368
  288:            CommUtil_PrintHex((uint8_t *)maPanId, 2, 0);
  00dc 450000   [3]             LDHX  @maPanId
  00df ac000177 [8]             CALL  AppTask:375
  289:            CommUtil_Print(", and short address 0x", gAllowToBlock_d);
  00e3 450000   [3]             LDHX  @", and short address 0x"
  00e6 ac000170 [8]             CALL  AppTask:368
  290:            CommUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
  00ea 450000   [3]             LDHX  @maShortAddress
  00ed ac000177 [8]             CALL  AppTask:375
  291:            CommUtil_Print(".\n\r\n\rReady to send and receive data over the serial terminal interface.\n\r\n\r", gAllowToBlock_d);
  00f1 450000   [3]             LDHX  @".\012\015\012\015Ready to send and receive data over the serial terminal interface.\012\015\012\015"
  00f4 ac000170 [8]             CALL  AppTask:368
  292:            /*print a message on the LCD also*/
  293:            LCD_ClearDisplay();
  294:            LCD_WriteString(1,"Ready to send");
  295:            LCD_WriteString(2,"and receive data");    
  296:            gState = stateListen;
  00f8 a605     [2]             LDA   #5
  00fa          LFA:    
  00fa c70000   [4]             STA   gState
  297:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  00fd c60000   [4]             LDA   gAppTaskID_c
  0100 ae01     [2]             LDX   #1
  0102          L102:   
  0102 8c       [1]             CLRH  
  0103 ac000000 [8]             CALL  TS_SendEvent
  0107 201b     [3]             BRA   L124 ;abs = 0124
  0109          L109:   
  298:          }
  299:        }
  300:      }
  301:      break; 
  302:      
  303:    case stateListen:
  304:      /* Stay in this state forever. 
  305:         Transmit the data received on serial terminal interface */
  306:      if (events & gAppEvtMessageFromMLME_c)
  0109 95       [2]             TSX   
  010a e603     [3]             LDA   3,X
  010c a504     [2]             BIT   #4
  010e 2709     [3]             BEQ   L119 ;abs = 0119
  307:      {
  308:        /* Get the message from MLME */
  309:        if (pMsgIn)
  0110 9efe01   [5]             LDHX  1,SP
  0113 2704     [3]             BEQ   L119 ;abs = 0119
  310:        {      
  311:          /* Process it */
  312:          ret = App_HandleMlmeInput(pMsgIn);
  0115 ac000000 [8]             CALL  App_HandleMlmeInput
  0119          L119:   
  313:          /* Messages from the MLME must always be freed. */
  314:        }
  315:      }
  316:  
  317:      if (events & gAppEvtRxFromComm_c)
  0119 95       [2]             TSX   
  011a e603     [3]             LDA   3,X
  011c a502     [2]             BIT   #2
  011e 2704     [3]             BEQ   L124 ;abs = 0124
  318:      {      
  319:        /* get byte from serial terminal interface */
  320:        App_TransmitCommData();
  0120 ac000000 [8]             CALL  App_TransmitCommData
  0124          L124:   
  321:      
  322:      }  
  323:      break;
  324:    }
  325:    
  326:    if (pMsgIn)
  0124 9efe01   [5]             LDHX  1,SP
  0127 2704     [3]             BEQ   L12D ;abs = 012d
  327:    {
  328:      /* Messages must always be freed. */ 
  329:      MSG_Free(pMsgIn);
  0129 ac000000 [8]             CALL  MM_Free
  012d          L12D:   
  330:    }
  331:    
  332:    if (events & gAppEvtMessageFromMCPS_c)
  012d 95       [2]             TSX   
  012e e603     [3]             LDA   3,X
  0130 a508     [2]             BIT   #8
  0132 271b     [3]             BEQ   L14F ;abs = 014f
  333:    {      
  334:       /* Get the message from MCPS */
  335:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  0134 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0137 ac000000 [8]             CALL  List_RemoveHead
  336:      if (pMsgIn)
  013b 650000   [3]             CPHX  #0
  013e 270f     [3]             BEQ   L14F ;abs = 014f
  337:      {
  338:        /* Process it */
  339:        App_HandleMcpsInput(pMsgIn);
  0140 89       [2]             PSHX  
  0141 8b       [2]             PSHH  
  0142 ac000000 [8]             CALL  App_HandleMcpsInput
  340:        /* Messages from the MCPS must always be freed. */
  341:        MSG_Free(pMsgIn);
  0146 9efe01   [5]             LDHX  1,SP
  0149 ac000000 [8]             CALL  MM_Free
  014d a702     [2]             AIS   #2
  014f          L14F:   
  342:      }
  343:    }  
  344:    
  345:    
  346:    /* Check for pending messages in the Queue */ 
  347:    if(MSG_Pending(&mMcpsNwkInputQueue))
  014f 320000   [5]             LDHX  mMcpsNwkInputQueue
  0152 270a     [3]             BEQ   L15E ;abs = 015e
  348:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0154 c60000   [4]             LDA   gAppTaskID_c
  0157 ae08     [2]             LDX   #8
  0159 8c       [1]             CLRH  
  015a ac000000 [8]             CALL  TS_SendEvent
  015e          L15E:   
  349:    if(MSG_Pending(&mMlmeNwkInputQueue))
  015e 320000   [5]             LDHX  mMlmeNwkInputQueue
  0161 270a     [3]             BEQ   L16D ;abs = 016d
  350:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0163 c60000   [4]             LDA   gAppTaskID_c
  0166 ae04     [2]             LDX   #4
  0168 8c       [1]             CLRH  
  0169 ac000000 [8]             CALL  TS_SendEvent
  016d          L16D:   
  351:  }
  016d a704     [2]             AIS   #4
  016f 8d       [7]             RTC   
  0170          L170:   
  0170 a601     [2]             LDA   #1
  0172 ac000000 [8]             CALL  CommUtil_Print
  0176 8d       [7]             RTC   
  0177          L177:   
  0177 89       [2]             PSHX  
  0178 8b       [2]             PSHH  
  0179 ae02     [2]             LDX   #2
  017b 4f       [1]             CLRA  
  017c ac000000 [8]             CALL  CommUtil_PrintHex
  0180 a702     [2]             AIS   #2
  0182 8d       [7]             RTC   
  352:  
  353:  
  354:  
  355:  /************************************************************************************
  356:  *************************************************************************************
  357:  * Private functions
  358:  *************************************************************************************
  359:  ************************************************************************************/
  360:  
  361:  /*****************************************************************************
  362:  * App_CommRxCallBack
  363:  *
  364:  * This callback is triggered when a new byte is received over the Serial Interface
  365:  *
  366:  *****************************************************************************/
  367:  static void App_CommRxCallBack(void) 
  368:  {
  0000 8b       [2]             PSHH  
  369:    uint8_t pressedKey;
  370:  	if(stateListen == gState){
  0001 c60000   [4]             LDA   gState
  0004 a105     [2]             CMP   #5
  0006 260c     [3]             BNE   L14 ;abs = 0014
  371:      TS_SendEvent(gAppTaskID_c, gAppEvtRxFromComm_c);
  0008 c60000   [4]             LDA   gAppTaskID_c
  000b ae02     [2]             LDX   #2
  000d 8c       [1]             CLRH  
  000e ac000000 [8]             CALL  TS_SendEvent
  372:    }else{
  373:  	  (void)Comm_GetByteFromRxBuffer(&pressedKey);
  374:    }
  375:  }
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 95       [2]             TSX   
  0015 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0019 8a       [3]             PULH  
  001a 8d       [7]             RTC   
  376:  
  377:  /******************************************************************************
  378:  * The App_StartScan(scanType) function will start the scan process of the
  379:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  380:  * which is then assigned the desired scan parameters and sent to the MLME
  381:  * service access point.
  382:  * The function may return either of the following values:
  383:  *   errorNoError:          The Scan message was sent successfully.
  384:  *   errorInvalidParameter: The MLME service access point rejected the
  385:  *                          message due to an invalid parameter.
  386:  *   errorAllocFailed:      A message buffer could not be allocated.
  387:  *
  388:  ******************************************************************************/
  389:  static uint8_t App_StartScan(uint8_t scanType)
  390:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  391:    mlmeMessage_t *pMsg;
  392:    mlmeScanReq_t *pScanReq;
  393:  
  394:    CommUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000058 [8]             CALL  App_StartScan:88
  395:  
  396:    /* Allocate a message for the MLME (We should check for NULL). */
  397:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a623     [2]             LDA   #35
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  398:    if(pMsg != NULL)
  0013 2737     [3]             BEQ   L4C ;abs = 004c
  399:    {
  400:      /* This is a MLME-SCAN.req command */
  401:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  402:      /* Create the Scan request message data. */
  403:      pScanReq = &pMsg->msgData.scanReq;
  404:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  405:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  406:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  407:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  408:      /* ChannelsToScan>>8 & 0xFF  */
  409:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f 6f03     [5]             CLR   3,X
  410:      /* ChannelsToScan>>16 & 0xFF  */
  411:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0021 6f04     [5]             CLR   4,X
  412:      /* ChannelsToScan>>24 & 0xFF - MSB */
  413:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0023 a601     [2]             LDA   #1
  0025 e705     [3]             STA   5,X
  414:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  415:         A scan duration of 3 on 16 channels approximately takes 2 secs. */
  416:      pScanReq->scanDuration = 3;
  0027 a603     [2]             LDA   #3
  0029 e706     [3]             STA   6,X
  417:  #ifdef gMAC2006_d
  418:      pScanReq->securityLevel = 0;
  002b 6f07     [5]             CLR   7,X
  419:  #endif //gMAC2006_d    
  420:      
  421:      /* Send the Scan request to the MLME. */
  422:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002d 9efe01   [5]             LDHX  1,SP
  0030 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0034 4d       [1]             TSTA  
  0035 260a     [3]             BNE   L41 ;abs = 0041
  423:      {
  424:        CommUtil_Print("Done\n\r", gAllowToBlock_d);
  0037 450000   [3]             LDHX  @"Done\012\015"
  003a ac000058 [8]             CALL  App_StartScan:88
  425:        return errorNoError;
  003e 4f       [1]             CLRA  
  003f 2014     [3]             BRA   L55 ;abs = 0055
  0041          L41:    
  426:      }
  427:      else
  428:      {
  429:        CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0041 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0044 ac000058 [8]             CALL  App_StartScan:88
  430:        return errorInvalidParameter;
  0048 a605     [2]             LDA   #5
  004a 2009     [3]             BRA   L55 ;abs = 0055
  004c          L4C:    
  431:      }
  432:    }
  433:    else
  434:    {
  435:      /* Allocation of a message buffer failed. */
  436:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  004c 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004f ac000058 [8]             CALL  App_StartScan:88
  437:      return errorAllocFailed;
  0053 a604     [2]             LDA   #4
  0055          L55:    
  438:    }
  439:  }
  0055 a703     [2]             AIS   #3
  0057 8d       [7]             RTC   
  0058          L58:    
  0058 a601     [2]             LDA   #1
  005a ac000000 [8]             CALL  CommUtil_Print
  005e 8d       [7]             RTC   
  440:  
  441:  
  442:  /******************************************************************************
  443:  * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
  444:  * ED scan confirm message received from the MLME when the ED scan has completed.
  445:  * The message contains the ED scan result list. This function will search the
  446:  * list in order to select the logical channel with the least energy. The
  447:  * selected channel is stored in the global variable called 'mLogicalChannel'.
  448:  *
  449:  ******************************************************************************/
  450:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
  451:  {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
  452:    uint8_t n, minEnergy;
  453:    uint8_t *pEdList;
  454:    uint8_t ChannelMask;
  455:  
  456:    CommUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Received the MLME-Scan Confirm message from the MAC\012\015"
  0007 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  457:      
  458:    /* Get a pointer to the energy detect results */
  459:    pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
  000b 9efe06   [5]             LDHX  6,SP
  000e 9ece08   [5]             LDHX  8,X
  0011 9eff03   [5]             STHX  3,SP
  460:    
  461:    /* Set the minimum energy to a large value */
  462:    minEnergy = 0xFF;
  0014 a6ff     [2]             LDA   #-1
  0016 95       [2]             TSX   
  0017 e704     [3]             STA   4,X
  463:  
  464:    /* Select default channel */
  465:    mLogicalChannel = 11;
  0019 a60b     [2]             LDA   #11
  001b c70000   [4]             STA   mLogicalChannel
  466:   
  467:    /* Search for the channel with least energy */
  468:    for(n=0; n<16; n++)
  001e 6f01     [5]             CLR   1,X
  0020          L20:    
  469:    {
  470:      ChannelMask = n + 11;
  0020 95       [2]             TSX   
  0021 e601     [3]             LDA   1,X
  0023 ab0b     [2]             ADD   #11
  471:  	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
  0025 f7       [2]             STA   ,X
  0026 e601     [3]             LDA   1,X
  0028 eb03     [3]             ADD   3,X
  002a 87       [2]             PSHA  
  002b 4f       [1]             CLRA  
  002c e902     [3]             ADC   2,X
  002e 87       [2]             PSHA  
  002f e604     [3]             LDA   4,X
  0031 8a       [3]             PULH  
  0032 88       [3]             PULX  
  0033 f1       [3]             CMP   ,X
  0034 232e     [3]             BLS   L64 ;abs = 0064
  0036 4f       [1]             CLRA  
  0037 450100   [3]             LDHX  #256
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f e604     [3]             LDA   4,X
  0041 cd0000   [6]             JSR   _LLSR
  0044 9ee604   [4]             LDA   4,SP
  0047 a501     [2]             BIT   #1
  0049 a708     [2]             AIS   #8
  004b 2717     [3]             BEQ   L64 ;abs = 0064
  472:      {
  473:        minEnergy = pEdList[n];
  004d e605     [3]             LDA   5,X
  004f eb07     [3]             ADD   7,X
  0051 87       [2]             PSHA  
  0052 4f       [1]             CLRA  
  0053 e906     [3]             ADC   6,X
  0055 87       [2]             PSHA  
  0056 8a       [3]             PULH  
  0057 88       [3]             PULX  
  0058 fe       [3]             LDX   ,X
  0059 9eef05   [4]             STX   5,SP
  474:        /* Channel numbering is 11 to 26 both inclusive */
  475:        mLogicalChannel = n + 11; 
  005c 95       [2]             TSX   
  005d e601     [3]             LDA   1,X
  005f ab0b     [2]             ADD   #11
  0061 c70000   [4]             STA   mLogicalChannel
  0064          L64:    
  0064 95       [2]             TSX   
  0065 6c01     [5]             INC   1,X
  0067 e601     [3]             LDA   1,X
  0069 a110     [2]             CMP   #16
  006b 25b3     [3]             BCS   L20 ;abs = 0020
  476:      }
  477:    }
  478:    
  479:    /* Print out the result of the ED scan */
  480:    CommUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
  006d 450000   [3]             LDHX  @"ED scan returned the following results:\012\015  ["
  0070 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  481:    CommUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
  0074 9efe03   [5]             LDHX  3,SP
  0077 89       [2]             PSHX  
  0078 8b       [2]             PSHH  
  0079 ae10     [2]             LDX   #16
  007b a609     [2]             LDA   #9
  007d ac000000 [8]             CALL  CommUtil_PrintHex
  0081 a702     [2]             AIS   #2
  482:    CommUtil_Print("]\n\r\n\r", gAllowToBlock_d);
  0083 450000   [3]             LDHX  @"]\012\015\012\015"
  0086 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  483:    
  484:    /* Print out the selected logical channel */
  485:    CommUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
  008a 450000   [3]             LDHX  @"Based on the ED scan the logical channel 0x"
  008d ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  486:    CommUtil_PrintHex(&mLogicalChannel, 1, 0);
  0091 450000   [3]             LDHX  @mLogicalChannel
  0094 89       [2]             PSHX  
  0095 8b       [2]             PSHH  
  0096 ae01     [2]             LDX   #1
  0098 4f       [1]             CLRA  
  0099 ac000000 [8]             CALL  CommUtil_PrintHex
  009d a702     [2]             AIS   #2
  487:    CommUtil_Print(" was selected\n\r", gAllowToBlock_d);
  009f 450000   [3]             LDHX  @" was selected\012\015"
  00a2 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  488:    
  489:    /* The list of detected energies must be freed. */
  490:    MSG_Free(pEdList);
  00a6 9efe03   [5]             LDHX  3,SP
  00a9 ac000000 [8]             CALL  MM_Free
  491:  }
  00ad a707     [2]             AIS   #7
  00af 8d       [7]             RTC   
  00b0          LB0:    
  00b0 a601     [2]             LDA   #1
  00b2 ac000000 [8]             CALL  CommUtil_Print
  00b6 8d       [7]             RTC   
  492:  
  493:  /******************************************************************************
  494:  * The App_StartScan(scanType) function will start the scan process of the
  495:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  496:  * which is then assigned the desired scan parameters and sent to the MLME
  497:  * service access point. The MAC PIB attributes "macShortAddress", and 
  498:  * "macAssociatePermit" are modified.
  499:  *
  500:  * The function may return either of the following values:
  501:  *   errorNoError:          The Scan message was sent successfully.
  502:  *   errorInvalidParameter: The MLME service access point rejected the
  503:  *                          message due to an invalid parameter.
  504:  *   errorAllocFailed:      A message buffer could not be allocated.
  505:  *
  506:  ******************************************************************************/
  507:  static uint8_t App_StartCoordinator(void)
  508:  {
  0000 a7fb     [2]             AIS   #-5
  509:    /* Message for the MLME will be allocated and attached to this pointer */
  510:    mlmeMessage_t *pMsg;
  511:  
  512:    CommUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Start Request message to the MAC..."
  0005 ac0000af [8]             CALL  App_StartCoordinator:175
  513:    
  514:    /* Allocate a message for the MLME (We should check for NULL). */
  515:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a623     [2]             LDA   #35
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff01   [5]             STHX  1,SP
  516:    if(pMsg != NULL)
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00a3   [4]             JMP   LA3 ;abs = 00a3
  0017          L17:    
  517:    {
  518:      /* Pointer which is used for easy access inside the allocated message */
  519:      mlmeStartReq_t *pStartReq;
  520:      /* Return value from MSG_send - used for avoiding compiler warnings */
  521:      uint8_t ret;
  522:      /* Boolean value that will be written to the MAC PIB */
  523:      uint8_t boolFlag;
  524:      
  525:      /* Set-up MAC PIB attributes. Please note that Set, Get,
  526:         and Reset messages are not freed by the MLME. */
  527:      
  528:      /* We must always set the short address to something
  529:         else than 0xFFFF before starting a PAN. */
  530:      pMsg->msgType = gMlmeSetReq_c;
  0017 a609     [2]             LDA   #9
  0019 f7       [2]             STA   ,X
  531:      pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
  001a a653     [2]             LDA   #83
  001c e701     [3]             STA   1,X
  532:      pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
  001e a600     [2]             LDA   @maShortAddress:MSB
  0020 e703     [3]             STA   3,X
  0022 a600     [2]             LDA   @maShortAddress
  0024 e704     [3]             STA   4,X
  533:      ret = MSG_Send(NWK_MLME, pMsg);
  0026 89       [2]             PSHX  
  0027 8b       [2]             PSHH  
  0028 ac000000 [8]             CALL  NWK_MLME_SapHandler
  534:      
  535:      /* We must set the Association Permit flag to TRUE 
  536:         in order to allow devices to associate to us. */
  537:      pMsg->msgType = gMlmeSetReq_c;
  002c 9efe01   [5]             LDHX  1,SP
  002f a609     [2]             LDA   #9
  0031 f7       [2]             STA   ,X
  538:      pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
  0032 a641     [2]             LDA   #65
  0034 e701     [3]             STA   1,X
  539:      boolFlag = TRUE;
  0036 a601     [2]             LDA   #1
  0038 95       [2]             TSX   
  0039 e704     [3]             STA   4,X
  540:      pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
  003b af04     [2]             AIX   #4
  003d 8b       [2]             PSHH  
  003e 9ee602   [4]             LDA   2,SP
  0041 87       [2]             PSHA  
  0042 8a       [3]             PULH  
  0043 9f       [1]             TXA   
  0044 9eee03   [4]             LDX   3,SP
  0047 e704     [3]             STA   4,X
  0049 86       [3]             PULA  
  004a e703     [3]             STA   3,X
  541:      ret = MSG_Send(NWK_MLME, pMsg);
  004c ac000000 [8]             CALL  NWK_MLME_SapHandler
  542:      
  543:      /* This is a MLME-START.req command */
  544:      pMsg->msgType = gMlmeStartReq_c;
  0050 9efe03   [5]             LDHX  3,SP
  0053 a60a     [2]             LDA   #10
  0055 f7       [2]             STA   ,X
  545:      
  546:      /* Create the Start request message data. */
  547:      pStartReq = &pMsg->msgData.startReq;
  0056 af01     [2]             AIX   #1
  0058 9eff06   [5]             STHX  6,SP
  548:      /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
  549:      FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maPanId
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
  550:      /* Logical Channel - the default of 11 will be overridden */
  551:      pStartReq->logicalChannel = mLogicalChannel;
  0068 9efe06   [5]             LDHX  6,SP
  006b c60000   [4]             LDA   mLogicalChannel
  006e e702     [3]             STA   2,X
  552:      /* Beacon Order - 0xF = turn off beacons */
  553:      pStartReq->beaconOrder = 0x0F;  
  0070 a60f     [2]             LDA   #15
  0072 e707     [3]             STA   7,X
  554:      /* Superframe Order - 0xF = turn off beacons */
  555:      pStartReq->superFrameOrder = 0x0F;
  0074 e708     [3]             STA   8,X
  556:      /* Be a PAN coordinator */
  557:      pStartReq->panCoordinator = TRUE;
  0076 a601     [2]             LDA   #1
  0078 e709     [3]             STA   9,X
  558:      /* Dont use battery life extension */
  559:      pStartReq->batteryLifeExt = FALSE;
  007a 6f0a     [5]             CLR   10,X
  560:      /* This is not a Realignment command */
  561:      pStartReq->coordRealignment = FALSE;
  007c 6f0b     [5]             CLR   11,X
  562:      /* Dont use security */
  563:  #ifndef gMAC2006_d    
  564:      pStartReq->securityEnable = FALSE;
  565:  #else
  566:      pStartReq->coordRealignSecurityLevel = 0;
  007e 6f0c     [5]             CLR   12,X
  567:      pStartReq->beaconSecurityLevel = 0;
  0080 6f17     [5]             CLR   23,X
  568:  #endif //gMAC2006_d        
  569:        
  570:      /* Send the Start request to the MLME. */
  571:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a a702     [2]             AIS   #2
  008c 260a     [3]             BNE   L98 ;abs = 0098
  572:      {
  573:        CommUtil_Print("Done\n\r", gAllowToBlock_d);
  008e 450000   [3]             LDHX  @"Done\012\015"
  0091 ac0000af [8]             CALL  App_StartCoordinator:175
  574:        return errorNoError;
  0095 4f       [1]             CLRA  
  0096 2014     [3]             BRA   LAC ;abs = 00ac
  0098          L98:    
  575:      }
  576:      else
  577:      {
  578:        /* One or more parameters in the Start Request message were invalid. */
  579:        CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0098 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  009b ac0000af [8]             CALL  App_StartCoordinator:175
  580:        return errorInvalidParameter;
  009f a605     [2]             LDA   #5
  00a1 2009     [3]             BRA   LAC ;abs = 00ac
  00a3          LA3:    
  581:      }
  582:    }
  583:    else
  584:    {
  585:      /* Allocation of a message buffer failed. */
  586:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a3 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a6 ac0000af [8]             CALL  App_StartCoordinator:175
  587:      return errorAllocFailed;
  00aa a604     [2]             LDA   #4
  00ac          LAC:    
  588:    }
  589:  }
  00ac a705     [2]             AIS   #5
  00ae 8d       [7]             RTC   
  00af          LAF:    
  00af a601     [2]             LDA   #1
  00b1 ac000000 [8]             CALL  CommUtil_Print
  00b5 8d       [7]             RTC   
  590:  
  591:  /******************************************************************************
  592:  * The App_SendAssociateResponse(nwkMessage_t *pMsgIn) will create the response
  593:  * message to an Associate Indication (device sends an Associate Request to its
  594:  * MAC. The request is transmitted to the coordinator where it is converted into
  595:  * an Associate Indication). This function will extract the devices long address,
  596:  * and various other flags from the incoming indication message for building the
  597:  * response message.
  598:  *
  599:  * The function may return either of the following values:
  600:  *   errorNoError:          The Associate Response message was sent successfully.
  601:  *   errorInvalidParameter: The MLME service access point rejected the
  602:  *                          message due to an invalid parameter.
  603:  *   errorAllocFailed:      A message buffer could not be allocated.
  604:  *
  605:  ******************************************************************************/
  606:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn)
  607:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7f6     [2]             AIS   #-10
  608:    mlmeMessage_t *pMsg;
  609:    mlmeAssociateRes_t *pAssocRes;
  610:    uint16_t i;
  611:    uint8_t FoundFlag = 0;
  0004 95       [2]             TSX   
  0005 6f05     [5]             CLR   5,X
  612:   
  613:    CommUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0007 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  000a ac000201 [8]             CALL  App_SendAssociateResponse:513
  614:   
  615:    /* Allocate a message for the MLME */
  616:    pMsg = MSG_AllocType(mlmeMessage_t);
  000e a623     [2]             LDA   #35
  0010 ac000000 [8]             CALL  MM_Alloc
  0014 9eff07   [5]             STHX  7,SP
  617:    if(pMsg != NULL)
  0017 2603     [3]             BNE   L1C ;abs = 001c
  0019 cc01f5   [4]             JMP   L1F5 ;abs = 01f5
  001c          L1C:    
  618:    {
  619:      /* This is a MLME-ASSOCIATE.res command */
  620:      pMsg->msgType = gMlmeAssociateRes_c;
  001c a601     [2]             LDA   #1
  001e f7       [2]             STA   ,X
  621:      
  622:      /* Create the Associate response message data. */
  623:      pAssocRes = &pMsg->msgData.associateRes;
  001f af01     [2]             AIX   #1
  0021 9eff04   [5]             STHX  4,SP
  624:      
  625:      /* Assign a short address to the device. In this example we simply
  626:         choose 0x0001. Though, all devices and coordinators in a PAN must have
  627:         different short addresses. However, if a device do not want to use 
  628:         short addresses at all in the PAN, a short address of 0xFFFE must
  629:         be assigned to it. */
  630:  
  631:        /* Check if ED requester was already registered */
  632:  
  633:        for (i = 0; i < AssocDevCounter; ++i)
  0024 95       [2]             TSX   
  0025 6f02     [5]             CLR   2,X
  0027 6f01     [5]             CLR   1,X
  0029 2029     [3]             BRA   L54 ;abs = 0054
  002b          L2B:    
  634:        {
  635:          /* If ED was already registered associate the same address and set the flag */
  636:          if(FLib_MemCmp(AssociatedDevices[i].ExtendedAddress,pMsgIn->msgData.associateInd.deviceAddress,8)){
  002b 95       [2]             TSX   
  002c e602     [3]             LDA   2,X
  002e ae0c     [2]             LDX   #12
  0030 42       [5]             MUL   
  0031 ab02     [2]             ADD   @AssociatedDevices:2
  0033 87       [2]             PSHA  
  0034 4f       [1]             CLRA  
  0035 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0037 87       [2]             PSHA  
  0038 9efe0d   [5]             LDHX  13,SP
  003b af01     [2]             AIX   #1
  003d a608     [2]             LDA   #8
  003f ac000000 [8]             CALL  FLib_MemCmp
  0043 a702     [2]             AIS   #2
  0045 4d       [1]             TSTA  
  0046 2705     [3]             BEQ   L4D ;abs = 004d
  637:            FoundFlag++;
  0048 95       [2]             TSX   
  0049 6c05     [5]             INC   5,X
  638:            break;
  004b 200f     [3]             BRA   L5C ;abs = 005c
  004d          L4D:    
  004d 95       [2]             TSX   
  004e 6c02     [5]             INC   2,X
  0050 2602     [3]             BNE   L54 ;abs = 0054
  0052 6c01     [5]             INC   1,X
  0054          L54:    
  0054 320000   [5]             LDHX  AssocDevCounter
  0057 9ef302   [6]             CPHX  2,SP
  005a 22cf     [3]             BHI   L2B ;abs = 002b
  005c          L5C:    
  639:          }
  640:        }
  641:  
  642:        if(FoundFlag){
  005c 95       [2]             TSX   
  005d 6d05     [4]             TST   5,X
  005f 2743     [3]             BEQ   LA4 ;abs = 00a4
  643:          FLib_MemCpy(pAssocRes->assocShortAddress, AssociatedDevices[i].ShortAddress, 2);
  0061 9efe04   [5]             LDHX  4,SP
  0064 af08     [2]             AIX   #8
  0066 89       [2]             PSHX  
  0067 8b       [2]             PSHH  
  0068 95       [2]             TSX   
  0069 e604     [3]             LDA   4,X
  006b ae0c     [2]             LDX   #12
  006d 42       [5]             MUL   
  006e ab00     [2]             ADD   @AssociatedDevices
  0070 95       [2]             TSX   
  0071 e702     [3]             STA   2,X
  0073 4f       [1]             CLRA  
  0074 a900     [2]             ADC   @AssociatedDevices:MSB
  0076 ee02     [3]             LDX   2,X
  0078 87       [2]             PSHA  
  0079 8a       [3]             PULH  
  007a a602     [2]             LDA   #2
  007c ac000000 [8]             CALL  FLib_MemCpy
  0080 a702     [2]             AIS   #2
  644:          FLib_MemCpy(pAssocRes->deviceAddress, AssociatedDevices[i].ExtendedAddress, 8);
  0082 9efe04   [5]             LDHX  4,SP
  0085 89       [2]             PSHX  
  0086 8b       [2]             PSHH  
  0087 95       [2]             TSX   
  0088 e604     [3]             LDA   4,X
  008a ae0c     [2]             LDX   #12
  008c 42       [5]             MUL   
  008d ab02     [2]             ADD   @AssociatedDevices:2
  008f 95       [2]             TSX   
  0090 e702     [3]             STA   2,X
  0092 4f       [1]             CLRA  
  0093 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0095 ee02     [3]             LDX   2,X
  0097 87       [2]             PSHA  
  0098 8a       [3]             PULH  
  0099 a608     [2]             LDA   #8
  009b ac000000 [8]             CALL  FLib_MemCpy
  009f a702     [2]             AIS   #2
  645:  
  646:        }else{
  00a1 cc013d   [4]             JMP   L13D ;abs = 013d
  00a4          LA4:    
  647:  
  648:  
  649:          if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  00a4 9efe0b   [5]             LDHX  11,SP
  00a7 e614     [3]             LDA   20,X
  00a9 2a1c     [3]             BPL   LC7 ;abs = 00c7
  650:          {
  651:            /* Assign a unique short address less than 0xfffe if the device requests so. */
  652:            uint16_t tmpAddr = AssocDevCounter + 1;
  00ab 320000   [5]             LDHX  AssocDevCounter
  00ae af01     [2]             AIX   #1
  00b0 9eff09   [5]             STHX  9,SP
  653:            FLib_MemCpy(pAssocRes->assocShortAddress, &tmpAddr, 2);
  00b3 9efe04   [5]             LDHX  4,SP
  00b6 af08     [2]             AIX   #8
  00b8 89       [2]             PSHX  
  00b9 8b       [2]             PSHH  
  00ba 95       [2]             TSX   
  00bb af0a     [2]             AIX   #10
  00bd a602     [2]             LDA   #2
  00bf ac000000 [8]             CALL  FLib_MemCpy
  00c3 a702     [2]             AIS   #2
  654:          }
  00c5 200a     [3]             BRA   LD1 ;abs = 00d1
  00c7          LC7:    
  655:          else
  656:          {
  657:            /* A short address of 0xfffe means that the device is granted access to
  658:               the PAN (Associate successful) but that long addressing is used.*/
  659:            pAssocRes->assocShortAddress[0] = 0xFE;
  00c7 9efe04   [5]             LDHX  4,SP
  00ca a6fe     [2]             LDA   #-2
  00cc e708     [3]             STA   8,X
  660:            pAssocRes->assocShortAddress[1] = 0xFF;
  00ce 4c       [1]             INCA  
  00cf e709     [3]             STA   9,X
  00d1          LD1:    
  661:  
  662:          }
  663:  
  664:  
  665:          /* Get the 64 bit address of the device requesting association. */
  666:          FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  00d1 9efe04   [5]             LDHX  4,SP
  00d4 89       [2]             PSHX  
  00d5 8b       [2]             PSHH  
  00d6 9efe0d   [5]             LDHX  13,SP
  00d9 af01     [2]             AIX   #1
  00db a608     [2]             LDA   #8
  00dd ac000000 [8]             CALL  FLib_MemCpy
  00e1 a702     [2]             AIS   #2
  667:  
  668:          /* Save Short and Extended address inside the local array */
  669:          FLib_MemCpy(AssociatedDevices[AssocDevCounter].ShortAddress, pAssocRes->assocShortAddress, 2);
  00e3 c60001   [4]             LDA   AssocDevCounter:1
  00e6 ae0c     [2]             LDX   #12
  00e8 42       [5]             MUL   
  00e9 ab00     [2]             ADD   @AssociatedDevices
  00eb 87       [2]             PSHA  
  00ec 4f       [1]             CLRA  
  00ed a900     [2]             ADC   @AssociatedDevices:MSB
  00ef 87       [2]             PSHA  
  00f0 9efe06   [5]             LDHX  6,SP
  00f3 af08     [2]             AIX   #8
  00f5 a602     [2]             LDA   #2
  00f7 ac000000 [8]             CALL  FLib_MemCpy
  00fb a702     [2]             AIS   #2
  670:          FLib_MemCpy(AssociatedDevices[AssocDevCounter].ExtendedAddress, pAssocRes->deviceAddress, 8);
  00fd c60001   [4]             LDA   AssocDevCounter:1
  0100 ae0c     [2]             LDX   #12
  0102 42       [5]             MUL   
  0103 ab02     [2]             ADD   @AssociatedDevices:2
  0105 87       [2]             PSHA  
  0106 4f       [1]             CLRA  
  0107 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0109 87       [2]             PSHA  
  010a 9efe06   [5]             LDHX  6,SP
  010d a608     [2]             LDA   #8
  010f ac000000 [8]             CALL  FLib_MemCpy
  0113 a702     [2]             AIS   #2
  671:          AssociatedDevices[AssocDevCounter].RxOnWhenIdle = pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoRxWhenIdle_c ? 0x1 : 0x0;
  0115 9efe0b   [5]             LDHX  11,SP
  0118 e614     [3]             LDA   20,X
  011a a508     [2]             BIT   #8
  011c 2602     [3]             BNE   L120 ;abs = 0120
  011e 4f       [1]             CLRA  
  011f 65       [3]             SKIP2 L122 ;abs = 0122
  0120          L120:   
  0120 a601     [2]             LDA   #1
  0122          L122:   
  0122 ac000208 [8]             CALL  App_SendAssociateResponse:520
  0126 d7000a   [4]             STA   @AssociatedDevices:10,X
  672:          AssociatedDevices[AssocDevCounter].DeviceType = pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoDeviceFfd_c ? 0x1 : 0x0;
  0129 9efe0b   [5]             LDHX  11,SP
  012c e614     [3]             LDA   20,X
  012e a502     [2]             BIT   #2
  0130 2602     [3]             BNE   L134 ;abs = 0134
  0132 4f       [1]             CLRA  
  0133 65       [3]             SKIP2 L136 ;abs = 0136
  0134          L134:   
  0134 a601     [2]             LDA   #1
  0136          L136:   
  0136 ac000208 [8]             CALL  App_SendAssociateResponse:520
  013a d7000b   [4]             STA   @AssociatedDevices:11,X
  013d          L13D:   
  673:          /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
  674:  
  675:        }
  676:  
  677:        pAssocRes->status = gSuccess_c;
  013d 9efe04   [5]             LDHX  4,SP
  0140 6f15     [5]             CLR   21,X
  678:        /* Do not use security */
  679:        #ifndef gMAC2006_d    
  680:            pAssocRes->securityEnable = FALSE;
  681:        #else
  682:            pAssocRes->securityLevel = 0;
  0142 6f0a     [5]             CLR   10,X
  683:        #endif //gMAC2006_d    
  684:            
  685:        
  686:        /* Send the Associate Response to the MLME. */
  687:        if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0144 9efe07   [5]             LDHX  7,SP
  0147 ac000000 [8]             CALL  NWK_MLME_SapHandler
  014b 4d       [1]             TSTA  
  014c 2703     [3]             BEQ   L151 ;abs = 0151
  014e cc01ea   [4]             JMP   L1EA ;abs = 01ea
  0151          L151:   
  688:        {
  689:          CommUtil_Print("Done\n\r", gAllowToBlock_d);
  0151 450000   [3]             LDHX  @"Done\012\015"
  0154 ac000201 [8]             CALL  App_SendAssociateResponse:513
  690:          
  691:          /* Print association information */
  692:          if(FoundFlag)
  0158 95       [2]             TSX   
  0159 6d05     [4]             TST   5,X
  015b 2709     [3]             BEQ   L166 ;abs = 0166
  693:            CommUtil_Print("\n\r************************************\n\r\n\rWelcome back old friend\n\rShort Address: 0x", gAllowToBlock_d);
  015d 450000   [3]             LDHX  @"\012\015************************************\012\015\012\015Welcome back old friend\012\015Short Address: 0x"
  0160 ac000201 [8]             CALL  App_SendAssociateResponse:513
  0164 200d     [3]             BRA   L173 ;abs = 0173
  0166          L166:   
  694:          else{
  695:            CommUtil_Print("\n\r************************************\n\r\n\rI see you are new, welcome!\n\rShort Address: 0x", gAllowToBlock_d);
  0166 450000   [3]             LDHX  @"\012\015************************************\012\015\012\015I see you are new, welcome!\012\015Short Address: 0x"
  0169 ac000201 [8]             CALL  App_SendAssociateResponse:513
  696:            i = AssocDevCounter;
  016d 320000   [5]             LDHX  AssocDevCounter
  0170 9eff02   [5]             STHX  2,SP
  0173          L173:   
  697:          }
  698:          CommUtil_PrintHex((uint8_t *)AssociatedDevices[i].ShortAddress, 2, 0);
  0173 95       [2]             TSX   
  0174 e602     [3]             LDA   2,X
  0176 ae0c     [2]             LDX   #12
  0178 42       [5]             MUL   
  0179 ab00     [2]             ADD   @AssociatedDevices
  017b 87       [2]             PSHA  
  017c 4f       [1]             CLRA  
  017d a900     [2]             ADC   @AssociatedDevices:MSB
  017f 87       [2]             PSHA  
  0180 ae02     [2]             LDX   #2
  0182 4f       [1]             CLRA  
  0183 ac000000 [8]             CALL  CommUtil_PrintHex
  0187 a702     [2]             AIS   #2
  699:          CommUtil_Print("\n\rLong Address: 0x", gAllowToBlock_d);
  0189 450000   [3]             LDHX  @"\012\015Long Address: 0x"
  018c ac000201 [8]             CALL  App_SendAssociateResponse:513
  700:          CommUtil_PrintHex((uint8_t *)AssociatedDevices[i].ExtendedAddress, 8, 0);
  0190 95       [2]             TSX   
  0191 e602     [3]             LDA   2,X
  0193 ae0c     [2]             LDX   #12
  0195 42       [5]             MUL   
  0196 ab02     [2]             ADD   @AssociatedDevices:2
  0198 87       [2]             PSHA  
  0199 4f       [1]             CLRA  
  019a a902     [2]             ADC   @AssociatedDevices:2:MSB
  019c 87       [2]             PSHA  
  019d ae08     [2]             LDX   #8
  019f 4f       [1]             CLRA  
  01a0 ac000000 [8]             CALL  CommUtil_PrintHex
  01a4 a702     [2]             AIS   #2
  701:          if(AssociatedDevices[i].RxOnWhenIdle)
  01a6 95       [2]             TSX   
  01a7 e602     [3]             LDA   2,X
  01a9 ae0c     [2]             LDX   #12
  01ab 42       [5]             MUL   
  01ac 8c       [1]             CLRH  
  01ad 97       [1]             TAX   
  01ae de000a   [4]             LDX   @AssociatedDevices:10,X
  01b1 2705     [3]             BEQ   L1B8 ;abs = 01b8
  702:            CommUtil_Print("\n\rRX On When Idle: Yes", gAllowToBlock_d);
  01b3 450000   [3]             LDHX  @"\012\015RX On When Idle: Yes"
  01b6 2003     [3]             BRA   L1BB ;abs = 01bb
  01b8          L1B8:   
  703:          else
  704:            CommUtil_Print("\n\rRX On When Idle: No", gAllowToBlock_d);
  01b8 450000   [3]             LDHX  @"\012\015RX On When Idle: No"
  01bb          L1BB:   
  01bb ac000201 [8]             CALL  App_SendAssociateResponse:513
  705:          if(AssociatedDevices[i].DeviceType)
  01bf 95       [2]             TSX   
  01c0 e602     [3]             LDA   2,X
  01c2 ae0c     [2]             LDX   #12
  01c4 42       [5]             MUL   
  01c5 8c       [1]             CLRH  
  01c6 97       [1]             TAX   
  01c7 de000b   [4]             LDX   @AssociatedDevices:11,X
  01ca 2705     [3]             BEQ   L1D1 ;abs = 01d1
  706:            CommUtil_Print("\n\rDevice Type: FFD", gAllowToBlock_d);
  01cc 450000   [3]             LDHX  @"\012\015Device Type: FFD"
  01cf 2003     [3]             BRA   L1D4 ;abs = 01d4
  01d1          L1D1:   
  707:          else
  708:            CommUtil_Print("\n\rDevice Type: RFD", gAllowToBlock_d);
  01d1 450000   [3]             LDHX  @"\012\015Device Type: RFD"
  01d4          L1D4:   
  01d4 ac000201 [8]             CALL  App_SendAssociateResponse:513
  709:          CommUtil_Print("\n\r\n\r************************************\n\r", gAllowToBlock_d);
  01d8 450000   [3]             LDHX  @"\012\015\012\015************************************\012\015"
  01db ac000201 [8]             CALL  App_SendAssociateResponse:513
  710:          
  711:          /* "SAVE" the new device by incrementing the counter */
  712:          AssocDevCounter++;
  01df 450000   [3]             LDHX  @AssocDevCounter
  01e2 6c01     [5]             INC   1,X
  01e4 2601     [3]             BNE   L1E7 ;abs = 01e7
  01e6 7c       [4]             INC   ,X
  01e7          L1E7:   
  713:          return errorNoError;
  01e7 4f       [1]             CLRA  
  01e8 2014     [3]             BRA   L1FE ;abs = 01fe
  01ea          L1EA:   
  714:        }
  715:        else
  716:        {
  717:          /* One or more parameters in the message were invalid. */
  718:          CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  01ea 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  01ed ac000201 [8]             CALL  App_SendAssociateResponse:513
  719:          return errorInvalidParameter;
  01f1 a605     [2]             LDA   #5
  01f3 2009     [3]             BRA   L1FE ;abs = 01fe
  01f5          L1F5:   
  720:        }
  721:      
  722:    }
  723:    else
  724:    {
  725:      /* Allocation of a message buffer failed. */
  726:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  01f5 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  01f8 ac000201 [8]             CALL  App_SendAssociateResponse:513
  727:      return errorAllocFailed;
  01fc a604     [2]             LDA   #4
  01fe          L1FE:   
  728:    }
  729:  }
  01fe a70c     [2]             AIS   #12
  0200 8d       [7]             RTC   
  0201          L201:   
  0201 a601     [2]             LDA   #1
  0203 ac000000 [8]             CALL  CommUtil_Print
  0207 8d       [7]             RTC   
  0208          L208:   
  0208 ce0001   [4]             LDX   AssocDevCounter:1
  020b 87       [2]             PSHA  
  020c a60c     [2]             LDA   #12
  020e 42       [5]             MUL   
  020f 8c       [1]             CLRH  
  0210 97       [1]             TAX   
  0211 86       [3]             PULA  
  0212 8d       [7]             RTC   
  730:  
  731:  /******************************************************************************
  732:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  733:  * messages from the MLME, e.g. (Dis)Associate Indication.
  734:  *
  735:  * The function may return either of the following values:
  736:  *   errorNoError:   The message was processed.
  737:  *   errorNoMessage: The message pointer is NULL.
  738:  ******************************************************************************/
  739:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  740:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  741:    if(pMsg == NULL)
  0002 650000   [3]             CPHX  #0
  0005 2604     [3]             BNE   LB ;abs = 000b
  742:      return errorNoMessage;
  0007 a603     [2]             LDA   #3
  0009 2025     [3]             BRA   L30 ;abs = 0030
  000b          LB:     
  743:    
  744:    /* Handle the incoming message. The type determines the sort of processing.*/
  745:    switch(pMsg->msgType) {
  000b f6       [3]             LDA   ,X
  000c 2706     [3]             BEQ   L14 ;abs = 0014
  000e a10c     [2]             CMP   #12
  0010 261d     [3]             BNE   L2F ;abs = 002f
  0012 2012     [3]             BRA   L26 ;abs = 0026
  0014          L14:    
  746:    case gNwkAssociateInd_c:
  747:      CommUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
  0014 450000   [3]             LDHX  @"Received an MLME-Associate Indication from the MAC\012\015"
  0017 a601     [2]             LDA   #1
  0019 ac000000 [8]             CALL  CommUtil_Print
  748:      /* A device sent us an Associate Request. We must send back a response.  */
  749:      return App_SendAssociateResponse(pMsg);
  001d 9efe01   [5]             LDHX  1,SP
  0020 ac000000 [8]             CALL  App_SendAssociateResponse
  0024 200a     [3]             BRA   L30 ;abs = 0030
  0026          L26:    
  750:      break;
  751:      
  752:    case gNwkCommStatusInd_c:
  753:      /* Sent by the MLME after the Association Response has been transmitted. */
  754:      CommUtil_Print("Received an MLME-Comm-Status Indication from the MAC\n\r", gAllowToBlock_d);
  0026 450000   [3]             LDHX  @"Received an MLME-Comm-Status Indication from the MAC\012\015"
  0029 a601     [2]             LDA   #1
  002b ac000000 [8]             CALL  CommUtil_Print
  002f          L2F:    
  755:      break;
  756:    }
  757:    return errorNoError;
  002f 4f       [1]             CLRA  
  0030          L30:    
  758:  }
  0030 a702     [2]             AIS   #2
  0032 8d       [7]             RTC   
  759:  
  760:  /******************************************************************************
  761:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
  762:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
  763:  *
  764:  ******************************************************************************/
  765:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
  766:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  767:  	uint8_t *btnValue;
  768:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2705     [3]             BEQ   LC ;abs = 000c
  0007 41010e   [4]             CBEQA #1,L18 ;abs = 0018
  000a 2009     [3]             BRA   L15 ;abs = 0015
  000c          LC:     
  769:    {
  770:      /* The MCPS-Data confirm is sent by the MAC to the network 
  771:         or application layer when data has been sent. */
  772:    case gMcpsDataCnf_c:
  773:      if(mcPendingPackets)
  000c c60000   [4]             LDA   mcPendingPackets
  000f 2704     [3]             BEQ   L15 ;abs = 0015
  774:        mcPendingPackets--;
  0011 450000   [3]             LDHX  @mcPendingPackets
  0014 7a       [4]             DEC   ,X
  0015          L15:    
  0015 cc00bc   [4]             JMP   LBC ;abs = 00bc
  0018          L18:    
  775:      break;
  776:    
  777:    case gMcpsDataInd_c:
  778:      /* The MCPS-Data indication is sent by the MAC to the network 
  779:         or application layer when data has been received. We simply 
  780:         copy the received data to the serial terminal interface. */
  781:  
  782:  
  783:  
  784:    /* NEWCODE: Check for Button Data */
  785:      if(FLib_MemCmp(pMsgIn->msgData.dataInd.pMsdu,"Counter:",8)){
  0018 9ece29   [5]             LDHX  41,X
  001b 89       [2]             PSHX  
  001c 8b       [2]             PSHH  
  001d 450000   [3]             LDHX  @"Counter:"
  0020 a608     [2]             LDA   #8
  0022 ac000000 [8]             CALL  FLib_MemCmp
  0026 a702     [2]             AIS   #2
  0028 4d       [1]             TSTA  
  0029 2603     [3]             BNE   L2E ;abs = 002e
  002b cc00be   [4]             JMP   LBE ;abs = 00be
  002e          L2E:    
  786:      	btnValue = (uint8_t *)pMsgIn->msgData.dataInd.pMsdu;
  002e 9efe03   [5]             LDHX  3,SP
  0031 9ece29   [5]             LDHX  41,X
  787:      	btnValue += 8;
  0034 af08     [2]             AIX   #8
  788:        TurnOffLeds();
  0036 89       [2]             PSHX  
  0037 8b       [2]             PSHH  
  0038 ac000000 [8]             CALL  LED_TurnOffAllLeds
  789:        switch(*btnValue){
  003c 8a       [3]             PULH  
  003d 88       [3]             PULX  
  003e f6       [3]             LDA   ,X
  003f a134     [2]             CMP   #52
  0041 221a     [3]             BHI   L5D ;abs = 005d
  0043 a031     [2]             SUB   #49
  0045 97       [1]             TAX   
  0046 4f       [1]             CLRA  
  0047 cd0000   [6]             JSR   _Jump_Table_Header_Offset
  004a 04               DC.B  4
  004b 11               DC.B  L5D
  004c 03               DC.B  L50
  004d 06               DC.B  L54
  004e 09               DC.B  L58
  004f 0b               DC.B  L5B
  0050          L50:    
  790:          case '1':
  791:           Led1On();
  0050 1100     [5]             BCLR  0,0
  792:          break;
  0052 2009     [3]             BRA   L5D ;abs = 005d
  0054          L54:    
  793:          case '2':
  794:           Led2On();
  0054 1900     [5]             BCLR  4,0
  795:          break;
  0056 2005     [3]             BRA   L5D ;abs = 005d
  0058          L58:    
  796:          case '3':
  797:           Led3On();
  0058 1106     [5]             BCLR  0,6
  798:          break;
  005a 65       [3]             SKIP2 L5D ;abs = 005d
  005b          L5B:    
  799:          case '4':
  800:           Led4On();
  005b 1306     [5]             BCLR  1,6
  005d          L5D:    
  801:          break;
  802:        }
  803:  
  804:        CommUtil_Print("Source Addres : 0x", gAllowToBlock_d);
  005d 450000   [3]             LDHX  @"Source Addres : 0x"
  0060 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  805:        CommUtil_PrintHex((uint8_t *)pMsgIn->msgData.dataInd.srcAddr, 2, 0);
  0064 9efe03   [5]             LDHX  3,SP
  0067 af0c     [2]             AIX   #12
  0069 89       [2]             PSHX  
  006a 8b       [2]             PSHH  
  006b ae02     [2]             LDX   #2
  006d 4f       [1]             CLRA  
  006e ac000000 [8]             CALL  CommUtil_PrintHex
  0072 a702     [2]             AIS   #2
  806:        CommUtil_Print("\r\n", gAllowToBlock_d);
  0074 450000   [3]             LDHX  @"\015\012"
  0077 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  807:        CommUtil_Print("Link Quality : 0x", gAllowToBlock_d);
  007b 450000   [3]             LDHX  @"Link Quality : 0x"
  007e ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  808:        CommUtil_PrintHex((uint8_t *)pMsgIn->msgData.dataInd.mpduLinkQuality, 1, 0);          
  0082 9efe03   [5]             LDHX  3,SP
  0085 e618     [3]             LDA   24,X
  0087 87       [2]             PSHA  
  0088 4f       [1]             CLRA  
  0089 87       [2]             PSHA  
  008a ae01     [2]             LDX   #1
  008c ac000000 [8]             CALL  CommUtil_PrintHex
  0090 a702     [2]             AIS   #2
  809:        CommUtil_Print("\r\n", gAllowToBlock_d);
  0092 450000   [3]             LDHX  @"\015\012"
  0095 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  810:        CommUtil_Print("Data : ", gAllowToBlock_d);
  0099 450000   [3]             LDHX  @"Data : "
  009c ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  811:        CommUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  00a0 9efe03   [5]             LDHX  3,SP
  00a3 9ece29   [5]             LDHX  41,X
  00a6 9eff01   [5]             STHX  1,SP
  00a9 9efe03   [5]             LDHX  3,SP
  00ac e617     [3]             LDA   23,X
  00ae 9efe01   [5]             LDHX  1,SP
  00b1 ac000000 [8]             CALL  CommUtil_Tx
  812:        CommUtil_Print("\r\n", gAllowToBlock_d);
  00b5 450000   [3]             LDHX  @"\015\012"
  00b8 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  00bc          LBC:    
  813:  
  814:      }else{
  00bc 2015     [3]             BRA   LD3 ;abs = 00d3
  00be          LBE:    
  815:        CommUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  00be 9efe03   [5]             LDHX  3,SP
  00c1 9ece29   [5]             LDHX  41,X
  00c4 9eff01   [5]             STHX  1,SP
  00c7 9efe03   [5]             LDHX  3,SP
  00ca e617     [3]             LDA   23,X
  00cc 9efe01   [5]             LDHX  1,SP
  00cf ac000000 [8]             CALL  CommUtil_Tx
  00d3          LD3:    
  816:      }
  817:      /* NEWCODE: Check for Button Data */
  818:      break;
  819:    }
  820:  }
  00d3 a704     [2]             AIS   #4
  00d5 8d       [7]             RTC   
  00d6          LD6:    
  00d6 a601     [2]             LDA   #1
  00d8 ac000000 [8]             CALL  CommUtil_Print
  00dc 8d       [7]             RTC   
  821:  
  822:  /******************************************************************************
  823:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
  824:  * the name implies, wait for a message, thus blocking the execution of the
  825:  * state machine. Instead the function analyzes the supplied message to determine
  826:  * whether or not the message is of the expected type.
  827:  * The function may return either of the following values:
  828:  *   errorNoError: The message was of the expected type.
  829:  *   errorNoMessage: The message pointer is NULL.
  830:  *   errorWrongConfirm: The message is not of the expected type.
  831:  *
  832:  ******************************************************************************/
  833:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
  834:  {
  835:    /* Do we have a message? If not, the exit with error code */
  836:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  837:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  838:  
  839:    /* Is it the expected message type? If not then exit with error code */
  840:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
  841:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
  842:  
  843:    /* Found the expected message. Return with success code */
  844:    return errorNoError;
  000e 4f       [1]             CLRA  
  845:  }
  000f 8d       [7]             RTC   
  846:  
  847:  /******************************************************************************
  848:  * The App_TransmitCommData() function will perform (single/multi buffered)
  849:  * data transmissions of data received by the serial terminal interface. Data could also come from
  850:  * other sources such as sensors etc. This is completely determined by the
  851:  * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
  852:  * number of packets pending for transmission in the MAC. A global variable
  853:  * is incremented each time a data packet is sent to the MCPS, and decremented
  854:  * when the corresponding MCPS-Data Confirm message is received. If the counter
  855:  * reaches the defined maximum no more data buffers are allocated until the
  856:  * counter is decreased below the maximum number of pending packets.
  857:  *
  858:  * The function uses the device information, that was stored when the device,
  859:  * associated to us, for building an MCPS-Data Request message. The message
  860:  * is sent to the MCPS service access point in the MAC.
  861:  ******************************************************************************/
  862:  static void App_TransmitCommData(void)
  863:  {   
  864:    static uint8_t keysBuffer[mMaxKeysToReceive_c];
  865:    static uint8_t keysReceived = 0;
  866:    
  867:    /* get data from serial terminal interface */
  868:    if( keysReceived < mMaxKeysToReceive_c) 
  0000 c60000   [4]             LDA   keysReceived
  0003 a120     [2]             CMP   #32
  0005 2414     [3]             BCC   L1B ;abs = 001b
  869:    { 
  870:      if(Comm_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
  0007 ab00     [2]             ADD   @keysBuffer
  0009 87       [2]             PSHA  
  000a 4f       [1]             CLRA  
  000b a900     [2]             ADC   @keysBuffer:MSB
  000d 88       [3]             PULX  
  000e 87       [2]             PSHA  
  000f 8a       [3]             PULH  
  0010 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0014 4d       [1]             TSTA  
  0015 2704     [3]             BEQ   L1B ;abs = 001b
  871:      {
  872:      keysReceived++;
  0017 450000   [3]             LDHX  @keysReceived
  001a 7c       [4]             INC   ,X
  001b          L1B:    
  873:      }
  874:    }
  875:    /* Use multi buffering for increased TX performance. It does not really
  876:       have any effect at a UART baud rate of 19200bps but serves as an
  877:       example of how the throughput may be improved in a real-world 
  878:       application where the data rate is of concern. */
  879:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  001b c60000   [4]             LDA   mcPendingPackets
  001e a102     [2]             CMP   #2
  0020 240e     [3]             BCC   L30 ;abs = 0030
  0022 320000   [5]             LDHX  mpPacket
  0025 2609     [3]             BNE   L30 ;abs = 0030
  880:    {
  881:      /* If the maximum number of pending data buffes is below maximum limit 
  882:         and we do not have a data buffer already then allocate one. */
  883:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  0027 a69c     [2]             LDA   #-100
  0029 ac000000 [8]             CALL  MM_Alloc
  002d 960000   [5]             STHX  mpPacket
  0030          L30:    
  884:    }
  885:  
  886:    if(mpPacket != NULL)
  0030 320000   [5]             LDHX  mpPacket
  0033 2603     [3]             BNE   L38 ;abs = 0038
  0035 cc00ba   [4]             JMP   LBA ;abs = 00ba
  0038          L38:    
  887:    {
  888:        /* get data from serial terminal interface */        
  889:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  0038 af27     [2]             AIX   #39
  003a 9f       [1]             TXA   
  003b 8b       [2]             PSHH  
  003c 320000   [5]             LDHX  mpPacket
  003f e726     [3]             STA   38,X
  0041 86       [3]             PULA  
  0042 e725     [3]             STA   37,X
  890:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) keysBuffer, keysReceived);
  0044 9ece25   [5]             LDHX  37,X
  0047 89       [2]             PSHX  
  0048 8b       [2]             PSHH  
  0049 450000   [3]             LDHX  @keysBuffer
  004c c60000   [4]             LDA   keysReceived
  004f ac000000 [8]             CALL  FLib_MemCpy
  0053 a702     [2]             AIS   #2
  891:  
  892:        /* Data was available in the serial terminal interface receive buffer. Now create an
  893:           MCPS-Data Request message containing the serial terminal interface data. */
  894:        mpPacket->msgType = gMcpsDataReq_c;
  0055 320000   [5]             LDHX  mpPacket
  0058 7f       [4]             CLR   ,X
  895:        /* Create the header using device information stored when creating 
  896:           the association response. In this simple example the use of short
  897:           addresses is hardcoded. In a real world application we must be
  898:           flexible, and use the address mode required by the given situation. */
  899:        FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, maDeviceShortAddress, 2);
  0059 af01     [2]             AIX   #1
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maDeviceShortAddress
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
  900:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  0068 320000   [5]             LDHX  mpPacket
  006b af0c     [2]             AIX   #12
  006d 89       [2]             PSHX  
  006e 8b       [2]             PSHH  
  006f 450000   [3]             LDHX  @maShortAddress
  0072 a602     [2]             LDA   #2
  0074 ac000000 [8]             CALL  FLib_MemCpy
  0078 a702     [2]             AIS   #2
  901:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  007a 320000   [5]             LDHX  mpPacket
  007d af09     [2]             AIX   #9
  007f ac0000ca [8]             CALL  App_TransmitCommData:202
  902:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  0083 320000   [5]             LDHX  mpPacket
  0086 af14     [2]             AIX   #20
  0088 ac0000ca [8]             CALL  App_TransmitCommData:202
  903:        mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  008c a602     [2]             LDA   #2
  008e 320000   [5]             LDHX  mpPacket
  0091 e70b     [3]             STA   11,X
  904:        mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  0093 e716     [3]             STA   22,X
  905:        mpPacket->msgData.dataReq.msduLength = keysReceived;
  0095 c60000   [4]             LDA   keysReceived
  0098 e717     [3]             STA   23,X
  906:        /* Request MAC level acknowledgement, and 
  907:           indirect transmission of the data packet */
  908:        mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c;
  009a a605     [2]             LDA   #5
  009c e719     [3]             STA   25,X
  909:        /* Give the data packet a handle. The handle is
  910:           returned in the MCPS-Data Confirm message. */
  911:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  009e c60000   [4]             LDA   mMsduHandle
  00a1 e718     [3]             STA   24,X
  00a3 4c       [1]             INCA  
  00a4 c70000   [4]             STA   mMsduHandle
  912:  #ifdef gMAC2006_d
  913:        mpPacket->msgData.dataReq.securityLevel = 0;
  00a7 6f1a     [5]             CLR   26,X
  914:  #endif //gMAC2006_d      
  915:        
  916:        /* Send the Data Request to the MCPS */
  917:        (void)MSG_Send(NWK_MCPS, mpPacket);
  00a9 ac000000 [8]             CALL  NWK_MCPS_SapHandler
  918:        /* Prepare for another data buffer */
  919:        mpPacket = NULL;
  00ad 5f       [1]             CLRX  
  00ae 8c       [1]             CLRH  
  00af 960000   [5]             STHX  mpPacket
  920:        mcPendingPackets++;
  00b2 450000   [3]             LDHX  @mcPendingPackets
  00b5 7c       [4]             INC   ,X
  921:        /* Receive another pressed keys */
  922:        keysReceived = 0;
  00b6 4f       [1]             CLRA  
  00b7 c70000   [4]             STA   keysReceived
  00ba          LBA:    
  923:    }
  924:    
  925:    /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
  926:    /* try to send it later   */
  927:    if (keysReceived)
  00ba c60000   [4]             LDA   keysReceived
  00bd 270a     [3]             BEQ   LC9 ;abs = 00c9
  928:    {
  929:    TS_SendEvent(gAppTaskID_c, gAppEvtRxFromComm_c);
  00bf c60000   [4]             LDA   gAppTaskID_c
  00c2 ae02     [2]             LDX   #2
  00c4 8c       [1]             CLRH  
  00c5 ac000000 [8]             CALL  TS_SendEvent
  00c9          LC9:    
  930:    }
  931:  }
  00c9 8d       [7]             RTC   
  00ca          LCA:    
  00ca 89       [2]             PSHX  
  00cb 8b       [2]             PSHH  
  00cc 450000   [3]             LDHX  @maPanId
  00cf a602     [2]             LDA   #2
  00d1 ac000000 [8]             CALL  FLib_MemCpy
  00d5 a702     [2]             AIS   #2
  00d7 8d       [7]             RTC   
  932:  
  933:  /*****************************************************************************
  934:  * Function to handle a generic key press. Called for all keys.
  935:  *****************************************************************************/
  936:  static void App_HandleGenericKey(void)
  937:  {
  938:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
  939:    {
  940:      StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
  941:      StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
  942:      StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
  943:      StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
  944:      Led1Off();
  001d 1000     [5]             BSET  0,0
  945:      Led2Off();
  001f 1800     [5]             BSET  4,0
  946:      Led3Off();
  0021 1006     [5]             BSET  0,6
  947:      Led4Off();
  0023 1206     [5]             BSET  1,6
  948:      LCD_ClearDisplay();
  949:      LCD_WriteString(1,"Application");
  950:      LCD_WriteString(2,"    started");     
  951:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
  952:    }
  953:  }
  002f 8d       [7]             RTC   
  954:  
  955:  /*****************************************************************************
  956:  * Handles all key events for this device.
  957:  * Interface assumptions: None
  958:  * Return value: None
  959:  *****************************************************************************/
  960:  #if (gMC1323xMatrixKBD_d == TRUE)
  961:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
  962:  {
  963:   (void)events;
  964:   (void)pressedKey;
  965:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
  966:  }
  0004 8d       [7]             RTC   
  967:  #else
  968:  static void App_HandleKeys(key_event_t events)
  969:  {
  970:    switch ( events ) 
  971:      { 
  972:        case gKBD_EventSW1_c:
  973:        case gKBD_EventSW2_c:
  974:        case gKBD_EventSW3_c:
  975:        case gKBD_EventSW4_c:
  976:        case gKBD_EventLongSW1_c:
  977:        case gKBD_EventLongSW2_c:
  978:        case gKBD_EventLongSW3_c:
  979:        case gKBD_EventLongSW4_c:
  980:         App_HandleGenericKey();
  981:         break;  
  982:      }    
  983:  }                                                      
  984:  #endif //gMC1323xMatrixKBD_d
  985:  /*****************************************************************************
  986:  * The DeepSleepWakeupStackProc(void) function is called each time the 
  987:  * application exits the DeepSleep mode .
  988:  * 
  989:  * Return value:
  990:  *     None
  991:  *****************************************************************************/
  992:  void DeepSleepWakeupStackProc(void){
  993:    return;
  994:  }
  0000 8d       [7]             RTC   
  995:  
  996:  /******************************************************************************
  997:  * The following functions are called by the MAC to put messages into the
  998:  * Application's queue. They need to be defined even if they are not used
  999:  * in order to avoid linker errors.
 1000:  ******************************************************************************/
 1001:  
 1002:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
 1003:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1004:    /* Put the incoming MLME message in the applications input queue. */
 1005:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1006:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1007:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1008:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1009:  
 1010:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
 1011:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1012:    /* Put the incoming MCPS message in the applications input queue. */
 1013:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1014:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1015:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1016:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1017:  
 1018:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
 1019:  {
 1020:    /* If the message is not handled anywhere it must be freed. */
 1021:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
 1022:    return gSuccess_c;
  0004 4f       [1]             CLRA  
 1023:  }
  0005 8d       [7]             RTC   
 1024:  
 1025:  /******************************************************************************/
 1026:  
