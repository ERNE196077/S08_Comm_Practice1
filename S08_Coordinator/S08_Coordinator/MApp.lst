ANSI-C/cC++ Compiler for HC08 V-5.0.45 Build 14019, Jan 20 2014

    1:  /*****************************************************************************
    2:  *  MyWirelessApp Demo Non Beacon Coordinator application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  
   17:  /************************************************************************************
   18:  *************************************************************************************
   19:  * Private macros
   20:  *************************************************************************************
   21:  ************************************************************************************/
   22:  
   23:  /* If there are too many pending packets to be send over the air, */
   24:  /* receive mMaxKeysToReceive_c chars. */
   25:  /* The chars will be send over the air when there are no pending packets*/
   26:  #define mMaxKeysToReceive_c 32
   27:  
   28:  /************************************************************************************
   29:  *************************************************************************************
   30:  * Private prototypes
   31:  *************************************************************************************
   32:  ************************************************************************************/
   33:  
   34:  /* Forward declarations of helper functions */
   35:  static void    App_CommRxCallBack(void);
   36:  static uint8_t App_StartScan(uint8_t scanType);
   37:  static void    App_HandleScanEdConfirm(nwkMessage_t *pMsg);
   38:  static uint8_t App_StartCoordinator(void);
   39:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   40:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn);
   41:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   42:  static void    App_TransmitCommData(void);
   43:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   44:  #if (gMC1323xMatrixKBD_d == TRUE)
   45:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   46:  #else
   47:  static void    App_HandleKeys(key_event_t events);
   48:  #endif //gMC1323xMatrixKBD_d
   49:  
   50:  
   51:  /************************************************************************************
   52:  *************************************************************************************
   53:  * Private type definitions
   54:  *************************************************************************************
   55:  ************************************************************************************/
   56:  
   57:  
   58:  /************************************************************************************
   59:  *************************************************************************************
   60:  * Private memory declarations
   61:  *************************************************************************************
   62:  ************************************************************************************/
   63:  
   64:  /* The short address and PAN ID of the coordinator*/
   65:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
   66:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   67:  
   68:  
   69:  /* The current logical channel (frequency band) */
   70:  static uint8_t mLogicalChannel;
   71:  
   72:  /* Data request packet for sending serial input to the coordinator */
   73:  static nwkToMcpsMessage_t *mpPacket;
   74:  
   75:  /* The MSDU handle is a unique data packet identifier */
   76:  static uint8_t mMsduHandle;
   77:  
   78:  /* NEWCODE: Pointer to Package Button State */
   79:  static nwkToMcpsMessage_t *mpGenericPkg;
   80:  /* NEWCODE: Pointer to Package Button State */
   81:  static uint8_t maDeviceShortAddress[2];
   82:  
   83:  /* Number of pending data packets */
   84:  static uint8_t mcPendingPackets;
   85:  
   86:  /* Application input queues */
   87:  static anchor_t mMlmeNwkInputQueue;
   88:  static anchor_t mMcpsNwkInputQueue;
   89:  
   90:  static EndDevListItem_t AssociatedDevices[5];
   91:  static uint16_t AssocDevCounter;
   92:  
   93:  
   94:  /************************************************************************************
   95:  *************************************************************************************
   96:  * Public memory declarations
   97:  *************************************************************************************
   98:  ************************************************************************************/
   99:  
  100:  /* The current state of the applications state machine */
  101:  uint8_t gState;
  102:  
  103:  /* This data set contains application variables to be preserved across resets */
  104:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  105:    {NULL, 0}       /* Required end-of-table marker. */
  106:  };
  107:  
  108:  /************************************************************************************
  109:  *************************************************************************************
  110:  * Public functions
  111:  *************************************************************************************
  112:  ************************************************************************************/
  113:  
  114:  void DeepSleepWakeupStackProc(void);
  115:  
  116:  /*****************************************************************************
  117:  * Initialization function for the App Task. This is called during
  118:  * initialization and should contain any application specific initialization
  119:  * (ie. hardware initialization/setup, table initialization, power up
  120:  * notificaiton.
  121:  *
  122:  * Interface assumptions: None
  123:  *
  124:  * Return value: None
  125:  *
  126:  *****************************************************************************/
  127:  
  128:  void MApp_init(void)
  129:  { 
  130:    
  131:    /* The initial application state */
  132:    gState = stateInit;
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  133:    /* Reset number of pending packets */
  134:    mcPendingPackets = 0;   
  0004 c70000   [4]             STA   mcPendingPackets
  135:    /* Number of devices associated - Max 5 */
  136:    AssocDevCounter = 0; 
  0007 8c       [1]             CLRH  
  0008 5f       [1]             CLRX  
  0009 960000   [5]             STHX  AssocDevCounter
  137:  
  138:    /* Initialize the MAC 802.15.4 extended address */
  139:    Init_MacExtendedAddress();
  000c ac000000 [8]             CALL  Init_MacExtendedAddress
  140:    /* register keyboard callback function */
  141:    KBD_Init(App_HandleKeys);
  0010 450000   [3]             LDHX  @App_HandleKeys
  0013 89       [2]             PSHX  
  0014 8b       [2]             PSHH  
  0015 a600     [2]             LDA   @App_HandleKeys:PAGE
  0017 87       [2]             PSHA  
  0018 ac000000 [8]             CALL  KBD_Init
  001c a703     [2]             AIS   #3
  142:    /* Initialize SPI Module */
  143:    SPI_Init();
  001e ac000000 [8]             CALL  SPI1_Init
  144:    /* initialize LCD Module */
  145:    LCD_Init();
  146:    /* initialize LED Module */
  147:    LED_Init();
  0022 ac000000 [8]             CALL  LED_Init
  148:    /* Initialize the LPM module */
  149:    PWRLib_Init();
  0026 ac000000 [8]             CALL  PWRLib_Init
  150:    /* Initialize the serial terminal interface so that we can print out status messages */
  151:    Comm_SetBaud(gUartDefaultBaud_c);
  002a ae08     [2]             LDX   #8
  002c 8c       [1]             CLRH  
  002d ac000000 [8]             CALL  Uart1_SetBaud
  152:    Comm_SetRxCallBack(App_CommRxCallBack);
  0031 450000   [3]             LDHX  @App_CommRxCallBack
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 a600     [2]             LDA   @App_CommRxCallBack:PAGE
  0038 87       [2]             PSHA  
  0039 ac000000 [8]             CALL  Uart1_SetRxCallBack
  003d a703     [2]             AIS   #3
  153:    
  154:    /* initialize buzzer (NCB, SRB only) */  
  155:    BuzzerInit();  
  156:    /* Prepare input queues.*/
  157:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  003f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0042 ac000000 [8]             CALL  List_ClearAnchor
  158:    MSG_InitQueue(&mMcpsNwkInputQueue);
  0046 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  159:    /* Enable MCU interrupts */
  160:    IrqControlLib_EnableAllIrqs();
  004d 9a       [1]             CLI   
  161:    /*signal app ready*/  
  162:    Led1Flashing();
  004e a601     [2]             LDA   #1
  0050 ac000000 [8]             CALL  LED_StartFlash
  163:    Led2Flashing();
  0054 a602     [2]             LDA   #2
  0056 ac000000 [8]             CALL  LED_StartFlash
  164:    Led3Flashing();
  005a a604     [2]             LDA   #4
  005c ac000000 [8]             CALL  LED_StartFlash
  165:    Led4Flashing();
  0060 a608     [2]             LDA   #8
  0062 ac000000 [8]             CALL  LED_StartFlash
  166:      
  167:    CommUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  0066 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0069 a601     [2]             LDA   #1
  006b ac000000 [8]             CALL  CommUtil_Print
  168:    LCD_ClearDisplay();
  169:    LCD_WriteString(1,"Press any key");
  170:    LCD_WriteString(2,"to start.");
  171:  }
  006f 8d       [7]             RTC   
  172:  
  173:  /*****************************************************************************
  174:  *Mac Application Task event processor.  This function is called to
  175:  * process all events for the task. Events include timers, messages and any
  176:  * other user defined events
  177:  *
  178:  * Interface assumptions: None
  179:  *
  180:  * Return value: None
  181:  *****************************************************************************/
  182:  /* The Application Task */
  183:  void AppTask(event_t events)
  184:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  185:    /* Pointer for storing the messages from MLME */
  186:    void *pMsgIn;
  187:    /* Stores the error/success code returned by some functions. */
  188:    uint8_t ret;  
  189:    pMsgIn = NULL;
  0004 9e6f02   [6]             CLR   2,SP
  0007 9e6f01   [6]             CLR   1,SP
  190:    
  191:    /* Dequeue the MLME message */
  192:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  193:    {
  194:      /* Get the message from MLME */
  195:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff01   [5]             STHX  1,SP
  196:      
  197:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  198:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  199:      {               
  200:        ret = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  201:        if(ret == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  202:        {
  203:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  204:          /* ALSO the application can use the beacon payload.*/
  205:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe01   [5]             LDHX  1,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  206:          CommUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac000170 [8]             CALL  AppTask:368
  0035          L35:    
  207:        }
  208:      }
  209:    }
  210:    /* The application state machine */
  211:    switch(gState)
  0035 ce0000   [4]             LDX   gState
  0038 a305     [2]             CPX   #5
  003a 2225     [3]             BHI   L61 ;abs = 0061
  003c 4f       [1]             CLRA  
  003d cd0000   [6]             JSR   _Jump_Table_Header_Offset
  0040 06               DC.B  6
  0041 e2               DC.B  L124
  0042 05               DC.B  L48
  0043 10               DC.B  L54
  0044 22               DC.B  L67
  0045 49               DC.B  L8F
  0046 79               DC.B  LC0
  0047 c1               DC.B  L109
  0048          L48:    
  212:    {
  213:    case stateInit:    
  214:      /* Print a welcome message to the serial terminal interface */
  215:      CommUtil_Print("\n\rMyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  0048 450000   [3]             LDHX  @"\012\015MyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\012\015\012\015"
  004b ac000170 [8]             CALL  AppTask:368
  216:      /* Goto Energy Detection state. */
  217:      gState = stateScanEdStart;
  004f a601     [2]             LDA   #1
  218:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  219:      break;
  0051 cc00fa   [4]             JMP   LFA ;abs = 00fa
  0054          L54:    
  220:      
  221:    case stateScanEdStart:
  222:      /* Start the Energy Detection scan, and goto wait for confirm state. */
  223:      CommUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
  0054 450000   [3]             LDHX  @"Initiating the Energy Detection Scan\012\015"
  0057 ac000170 [8]             CALL  AppTask:368
  224:      /*Print the message on the LCD also*/
  225:      LCD_ClearDisplay();
  226:      LCD_WriteString(1,"Starting Energy");
  227:      LCD_WriteString(2,"Detection Scan");  
  228:      ret = App_StartScan(gScanModeED_c);
  005b 4f       [1]             CLRA  
  005c ac000000 [8]             CALL  App_StartScan
  229:      if(ret == errorNoError)
  0060 4d       [1]             TSTA  
  0061          L61:    
  0061 265b     [3]             BNE   LBE ;abs = 00be
  230:      {
  231:        gState = stateScanEdWaitConfirm;
  0063 a602     [2]             LDA   #2
  0065 2054     [3]             BRA   LBB ;abs = 00bb
  0067          L67:    
  232:      }
  233:      break;
  234:      
  235:    case stateScanEdWaitConfirm:
  236:      /* Stay in this state until the MLME Scan confirm message arrives,
  237:         and has been processed. Then goto Start Coordinator state. */
  238:      if (events & gAppEvtMessageFromMLME_c)
  0067 95       [2]             TSX   
  0068 e603     [3]             LDA   3,X
  006a a504     [2]             BIT   #4
  006c 2750     [3]             BEQ   LBE ;abs = 00be
  239:      {
  240:        if (pMsgIn)
  006e 9efe01   [5]             LDHX  1,SP
  0071 274b     [3]             BEQ   LBE ;abs = 00be
  241:        {
  242:          ret = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  0073 a60b     [2]             LDA   #11
  0075 ac000000 [8]             CALL  App_WaitMsg
  243:          if(ret == errorNoError)
  0079 4d       [1]             TSTA  
  007a 2642     [3]             BNE   LBE ;abs = 00be
  244:          {
  245:            /* Process the ED scan confirm. The logical
  246:               channel is selected by this function. */
  247:            App_HandleScanEdConfirm(pMsgIn);
  007c 9efe01   [5]             LDHX  1,SP
  007f ac000000 [8]             CALL  App_HandleScanEdConfirm
  248:            /* Go to the Start Coordinator state */
  249:            gState = stateStartCoordinator;
  0083 a603     [2]             LDA   #3
  0085 c70000   [4]             STA   gState
  250:            TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
  0088 c60000   [4]             LDA   gAppTaskID_c
  008b ae10     [2]             LDX   #16
  008d 2073     [3]             BRA   L102 ;abs = 0102
  008f          L8F:    
  251:          }
  252:        }      
  253:      }        
  254:      break;
  255:      
  256:  
  257:    case stateStartCoordinator:
  258:      if (events & gAppEvtStartCoordinator_c)
  008f 95       [2]             TSX   
  0090 e603     [3]             LDA   3,X
  0092 a510     [2]             BIT   #16
  0094 2728     [3]             BEQ   LBE ;abs = 00be
  259:      {
  260:        /* Start up as a PAN Coordinator on the selected channel. */
  261:        CommUtil_Print("\n\rStarting as PAN coordinator on channel 0x", gAllowToBlock_d);
  0096 450000   [3]             LDHX  @"\012\015Starting as PAN coordinator on channel 0x"
  0099 ac000170 [8]             CALL  AppTask:368
  262:        CommUtil_PrintHex(&mLogicalChannel, 1, FALSE);
  009d 450000   [3]             LDHX  @mLogicalChannel
  00a0 89       [2]             PSHX  
  00a1 8b       [2]             PSHH  
  00a2 ae01     [2]             LDX   #1
  00a4 4f       [1]             CLRA  
  00a5 ac000000 [8]             CALL  CommUtil_PrintHex
  00a9 a702     [2]             AIS   #2
  263:        CommUtil_Print("\n\r", gAllowToBlock_d);
  00ab 450000   [3]             LDHX  @"\012\015"
  00ae ac000170 [8]             CALL  AppTask:368
  264:        /*print a message on the LCD also*/
  265:        LCD_ClearDisplay();
  266:        LCD_WriteString(1,"Starting");
  267:        LCD_WriteString(2,"PAN coordinator");    
  268:      
  269:        ret = App_StartCoordinator();
  00b2 ac000000 [8]             CALL  App_StartCoordinator
  270:        if(ret == errorNoError)
  00b6 4d       [1]             TSTA  
  00b7 266b     [3]             BNE   L124 ;abs = 0124
  271:        {
  272:          /* If the Start request was sent successfully to
  273:             the MLME, then goto Wait for confirm state. */
  274:          gState = stateStartCoordinatorWaitConfirm;
  00b9 a604     [2]             LDA   #4
  00bb          LBB:    
  00bb c70000   [4]             STA   gState
  00be          LBE:    
  00be 2064     [3]             BRA   L124 ;abs = 0124
  00c0          LC0:    
  275:        }
  276:      }
  277:      break; 
  278:  
  279:    case stateStartCoordinatorWaitConfirm:
  280:      /* Stay in this state until the Start confirm message
  281:             arrives, and then goto the Listen state. */
  282:      if (events & gAppEvtMessageFromMLME_c)
  00c0 95       [2]             TSX   
  00c1 e603     [3]             LDA   3,X
  00c3 a504     [2]             BIT   #4
  00c5 275d     [3]             BEQ   L124 ;abs = 0124
  283:      {
  284:        if (pMsgIn)
  00c7 9efe01   [5]             LDHX  1,SP
  00ca 2758     [3]             BEQ   L124 ;abs = 0124
  285:        {        
  286:          ret = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
  00cc a60e     [2]             LDA   #14
  00ce ac000000 [8]             CALL  App_WaitMsg
  287:          if(ret == errorNoError)
  00d2 4d       [1]             TSTA  
  00d3 264f     [3]             BNE   L124 ;abs = 0124
  288:          {
  289:            CommUtil_Print("Started the coordinator with PAN ID 0x", gAllowToBlock_d);
  00d5 450000   [3]             LDHX  @"Started the coordinator with PAN ID 0x"
  00d8 ac000170 [8]             CALL  AppTask:368
  290:            CommUtil_PrintHex((uint8_t *)maPanId, 2, 0);
  00dc 450000   [3]             LDHX  @maPanId
  00df ac000177 [8]             CALL  AppTask:375
  291:            CommUtil_Print(", and short address 0x", gAllowToBlock_d);
  00e3 450000   [3]             LDHX  @", and short address 0x"
  00e6 ac000170 [8]             CALL  AppTask:368
  292:            CommUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
  00ea 450000   [3]             LDHX  @maShortAddress
  00ed ac000177 [8]             CALL  AppTask:375
  293:            CommUtil_Print(".\n\r\n\rReady to send and receive data over the serial terminal interface.\n\r\n\r", gAllowToBlock_d);
  00f1 450000   [3]             LDHX  @".\012\015\012\015Ready to send and receive data over the serial terminal interface.\012\015\012\015"
  00f4 ac000170 [8]             CALL  AppTask:368
  294:            /*print a message on the LCD also*/
  295:            LCD_ClearDisplay();
  296:            LCD_WriteString(1,"Ready to send");
  297:            LCD_WriteString(2,"and receive data");    
  298:            gState = stateListen;
  00f8 a605     [2]             LDA   #5
  00fa          LFA:    
  00fa c70000   [4]             STA   gState
  299:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  00fd c60000   [4]             LDA   gAppTaskID_c
  0100 ae01     [2]             LDX   #1
  0102          L102:   
  0102 8c       [1]             CLRH  
  0103 ac000000 [8]             CALL  TS_SendEvent
  0107 201b     [3]             BRA   L124 ;abs = 0124
  0109          L109:   
  300:          }
  301:        }
  302:      }
  303:      break; 
  304:      
  305:    case stateListen:
  306:      /* Stay in this state forever. 
  307:         Transmit the data received on serial terminal interface */
  308:      if (events & gAppEvtMessageFromMLME_c)
  0109 95       [2]             TSX   
  010a e603     [3]             LDA   3,X
  010c a504     [2]             BIT   #4
  010e 2709     [3]             BEQ   L119 ;abs = 0119
  309:      {
  310:        /* Get the message from MLME */
  311:        if (pMsgIn)
  0110 9efe01   [5]             LDHX  1,SP
  0113 2704     [3]             BEQ   L119 ;abs = 0119
  312:        {      
  313:          /* Process it */
  314:          ret = App_HandleMlmeInput(pMsgIn);
  0115 ac000000 [8]             CALL  App_HandleMlmeInput
  0119          L119:   
  315:          /* Messages from the MLME must always be freed. */
  316:        }
  317:      }
  318:  
  319:      if (events & gAppEvtRxFromComm_c)
  0119 95       [2]             TSX   
  011a e603     [3]             LDA   3,X
  011c a502     [2]             BIT   #2
  011e 2704     [3]             BEQ   L124 ;abs = 0124
  320:      {      
  321:        /* get byte from serial terminal interface */
  322:        App_TransmitCommData();
  0120 ac000000 [8]             CALL  App_TransmitCommData
  0124          L124:   
  323:      
  324:      }  
  325:      break;
  326:    }
  327:    
  328:    if (pMsgIn)
  0124 9efe01   [5]             LDHX  1,SP
  0127 2704     [3]             BEQ   L12D ;abs = 012d
  329:    {
  330:      /* Messages must always be freed. */ 
  331:      MSG_Free(pMsgIn);
  0129 ac000000 [8]             CALL  MM_Free
  012d          L12D:   
  332:    }
  333:    
  334:    if (events & gAppEvtMessageFromMCPS_c)
  012d 95       [2]             TSX   
  012e e603     [3]             LDA   3,X
  0130 a508     [2]             BIT   #8
  0132 271b     [3]             BEQ   L14F ;abs = 014f
  335:    {      
  336:       /* Get the message from MCPS */
  337:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  0134 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0137 ac000000 [8]             CALL  List_RemoveHead
  338:      if (pMsgIn)
  013b 650000   [3]             CPHX  #0
  013e 270f     [3]             BEQ   L14F ;abs = 014f
  339:      {
  340:        /* Process it */
  341:        App_HandleMcpsInput(pMsgIn);
  0140 89       [2]             PSHX  
  0141 8b       [2]             PSHH  
  0142 ac000000 [8]             CALL  App_HandleMcpsInput
  342:        /* Messages from the MCPS must always be freed. */
  343:        MSG_Free(pMsgIn);
  0146 9efe01   [5]             LDHX  1,SP
  0149 ac000000 [8]             CALL  MM_Free
  014d a702     [2]             AIS   #2
  014f          L14F:   
  344:      }
  345:    }  
  346:    
  347:    
  348:    /* Check for pending messages in the Queue */ 
  349:    if(MSG_Pending(&mMcpsNwkInputQueue))
  014f 320000   [5]             LDHX  mMcpsNwkInputQueue
  0152 270a     [3]             BEQ   L15E ;abs = 015e
  350:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0154 c60000   [4]             LDA   gAppTaskID_c
  0157 ae08     [2]             LDX   #8
  0159 8c       [1]             CLRH  
  015a ac000000 [8]             CALL  TS_SendEvent
  015e          L15E:   
  351:    if(MSG_Pending(&mMlmeNwkInputQueue))
  015e 320000   [5]             LDHX  mMlmeNwkInputQueue
  0161 270a     [3]             BEQ   L16D ;abs = 016d
  352:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0163 c60000   [4]             LDA   gAppTaskID_c
  0166 ae04     [2]             LDX   #4
  0168 8c       [1]             CLRH  
  0169 ac000000 [8]             CALL  TS_SendEvent
  016d          L16D:   
  353:  }
  016d a704     [2]             AIS   #4
  016f 8d       [7]             RTC   
  0170          L170:   
  0170 a601     [2]             LDA   #1
  0172 ac000000 [8]             CALL  CommUtil_Print
  0176 8d       [7]             RTC   
  0177          L177:   
  0177 89       [2]             PSHX  
  0178 8b       [2]             PSHH  
  0179 ae02     [2]             LDX   #2
  017b 4f       [1]             CLRA  
  017c ac000000 [8]             CALL  CommUtil_PrintHex
  0180 a702     [2]             AIS   #2
  0182 8d       [7]             RTC   
  354:  
  355:  
  356:  
  357:  /************************************************************************************
  358:  *************************************************************************************
  359:  * Private functions
  360:  *************************************************************************************
  361:  ************************************************************************************/
  362:  
  363:  /*****************************************************************************
  364:  * App_CommRxCallBack
  365:  *
  366:  * This callback is triggered when a new byte is received over the Serial Interface
  367:  *
  368:  *****************************************************************************/
  369:  static void App_CommRxCallBack(void) 
  370:  {
  0000 8b       [2]             PSHH  
  371:    uint8_t pressedKey;
  372:  	if(stateListen == gState){
  0001 c60000   [4]             LDA   gState
  0004 a105     [2]             CMP   #5
  0006 260c     [3]             BNE   L14 ;abs = 0014
  373:      TS_SendEvent(gAppTaskID_c, gAppEvtRxFromComm_c);
  0008 c60000   [4]             LDA   gAppTaskID_c
  000b ae02     [2]             LDX   #2
  000d 8c       [1]             CLRH  
  000e ac000000 [8]             CALL  TS_SendEvent
  374:    }else{
  375:  	  (void)Comm_GetByteFromRxBuffer(&pressedKey);
  376:    }
  377:  }
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 95       [2]             TSX   
  0015 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0019 8a       [3]             PULH  
  001a 8d       [7]             RTC   
  378:  
  379:  /******************************************************************************
  380:  * The App_StartScan(scanType) function will start the scan process of the
  381:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  382:  * which is then assigned the desired scan parameters and sent to the MLME
  383:  * service access point.
  384:  * The function may return either of the following values:
  385:  *   errorNoError:          The Scan message was sent successfully.
  386:  *   errorInvalidParameter: The MLME service access point rejected the
  387:  *                          message due to an invalid parameter.
  388:  *   errorAllocFailed:      A message buffer could not be allocated.
  389:  *
  390:  ******************************************************************************/
  391:  static uint8_t App_StartScan(uint8_t scanType)
  392:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  393:    mlmeMessage_t *pMsg;
  394:    mlmeScanReq_t *pScanReq;
  395:  
  396:    CommUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000058 [8]             CALL  App_StartScan:88
  397:  
  398:    /* Allocate a message for the MLME (We should check for NULL). */
  399:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a623     [2]             LDA   #35
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  400:    if(pMsg != NULL)
  0013 2737     [3]             BEQ   L4C ;abs = 004c
  401:    {
  402:      /* This is a MLME-SCAN.req command */
  403:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  404:      /* Create the Scan request message data. */
  405:      pScanReq = &pMsg->msgData.scanReq;
  406:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  407:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  408:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  409:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  410:      /* ChannelsToScan>>8 & 0xFF  */
  411:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f 6f03     [5]             CLR   3,X
  412:      /* ChannelsToScan>>16 & 0xFF  */
  413:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0021 6f04     [5]             CLR   4,X
  414:      /* ChannelsToScan>>24 & 0xFF - MSB */
  415:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0023 a601     [2]             LDA   #1
  0025 e705     [3]             STA   5,X
  416:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  417:         A scan duration of 3 on 16 channels approximately takes 2 secs. */
  418:      pScanReq->scanDuration = 3;
  0027 a603     [2]             LDA   #3
  0029 e706     [3]             STA   6,X
  419:  #ifdef gMAC2006_d
  420:      pScanReq->securityLevel = 0;
  002b 6f07     [5]             CLR   7,X
  421:  #endif //gMAC2006_d    
  422:      
  423:      /* Send the Scan request to the MLME. */
  424:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002d 9efe01   [5]             LDHX  1,SP
  0030 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0034 4d       [1]             TSTA  
  0035 260a     [3]             BNE   L41 ;abs = 0041
  425:      {
  426:        CommUtil_Print("Done\n\r", gAllowToBlock_d);
  0037 450000   [3]             LDHX  @"Done\012\015"
  003a ac000058 [8]             CALL  App_StartScan:88
  427:        return errorNoError;
  003e 4f       [1]             CLRA  
  003f 2014     [3]             BRA   L55 ;abs = 0055
  0041          L41:    
  428:      }
  429:      else
  430:      {
  431:        CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0041 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0044 ac000058 [8]             CALL  App_StartScan:88
  432:        return errorInvalidParameter;
  0048 a605     [2]             LDA   #5
  004a 2009     [3]             BRA   L55 ;abs = 0055
  004c          L4C:    
  433:      }
  434:    }
  435:    else
  436:    {
  437:      /* Allocation of a message buffer failed. */
  438:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  004c 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004f ac000058 [8]             CALL  App_StartScan:88
  439:      return errorAllocFailed;
  0053 a604     [2]             LDA   #4
  0055          L55:    
  440:    }
  441:  }
  0055 a703     [2]             AIS   #3
  0057 8d       [7]             RTC   
  0058          L58:    
  0058 a601     [2]             LDA   #1
  005a ac000000 [8]             CALL  CommUtil_Print
  005e 8d       [7]             RTC   
  442:  
  443:  
  444:  /******************************************************************************
  445:  * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
  446:  * ED scan confirm message received from the MLME when the ED scan has completed.
  447:  * The message contains the ED scan result list. This function will search the
  448:  * list in order to select the logical channel with the least energy. The
  449:  * selected channel is stored in the global variable called 'mLogicalChannel'.
  450:  *
  451:  ******************************************************************************/
  452:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
  453:  {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
  454:    uint8_t n, minEnergy;
  455:    uint8_t *pEdList;
  456:    uint8_t ChannelMask;
  457:  
  458:    CommUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Received the MLME-Scan Confirm message from the MAC\012\015"
  0007 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  459:      
  460:    /* Get a pointer to the energy detect results */
  461:    pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
  000b 9efe06   [5]             LDHX  6,SP
  000e 9ece08   [5]             LDHX  8,X
  0011 9eff03   [5]             STHX  3,SP
  462:    
  463:    /* Set the minimum energy to a large value */
  464:    minEnergy = 0xFF;
  0014 a6ff     [2]             LDA   #-1
  0016 95       [2]             TSX   
  0017 e704     [3]             STA   4,X
  465:  
  466:    /* Select default channel */
  467:    mLogicalChannel = 11;
  0019 a60b     [2]             LDA   #11
  001b c70000   [4]             STA   mLogicalChannel
  468:   
  469:    /* Search for the channel with least energy */
  470:    for(n=0; n<16; n++)
  001e 6f01     [5]             CLR   1,X
  0020          L20:    
  471:    {
  472:      ChannelMask = n + 11;
  0020 95       [2]             TSX   
  0021 e601     [3]             LDA   1,X
  0023 ab0b     [2]             ADD   #11
  473:  	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
  0025 f7       [2]             STA   ,X
  0026 e601     [3]             LDA   1,X
  0028 eb03     [3]             ADD   3,X
  002a 87       [2]             PSHA  
  002b 4f       [1]             CLRA  
  002c e902     [3]             ADC   2,X
  002e 87       [2]             PSHA  
  002f e604     [3]             LDA   4,X
  0031 8a       [3]             PULH  
  0032 88       [3]             PULX  
  0033 f1       [3]             CMP   ,X
  0034 232e     [3]             BLS   L64 ;abs = 0064
  0036 4f       [1]             CLRA  
  0037 450100   [3]             LDHX  #256
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f e604     [3]             LDA   4,X
  0041 cd0000   [6]             JSR   _LLSR
  0044 9ee604   [4]             LDA   4,SP
  0047 a501     [2]             BIT   #1
  0049 a708     [2]             AIS   #8
  004b 2717     [3]             BEQ   L64 ;abs = 0064
  474:      {
  475:        minEnergy = pEdList[n];
  004d e605     [3]             LDA   5,X
  004f eb07     [3]             ADD   7,X
  0051 87       [2]             PSHA  
  0052 4f       [1]             CLRA  
  0053 e906     [3]             ADC   6,X
  0055 87       [2]             PSHA  
  0056 8a       [3]             PULH  
  0057 88       [3]             PULX  
  0058 fe       [3]             LDX   ,X
  0059 9eef05   [4]             STX   5,SP
  476:        /* Channel numbering is 11 to 26 both inclusive */
  477:        mLogicalChannel = n + 11; 
  005c 95       [2]             TSX   
  005d e601     [3]             LDA   1,X
  005f ab0b     [2]             ADD   #11
  0061 c70000   [4]             STA   mLogicalChannel
  0064          L64:    
  0064 95       [2]             TSX   
  0065 6c01     [5]             INC   1,X
  0067 e601     [3]             LDA   1,X
  0069 a110     [2]             CMP   #16
  006b 25b3     [3]             BCS   L20 ;abs = 0020
  478:      }
  479:    }
  480:    
  481:    /* Print out the result of the ED scan */
  482:    CommUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
  006d 450000   [3]             LDHX  @"ED scan returned the following results:\012\015  ["
  0070 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  483:    CommUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
  0074 9efe03   [5]             LDHX  3,SP
  0077 89       [2]             PSHX  
  0078 8b       [2]             PSHH  
  0079 ae10     [2]             LDX   #16
  007b a609     [2]             LDA   #9
  007d ac000000 [8]             CALL  CommUtil_PrintHex
  0081 a702     [2]             AIS   #2
  484:    CommUtil_Print("]\n\r\n\r", gAllowToBlock_d);
  0083 450000   [3]             LDHX  @"]\012\015\012\015"
  0086 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  485:    
  486:    /* Print out the selected logical channel */
  487:    CommUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
  008a 450000   [3]             LDHX  @"Based on the ED scan the logical channel 0x"
  008d ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  488:    CommUtil_PrintHex(&mLogicalChannel, 1, 0);
  0091 450000   [3]             LDHX  @mLogicalChannel
  0094 89       [2]             PSHX  
  0095 8b       [2]             PSHH  
  0096 ae01     [2]             LDX   #1
  0098 4f       [1]             CLRA  
  0099 ac000000 [8]             CALL  CommUtil_PrintHex
  009d a702     [2]             AIS   #2
  489:    CommUtil_Print(" was selected\n\r", gAllowToBlock_d);
  009f 450000   [3]             LDHX  @" was selected\012\015"
  00a2 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  490:    
  491:    /* The list of detected energies must be freed. */
  492:    MSG_Free(pEdList);
  00a6 9efe03   [5]             LDHX  3,SP
  00a9 ac000000 [8]             CALL  MM_Free
  493:  }
  00ad a707     [2]             AIS   #7
  00af 8d       [7]             RTC   
  00b0          LB0:    
  00b0 a601     [2]             LDA   #1
  00b2 ac000000 [8]             CALL  CommUtil_Print
  00b6 8d       [7]             RTC   
  494:  
  495:  /******************************************************************************
  496:  * The App_StartScan(scanType) function will start the scan process of the
  497:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  498:  * which is then assigned the desired scan parameters and sent to the MLME
  499:  * service access point. The MAC PIB attributes "macShortAddress", and 
  500:  * "macAssociatePermit" are modified.
  501:  *
  502:  * The function may return either of the following values:
  503:  *   errorNoError:          The Scan message was sent successfully.
  504:  *   errorInvalidParameter: The MLME service access point rejected the
  505:  *                          message due to an invalid parameter.
  506:  *   errorAllocFailed:      A message buffer could not be allocated.
  507:  *
  508:  ******************************************************************************/
  509:  static uint8_t App_StartCoordinator(void)
  510:  {
  0000 a7fb     [2]             AIS   #-5
  511:    /* Message for the MLME will be allocated and attached to this pointer */
  512:    mlmeMessage_t *pMsg;
  513:  
  514:    CommUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Start Request message to the MAC..."
  0005 ac0000af [8]             CALL  App_StartCoordinator:175
  515:    
  516:    /* Allocate a message for the MLME (We should check for NULL). */
  517:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a623     [2]             LDA   #35
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff01   [5]             STHX  1,SP
  518:    if(pMsg != NULL)
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00a3   [4]             JMP   LA3 ;abs = 00a3
  0017          L17:    
  519:    {
  520:      /* Pointer which is used for easy access inside the allocated message */
  521:      mlmeStartReq_t *pStartReq;
  522:      /* Return value from MSG_send - used for avoiding compiler warnings */
  523:      uint8_t ret;
  524:      /* Boolean value that will be written to the MAC PIB */
  525:      uint8_t boolFlag;
  526:      
  527:      /* Set-up MAC PIB attributes. Please note that Set, Get,
  528:         and Reset messages are not freed by the MLME. */
  529:      
  530:      /* We must always set the short address to something
  531:         else than 0xFFFF before starting a PAN. */
  532:      pMsg->msgType = gMlmeSetReq_c;
  0017 a609     [2]             LDA   #9
  0019 f7       [2]             STA   ,X
  533:      pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
  001a a653     [2]             LDA   #83
  001c e701     [3]             STA   1,X
  534:      pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
  001e a600     [2]             LDA   @maShortAddress:MSB
  0020 e703     [3]             STA   3,X
  0022 a600     [2]             LDA   @maShortAddress
  0024 e704     [3]             STA   4,X
  535:      ret = MSG_Send(NWK_MLME, pMsg);
  0026 89       [2]             PSHX  
  0027 8b       [2]             PSHH  
  0028 ac000000 [8]             CALL  NWK_MLME_SapHandler
  536:      
  537:      /* We must set the Association Permit flag to TRUE 
  538:         in order to allow devices to associate to us. */
  539:      pMsg->msgType = gMlmeSetReq_c;
  002c 9efe01   [5]             LDHX  1,SP
  002f a609     [2]             LDA   #9
  0031 f7       [2]             STA   ,X
  540:      pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
  0032 a641     [2]             LDA   #65
  0034 e701     [3]             STA   1,X
  541:      boolFlag = TRUE;
  0036 a601     [2]             LDA   #1
  0038 95       [2]             TSX   
  0039 e704     [3]             STA   4,X
  542:      pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
  003b af04     [2]             AIX   #4
  003d 8b       [2]             PSHH  
  003e 9ee602   [4]             LDA   2,SP
  0041 87       [2]             PSHA  
  0042 8a       [3]             PULH  
  0043 9f       [1]             TXA   
  0044 9eee03   [4]             LDX   3,SP
  0047 e704     [3]             STA   4,X
  0049 86       [3]             PULA  
  004a e703     [3]             STA   3,X
  543:      ret = MSG_Send(NWK_MLME, pMsg);
  004c ac000000 [8]             CALL  NWK_MLME_SapHandler
  544:      
  545:      /* This is a MLME-START.req command */
  546:      pMsg->msgType = gMlmeStartReq_c;
  0050 9efe03   [5]             LDHX  3,SP
  0053 a60a     [2]             LDA   #10
  0055 f7       [2]             STA   ,X
  547:      
  548:      /* Create the Start request message data. */
  549:      pStartReq = &pMsg->msgData.startReq;
  0056 af01     [2]             AIX   #1
  0058 9eff06   [5]             STHX  6,SP
  550:      /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
  551:      FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maPanId
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
  552:      /* Logical Channel - the default of 11 will be overridden */
  553:      pStartReq->logicalChannel = mLogicalChannel;
  0068 9efe06   [5]             LDHX  6,SP
  006b c60000   [4]             LDA   mLogicalChannel
  006e e702     [3]             STA   2,X
  554:      /* Beacon Order - 0xF = turn off beacons */
  555:      pStartReq->beaconOrder = 0x0F;  
  0070 a60f     [2]             LDA   #15
  0072 e707     [3]             STA   7,X
  556:      /* Superframe Order - 0xF = turn off beacons */
  557:      pStartReq->superFrameOrder = 0x0F;
  0074 e708     [3]             STA   8,X
  558:      /* Be a PAN coordinator */
  559:      pStartReq->panCoordinator = TRUE;
  0076 a601     [2]             LDA   #1
  0078 e709     [3]             STA   9,X
  560:      /* Dont use battery life extension */
  561:      pStartReq->batteryLifeExt = FALSE;
  007a 6f0a     [5]             CLR   10,X
  562:      /* This is not a Realignment command */
  563:      pStartReq->coordRealignment = FALSE;
  007c 6f0b     [5]             CLR   11,X
  564:      /* Dont use security */
  565:  #ifndef gMAC2006_d    
  566:      pStartReq->securityEnable = FALSE;
  567:  #else
  568:      pStartReq->coordRealignSecurityLevel = 0;
  007e 6f0c     [5]             CLR   12,X
  569:      pStartReq->beaconSecurityLevel = 0;
  0080 6f17     [5]             CLR   23,X
  570:  #endif //gMAC2006_d        
  571:        
  572:      /* Send the Start request to the MLME. */
  573:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a a702     [2]             AIS   #2
  008c 260a     [3]             BNE   L98 ;abs = 0098
  574:      {
  575:        CommUtil_Print("Done\n\r", gAllowToBlock_d);
  008e 450000   [3]             LDHX  @"Done\012\015"
  0091 ac0000af [8]             CALL  App_StartCoordinator:175
  576:        return errorNoError;
  0095 4f       [1]             CLRA  
  0096 2014     [3]             BRA   LAC ;abs = 00ac
  0098          L98:    
  577:      }
  578:      else
  579:      {
  580:        /* One or more parameters in the Start Request message were invalid. */
  581:        CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0098 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  009b ac0000af [8]             CALL  App_StartCoordinator:175
  582:        return errorInvalidParameter;
  009f a605     [2]             LDA   #5
  00a1 2009     [3]             BRA   LAC ;abs = 00ac
  00a3          LA3:    
  583:      }
  584:    }
  585:    else
  586:    {
  587:      /* Allocation of a message buffer failed. */
  588:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a3 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a6 ac0000af [8]             CALL  App_StartCoordinator:175
  589:      return errorAllocFailed;
  00aa a604     [2]             LDA   #4
  00ac          LAC:    
  590:    }
  591:  }
  00ac a705     [2]             AIS   #5
  00ae 8d       [7]             RTC   
  00af          LAF:    
  00af a601     [2]             LDA   #1
  00b1 ac000000 [8]             CALL  CommUtil_Print
  00b5 8d       [7]             RTC   
  592:  
  593:  /******************************************************************************
  594:  * The App_SendAssociateResponse(nwkMessage_t *pMsgIn) will create the response
  595:  * message to an Associate Indication (device sends an Associate Request to its
  596:  * MAC. The request is transmitted to the coordinator where it is converted into
  597:  * an Associate Indication). This function will extract the devices long address,
  598:  * and various other flags from the incoming indication message for building the
  599:  * response message.
  600:  *
  601:  * The function may return either of the following values:
  602:  *   errorNoError:          The Associate Response message was sent successfully.
  603:  *   errorInvalidParameter: The MLME service access point rejected the
  604:  *                          message due to an invalid parameter.
  605:  *   errorAllocFailed:      A message buffer could not be allocated.
  606:  *
  607:  ******************************************************************************/
  608:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn)
  609:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7f6     [2]             AIS   #-10
  610:    mlmeMessage_t *pMsg;
  611:    mlmeAssociateRes_t *pAssocRes;
  612:    uint16_t i;
  613:    uint8_t FoundFlag = 0;
  0004 95       [2]             TSX   
  0005 6f05     [5]             CLR   5,X
  614:   
  615:    CommUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0007 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  000a ac000201 [8]             CALL  App_SendAssociateResponse:513
  616:   
  617:    /* Allocate a message for the MLME */
  618:    pMsg = MSG_AllocType(mlmeMessage_t);
  000e a623     [2]             LDA   #35
  0010 ac000000 [8]             CALL  MM_Alloc
  0014 9eff07   [5]             STHX  7,SP
  619:    if(pMsg != NULL)
  0017 2603     [3]             BNE   L1C ;abs = 001c
  0019 cc01f5   [4]             JMP   L1F5 ;abs = 01f5
  001c          L1C:    
  620:    {
  621:      /* This is a MLME-ASSOCIATE.res command */
  622:      pMsg->msgType = gMlmeAssociateRes_c;
  001c a601     [2]             LDA   #1
  001e f7       [2]             STA   ,X
  623:      
  624:      /* Create the Associate response message data. */
  625:      pAssocRes = &pMsg->msgData.associateRes;
  001f af01     [2]             AIX   #1
  0021 9eff04   [5]             STHX  4,SP
  626:      
  627:      /* Assign a short address to the device. In this example we simply
  628:         choose 0x0001. Though, all devices and coordinators in a PAN must have
  629:         different short addresses. However, if a device do not want to use 
  630:         short addresses at all in the PAN, a short address of 0xFFFE must
  631:         be assigned to it. */
  632:  
  633:        /* Check if ED requester was already registered */
  634:  
  635:        for (i = 0; i < AssocDevCounter; ++i)
  0024 95       [2]             TSX   
  0025 6f02     [5]             CLR   2,X
  0027 6f01     [5]             CLR   1,X
  0029 2029     [3]             BRA   L54 ;abs = 0054
  002b          L2B:    
  636:        {
  637:          /* If ED was already registered associate the same address and set the flag */
  638:          if(FLib_MemCmp(AssociatedDevices[i].ExtendedAddress,pMsgIn->msgData.associateInd.deviceAddress,8)){
  002b 95       [2]             TSX   
  002c e602     [3]             LDA   2,X
  002e ae0c     [2]             LDX   #12
  0030 42       [5]             MUL   
  0031 ab02     [2]             ADD   @AssociatedDevices:2
  0033 87       [2]             PSHA  
  0034 4f       [1]             CLRA  
  0035 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0037 87       [2]             PSHA  
  0038 9efe0d   [5]             LDHX  13,SP
  003b af01     [2]             AIX   #1
  003d a608     [2]             LDA   #8
  003f ac000000 [8]             CALL  FLib_MemCmp
  0043 a702     [2]             AIS   #2
  0045 4d       [1]             TSTA  
  0046 2705     [3]             BEQ   L4D ;abs = 004d
  639:            FoundFlag++;
  0048 95       [2]             TSX   
  0049 6c05     [5]             INC   5,X
  640:            break;
  004b 200f     [3]             BRA   L5C ;abs = 005c
  004d          L4D:    
  004d 95       [2]             TSX   
  004e 6c02     [5]             INC   2,X
  0050 2602     [3]             BNE   L54 ;abs = 0054
  0052 6c01     [5]             INC   1,X
  0054          L54:    
  0054 320000   [5]             LDHX  AssocDevCounter
  0057 9ef302   [6]             CPHX  2,SP
  005a 22cf     [3]             BHI   L2B ;abs = 002b
  005c          L5C:    
  641:          }
  642:        }
  643:  
  644:        if(FoundFlag){
  005c 95       [2]             TSX   
  005d 6d05     [4]             TST   5,X
  005f 2743     [3]             BEQ   LA4 ;abs = 00a4
  645:          FLib_MemCpy(pAssocRes->assocShortAddress, AssociatedDevices[i].ShortAddress, 2);
  0061 9efe04   [5]             LDHX  4,SP
  0064 af08     [2]             AIX   #8
  0066 89       [2]             PSHX  
  0067 8b       [2]             PSHH  
  0068 95       [2]             TSX   
  0069 e604     [3]             LDA   4,X
  006b ae0c     [2]             LDX   #12
  006d 42       [5]             MUL   
  006e ab00     [2]             ADD   @AssociatedDevices
  0070 95       [2]             TSX   
  0071 e702     [3]             STA   2,X
  0073 4f       [1]             CLRA  
  0074 a900     [2]             ADC   @AssociatedDevices:MSB
  0076 ee02     [3]             LDX   2,X
  0078 87       [2]             PSHA  
  0079 8a       [3]             PULH  
  007a a602     [2]             LDA   #2
  007c ac000000 [8]             CALL  FLib_MemCpy
  0080 a702     [2]             AIS   #2
  646:          FLib_MemCpy(pAssocRes->deviceAddress, AssociatedDevices[i].ExtendedAddress, 8);
  0082 9efe04   [5]             LDHX  4,SP
  0085 89       [2]             PSHX  
  0086 8b       [2]             PSHH  
  0087 95       [2]             TSX   
  0088 e604     [3]             LDA   4,X
  008a ae0c     [2]             LDX   #12
  008c 42       [5]             MUL   
  008d ab02     [2]             ADD   @AssociatedDevices:2
  008f 95       [2]             TSX   
  0090 e702     [3]             STA   2,X
  0092 4f       [1]             CLRA  
  0093 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0095 ee02     [3]             LDX   2,X
  0097 87       [2]             PSHA  
  0098 8a       [3]             PULH  
  0099 a608     [2]             LDA   #8
  009b ac000000 [8]             CALL  FLib_MemCpy
  009f a702     [2]             AIS   #2
  647:  
  648:        }else{
  00a1 cc013d   [4]             JMP   L13D ;abs = 013d
  00a4          LA4:    
  649:  
  650:  
  651:          if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  00a4 9efe0b   [5]             LDHX  11,SP
  00a7 e614     [3]             LDA   20,X
  00a9 2a1c     [3]             BPL   LC7 ;abs = 00c7
  652:          {
  653:            /* Assign a unique short address less than 0xfffe if the device requests so. */
  654:            uint16_t tmpAddr = AssocDevCounter + 1;
  00ab 320000   [5]             LDHX  AssocDevCounter
  00ae af01     [2]             AIX   #1
  00b0 9eff09   [5]             STHX  9,SP
  655:            FLib_MemCpy(pAssocRes->assocShortAddress, &tmpAddr, 2);
  00b3 9efe04   [5]             LDHX  4,SP
  00b6 af08     [2]             AIX   #8
  00b8 89       [2]             PSHX  
  00b9 8b       [2]             PSHH  
  00ba 95       [2]             TSX   
  00bb af0a     [2]             AIX   #10
  00bd a602     [2]             LDA   #2
  00bf ac000000 [8]             CALL  FLib_MemCpy
  00c3 a702     [2]             AIS   #2
  656:          }
  00c5 200a     [3]             BRA   LD1 ;abs = 00d1
  00c7          LC7:    
  657:          else
  658:          {
  659:            /* A short address of 0xfffe means that the device is granted access to
  660:               the PAN (Associate successful) but that long addressing is used.*/
  661:            pAssocRes->assocShortAddress[0] = 0xFE;
  00c7 9efe04   [5]             LDHX  4,SP
  00ca a6fe     [2]             LDA   #-2
  00cc e708     [3]             STA   8,X
  662:            pAssocRes->assocShortAddress[1] = 0xFF;
  00ce 4c       [1]             INCA  
  00cf e709     [3]             STA   9,X
  00d1          LD1:    
  663:  
  664:          }
  665:  
  666:  
  667:          /* Get the 64 bit address of the device requesting association. */
  668:          FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  00d1 9efe04   [5]             LDHX  4,SP
  00d4 89       [2]             PSHX  
  00d5 8b       [2]             PSHH  
  00d6 9efe0d   [5]             LDHX  13,SP
  00d9 af01     [2]             AIX   #1
  00db a608     [2]             LDA   #8
  00dd ac000000 [8]             CALL  FLib_MemCpy
  00e1 a702     [2]             AIS   #2
  669:  
  670:          /* Save Short and Extended address inside the local array */
  671:          FLib_MemCpy(AssociatedDevices[AssocDevCounter].ShortAddress, pAssocRes->assocShortAddress, 2);
  00e3 c60001   [4]             LDA   AssocDevCounter:1
  00e6 ae0c     [2]             LDX   #12
  00e8 42       [5]             MUL   
  00e9 ab00     [2]             ADD   @AssociatedDevices
  00eb 87       [2]             PSHA  
  00ec 4f       [1]             CLRA  
  00ed a900     [2]             ADC   @AssociatedDevices:MSB
  00ef 87       [2]             PSHA  
  00f0 9efe06   [5]             LDHX  6,SP
  00f3 af08     [2]             AIX   #8
  00f5 a602     [2]             LDA   #2
  00f7 ac000000 [8]             CALL  FLib_MemCpy
  00fb a702     [2]             AIS   #2
  672:          FLib_MemCpy(AssociatedDevices[AssocDevCounter].ExtendedAddress, pAssocRes->deviceAddress, 8);
  00fd c60001   [4]             LDA   AssocDevCounter:1
  0100 ae0c     [2]             LDX   #12
  0102 42       [5]             MUL   
  0103 ab02     [2]             ADD   @AssociatedDevices:2
  0105 87       [2]             PSHA  
  0106 4f       [1]             CLRA  
  0107 a902     [2]             ADC   @AssociatedDevices:2:MSB
  0109 87       [2]             PSHA  
  010a 9efe06   [5]             LDHX  6,SP
  010d a608     [2]             LDA   #8
  010f ac000000 [8]             CALL  FLib_MemCpy
  0113 a702     [2]             AIS   #2
  673:          AssociatedDevices[AssocDevCounter].RxOnWhenIdle = pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoRxWhenIdle_c ? 0x1 : 0x0;
  0115 9efe0b   [5]             LDHX  11,SP
  0118 e614     [3]             LDA   20,X
  011a a508     [2]             BIT   #8
  011c 2602     [3]             BNE   L120 ;abs = 0120
  011e 4f       [1]             CLRA  
  011f 65       [3]             SKIP2 L122 ;abs = 0122
  0120          L120:   
  0120 a601     [2]             LDA   #1
  0122          L122:   
  0122 ac000208 [8]             CALL  App_SendAssociateResponse:520
  0126 d7000a   [4]             STA   @AssociatedDevices:10,X
  674:          AssociatedDevices[AssocDevCounter].DeviceType = pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoDeviceFfd_c ? 0x1 : 0x0;
  0129 9efe0b   [5]             LDHX  11,SP
  012c e614     [3]             LDA   20,X
  012e a502     [2]             BIT   #2
  0130 2602     [3]             BNE   L134 ;abs = 0134
  0132 4f       [1]             CLRA  
  0133 65       [3]             SKIP2 L136 ;abs = 0136
  0134          L134:   
  0134 a601     [2]             LDA   #1
  0136          L136:   
  0136 ac000208 [8]             CALL  App_SendAssociateResponse:520
  013a d7000b   [4]             STA   @AssociatedDevices:11,X
  013d          L13D:   
  675:          /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
  676:  
  677:        }
  678:  
  679:        pAssocRes->status = gSuccess_c;
  013d 9efe04   [5]             LDHX  4,SP
  0140 6f15     [5]             CLR   21,X
  680:        /* Do not use security */
  681:        #ifndef gMAC2006_d    
  682:            pAssocRes->securityEnable = FALSE;
  683:        #else
  684:            pAssocRes->securityLevel = 0;
  0142 6f0a     [5]             CLR   10,X
  685:        #endif //gMAC2006_d    
  686:            
  687:        
  688:        /* Send the Associate Response to the MLME. */
  689:        if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0144 9efe07   [5]             LDHX  7,SP
  0147 ac000000 [8]             CALL  NWK_MLME_SapHandler
  014b 4d       [1]             TSTA  
  014c 2703     [3]             BEQ   L151 ;abs = 0151
  014e cc01ea   [4]             JMP   L1EA ;abs = 01ea
  0151          L151:   
  690:        {
  691:          CommUtil_Print("Done\n\r", gAllowToBlock_d);
  0151 450000   [3]             LDHX  @"Done\012\015"
  0154 ac000201 [8]             CALL  App_SendAssociateResponse:513
  692:          
  693:          /* Print association information */
  694:          if(FoundFlag)
  0158 95       [2]             TSX   
  0159 6d05     [4]             TST   5,X
  015b 2709     [3]             BEQ   L166 ;abs = 0166
  695:            CommUtil_Print("\n\r************************************\n\r\n\rWelcome back old friend\n\rShort Address: 0x", gAllowToBlock_d);
  015d 450000   [3]             LDHX  @"\012\015************************************\012\015\012\015Welcome back old friend\012\015Short Address: 0x"
  0160 ac000201 [8]             CALL  App_SendAssociateResponse:513
  0164 200d     [3]             BRA   L173 ;abs = 0173
  0166          L166:   
  696:          else{
  697:            CommUtil_Print("\n\r************************************\n\r\n\rI see you are new, welcome!\n\rShort Address: 0x", gAllowToBlock_d);
  0166 450000   [3]             LDHX  @"\012\015************************************\012\015\012\015I see you are new, welcome!\012\015Short Address: 0x"
  0169 ac000201 [8]             CALL  App_SendAssociateResponse:513
  698:            i = AssocDevCounter;
  016d 320000   [5]             LDHX  AssocDevCounter
  0170 9eff02   [5]             STHX  2,SP
  0173          L173:   
  699:          }
  700:          CommUtil_PrintHex((uint8_t *)AssociatedDevices[i].ShortAddress, 2, 0);
  0173 95       [2]             TSX   
  0174 e602     [3]             LDA   2,X
  0176 ae0c     [2]             LDX   #12
  0178 42       [5]             MUL   
  0179 ab00     [2]             ADD   @AssociatedDevices
  017b 87       [2]             PSHA  
  017c 4f       [1]             CLRA  
  017d a900     [2]             ADC   @AssociatedDevices:MSB
  017f 87       [2]             PSHA  
  0180 ae02     [2]             LDX   #2
  0182 4f       [1]             CLRA  
  0183 ac000000 [8]             CALL  CommUtil_PrintHex
  0187 a702     [2]             AIS   #2
  701:          CommUtil_Print("\n\rLong Address: 0x", gAllowToBlock_d);
  0189 450000   [3]             LDHX  @"\012\015Long Address: 0x"
  018c ac000201 [8]             CALL  App_SendAssociateResponse:513
  702:          CommUtil_PrintHex((uint8_t *)AssociatedDevices[i].ExtendedAddress, 8, 0);
  0190 95       [2]             TSX   
  0191 e602     [3]             LDA   2,X
  0193 ae0c     [2]             LDX   #12
  0195 42       [5]             MUL   
  0196 ab02     [2]             ADD   @AssociatedDevices:2
  0198 87       [2]             PSHA  
  0199 4f       [1]             CLRA  
  019a a902     [2]             ADC   @AssociatedDevices:2:MSB
  019c 87       [2]             PSHA  
  019d ae08     [2]             LDX   #8
  019f 4f       [1]             CLRA  
  01a0 ac000000 [8]             CALL  CommUtil_PrintHex
  01a4 a702     [2]             AIS   #2
  703:          if(AssociatedDevices[i].RxOnWhenIdle)
  01a6 95       [2]             TSX   
  01a7 e602     [3]             LDA   2,X
  01a9 ae0c     [2]             LDX   #12
  01ab 42       [5]             MUL   
  01ac 8c       [1]             CLRH  
  01ad 97       [1]             TAX   
  01ae de000a   [4]             LDX   @AssociatedDevices:10,X
  01b1 2705     [3]             BEQ   L1B8 ;abs = 01b8
  704:            CommUtil_Print("\n\rRX On When Idle: Yes", gAllowToBlock_d);
  01b3 450000   [3]             LDHX  @"\012\015RX On When Idle: Yes"
  01b6 2003     [3]             BRA   L1BB ;abs = 01bb
  01b8          L1B8:   
  705:          else
  706:            CommUtil_Print("\n\rRX On When Idle: No", gAllowToBlock_d);
  01b8 450000   [3]             LDHX  @"\012\015RX On When Idle: No"
  01bb          L1BB:   
  01bb ac000201 [8]             CALL  App_SendAssociateResponse:513
  707:          if(AssociatedDevices[i].DeviceType)
  01bf 95       [2]             TSX   
  01c0 e602     [3]             LDA   2,X
  01c2 ae0c     [2]             LDX   #12
  01c4 42       [5]             MUL   
  01c5 8c       [1]             CLRH  
  01c6 97       [1]             TAX   
  01c7 de000b   [4]             LDX   @AssociatedDevices:11,X
  01ca 2705     [3]             BEQ   L1D1 ;abs = 01d1
  708:            CommUtil_Print("\n\rDevice Type: FFD", gAllowToBlock_d);
  01cc 450000   [3]             LDHX  @"\012\015Device Type: FFD"
  01cf 2003     [3]             BRA   L1D4 ;abs = 01d4
  01d1          L1D1:   
  709:          else
  710:            CommUtil_Print("\n\rDevice Type: RFD", gAllowToBlock_d);
  01d1 450000   [3]             LDHX  @"\012\015Device Type: RFD"
  01d4          L1D4:   
  01d4 ac000201 [8]             CALL  App_SendAssociateResponse:513
  711:          CommUtil_Print("\n\r\n\r************************************\n\r", gAllowToBlock_d);
  01d8 450000   [3]             LDHX  @"\012\015\012\015************************************\012\015"
  01db ac000201 [8]             CALL  App_SendAssociateResponse:513
  712:          
  713:          /* "SAVE" the new device by incrementing the counter */
  714:          AssocDevCounter++;
  01df 450000   [3]             LDHX  @AssocDevCounter
  01e2 6c01     [5]             INC   1,X
  01e4 2601     [3]             BNE   L1E7 ;abs = 01e7
  01e6 7c       [4]             INC   ,X
  01e7          L1E7:   
  715:          return errorNoError;
  01e7 4f       [1]             CLRA  
  01e8 2014     [3]             BRA   L1FE ;abs = 01fe
  01ea          L1EA:   
  716:        }
  717:        else
  718:        {
  719:          /* One or more parameters in the message were invalid. */
  720:          CommUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  01ea 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  01ed ac000201 [8]             CALL  App_SendAssociateResponse:513
  721:          return errorInvalidParameter;
  01f1 a605     [2]             LDA   #5
  01f3 2009     [3]             BRA   L1FE ;abs = 01fe
  01f5          L1F5:   
  722:        }
  723:      
  724:    }
  725:    else
  726:    {
  727:      /* Allocation of a message buffer failed. */
  728:      CommUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  01f5 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  01f8 ac000201 [8]             CALL  App_SendAssociateResponse:513
  729:      return errorAllocFailed;
  01fc a604     [2]             LDA   #4
  01fe          L1FE:   
  730:    }
  731:  }
  01fe a70c     [2]             AIS   #12
  0200 8d       [7]             RTC   
  0201          L201:   
  0201 a601     [2]             LDA   #1
  0203 ac000000 [8]             CALL  CommUtil_Print
  0207 8d       [7]             RTC   
  0208          L208:   
  0208 ce0001   [4]             LDX   AssocDevCounter:1
  020b 87       [2]             PSHA  
  020c a60c     [2]             LDA   #12
  020e 42       [5]             MUL   
  020f 8c       [1]             CLRH  
  0210 97       [1]             TAX   
  0211 86       [3]             PULA  
  0212 8d       [7]             RTC   
  732:  
  733:  /******************************************************************************
  734:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  735:  * messages from the MLME, e.g. (Dis)Associate Indication.
  736:  *
  737:  * The function may return either of the following values:
  738:  *   errorNoError:   The message was processed.
  739:  *   errorNoMessage: The message pointer is NULL.
  740:  ******************************************************************************/
  741:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  742:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  743:    if(pMsg == NULL)
  0002 650000   [3]             CPHX  #0
  0005 2604     [3]             BNE   LB ;abs = 000b
  744:      return errorNoMessage;
  0007 a603     [2]             LDA   #3
  0009 2025     [3]             BRA   L30 ;abs = 0030
  000b          LB:     
  745:    
  746:    /* Handle the incoming message. The type determines the sort of processing.*/
  747:    switch(pMsg->msgType) {
  000b f6       [3]             LDA   ,X
  000c 2706     [3]             BEQ   L14 ;abs = 0014
  000e a10c     [2]             CMP   #12
  0010 261d     [3]             BNE   L2F ;abs = 002f
  0012 2012     [3]             BRA   L26 ;abs = 0026
  0014          L14:    
  748:    case gNwkAssociateInd_c:
  749:      CommUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
  0014 450000   [3]             LDHX  @"Received an MLME-Associate Indication from the MAC\012\015"
  0017 a601     [2]             LDA   #1
  0019 ac000000 [8]             CALL  CommUtil_Print
  750:      /* A device sent us an Associate Request. We must send back a response.  */
  751:      return App_SendAssociateResponse(pMsg);
  001d 9efe01   [5]             LDHX  1,SP
  0020 ac000000 [8]             CALL  App_SendAssociateResponse
  0024 200a     [3]             BRA   L30 ;abs = 0030
  0026          L26:    
  752:      break;
  753:      
  754:    case gNwkCommStatusInd_c:
  755:      /* Sent by the MLME after the Association Response has been transmitted. */
  756:      CommUtil_Print("Received an MLME-Comm-Status Indication from the MAC\n\r", gAllowToBlock_d);
  0026 450000   [3]             LDHX  @"Received an MLME-Comm-Status Indication from the MAC\012\015"
  0029 a601     [2]             LDA   #1
  002b ac000000 [8]             CALL  CommUtil_Print
  002f          L2F:    
  757:      break;
  758:    }
  759:    return errorNoError;
  002f 4f       [1]             CLRA  
  0030          L30:    
  760:  }
  0030 a702     [2]             AIS   #2
  0032 8d       [7]             RTC   
  761:  
  762:  /******************************************************************************
  763:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
  764:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
  765:  *
  766:  ******************************************************************************/
  767:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
  768:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  769:  	uint8_t *btnValue;
  770:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2705     [3]             BEQ   LC ;abs = 000c
  0007 41010e   [4]             CBEQA #1,L18 ;abs = 0018
  000a 2009     [3]             BRA   L15 ;abs = 0015
  000c          LC:     
  771:    {
  772:      /* The MCPS-Data confirm is sent by the MAC to the network 
  773:         or application layer when data has been sent. */
  774:    case gMcpsDataCnf_c:
  775:      if(mcPendingPackets)
  000c c60000   [4]             LDA   mcPendingPackets
  000f 2704     [3]             BEQ   L15 ;abs = 0015
  776:        mcPendingPackets--;
  0011 450000   [3]             LDHX  @mcPendingPackets
  0014 7a       [4]             DEC   ,X
  0015          L15:    
  0015 cc00bc   [4]             JMP   LBC ;abs = 00bc
  0018          L18:    
  777:      break;
  778:    
  779:    case gMcpsDataInd_c:
  780:      /* The MCPS-Data indication is sent by the MAC to the network 
  781:         or application layer when data has been received. We simply 
  782:         copy the received data to the serial terminal interface. */
  783:  
  784:  
  785:  
  786:    /* NEWCODE: Check for Button Data */
  787:      if(FLib_MemCmp(pMsgIn->msgData.dataInd.pMsdu,"Counter:",8)){
  0018 9ece29   [5]             LDHX  41,X
  001b 89       [2]             PSHX  
  001c 8b       [2]             PSHH  
  001d 450000   [3]             LDHX  @"Counter:"
  0020 a608     [2]             LDA   #8
  0022 ac000000 [8]             CALL  FLib_MemCmp
  0026 a702     [2]             AIS   #2
  0028 4d       [1]             TSTA  
  0029 2603     [3]             BNE   L2E ;abs = 002e
  002b cc00be   [4]             JMP   LBE ;abs = 00be
  002e          L2E:    
  788:      	btnValue = (uint8_t *)pMsgIn->msgData.dataInd.pMsdu;
  002e 9efe03   [5]             LDHX  3,SP
  0031 9ece29   [5]             LDHX  41,X
  789:      	btnValue += 8;
  0034 af08     [2]             AIX   #8
  790:        TurnOffLeds();
  0036 89       [2]             PSHX  
  0037 8b       [2]             PSHH  
  0038 ac000000 [8]             CALL  LED_TurnOffAllLeds
  791:        switch(*btnValue){
  003c 8a       [3]             PULH  
  003d 88       [3]             PULX  
  003e f6       [3]             LDA   ,X
  003f a134     [2]             CMP   #52
  0041 221a     [3]             BHI   L5D ;abs = 005d
  0043 a031     [2]             SUB   #49
  0045 97       [1]             TAX   
  0046 4f       [1]             CLRA  
  0047 cd0000   [6]             JSR   _Jump_Table_Header_Offset
  004a 04               DC.B  4
  004b 11               DC.B  L5D
  004c 03               DC.B  L50
  004d 06               DC.B  L54
  004e 09               DC.B  L58
  004f 0b               DC.B  L5B
  0050          L50:    
  792:          case '1':
  793:           Led1On();
  0050 1100     [5]             BCLR  0,0
  794:          break;
  0052 2009     [3]             BRA   L5D ;abs = 005d
  0054          L54:    
  795:          case '2':
  796:           Led2On();
  0054 1900     [5]             BCLR  4,0
  797:          break;
  0056 2005     [3]             BRA   L5D ;abs = 005d
  0058          L58:    
  798:          case '3':
  799:           Led3On();
  0058 1106     [5]             BCLR  0,6
  800:          break;
  005a 65       [3]             SKIP2 L5D ;abs = 005d
  005b          L5B:    
  801:          case '4':
  802:           Led4On();
  005b 1306     [5]             BCLR  1,6
  005d          L5D:    
  803:          break;
  804:        }
  805:  
  806:        CommUtil_Print("Source Addres : 0x", gAllowToBlock_d);
  005d 450000   [3]             LDHX  @"Source Addres : 0x"
  0060 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  807:        CommUtil_PrintHex((uint8_t *)pMsgIn->msgData.dataInd.srcAddr, 2, 0);
  0064 9efe03   [5]             LDHX  3,SP
  0067 af0c     [2]             AIX   #12
  0069 89       [2]             PSHX  
  006a 8b       [2]             PSHH  
  006b ae02     [2]             LDX   #2
  006d 4f       [1]             CLRA  
  006e ac000000 [8]             CALL  CommUtil_PrintHex
  0072 a702     [2]             AIS   #2
  808:        CommUtil_Print("\r\n", gAllowToBlock_d);
  0074 450000   [3]             LDHX  @"\015\012"
  0077 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  809:        CommUtil_Print("Link Quality : 0x", gAllowToBlock_d);
  007b 450000   [3]             LDHX  @"Link Quality : 0x"
  007e ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  810:        CommUtil_PrintHex((uint8_t *)pMsgIn->msgData.dataInd.mpduLinkQuality, 1, 0);          
  0082 9efe03   [5]             LDHX  3,SP
  0085 e618     [3]             LDA   24,X
  0087 87       [2]             PSHA  
  0088 4f       [1]             CLRA  
  0089 87       [2]             PSHA  
  008a ae01     [2]             LDX   #1
  008c ac000000 [8]             CALL  CommUtil_PrintHex
  0090 a702     [2]             AIS   #2
  811:        CommUtil_Print("\r\n", gAllowToBlock_d);
  0092 450000   [3]             LDHX  @"\015\012"
  0095 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  812:        CommUtil_Print("Data : ", gAllowToBlock_d);
  0099 450000   [3]             LDHX  @"Data : "
  009c ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  813:        CommUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  00a0 9efe03   [5]             LDHX  3,SP
  00a3 9ece29   [5]             LDHX  41,X
  00a6 9eff01   [5]             STHX  1,SP
  00a9 9efe03   [5]             LDHX  3,SP
  00ac e617     [3]             LDA   23,X
  00ae 9efe01   [5]             LDHX  1,SP
  00b1 ac000000 [8]             CALL  CommUtil_Tx
  814:        CommUtil_Print("\r\n", gAllowToBlock_d);
  00b5 450000   [3]             LDHX  @"\015\012"
  00b8 ac0000d6 [8]             CALL  App_HandleMcpsInput:214
  00bc          LBC:    
  815:  
  816:      }else{
  00bc 2015     [3]             BRA   LD3 ;abs = 00d3
  00be          LBE:    
  817:        CommUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  00be 9efe03   [5]             LDHX  3,SP
  00c1 9ece29   [5]             LDHX  41,X
  00c4 9eff01   [5]             STHX  1,SP
  00c7 9efe03   [5]             LDHX  3,SP
  00ca e617     [3]             LDA   23,X
  00cc 9efe01   [5]             LDHX  1,SP
  00cf ac000000 [8]             CALL  CommUtil_Tx
  00d3          LD3:    
  818:      }
  819:      /* NEWCODE: Check for Button Data */
  820:      break;
  821:    }
  822:  }
  00d3 a704     [2]             AIS   #4
  00d5 8d       [7]             RTC   
  00d6          LD6:    
  00d6 a601     [2]             LDA   #1
  00d8 ac000000 [8]             CALL  CommUtil_Print
  00dc 8d       [7]             RTC   
  823:  
  824:  /******************************************************************************
  825:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
  826:  * the name implies, wait for a message, thus blocking the execution of the
  827:  * state machine. Instead the function analyzes the supplied message to determine
  828:  * whether or not the message is of the expected type.
  829:  * The function may return either of the following values:
  830:  *   errorNoError: The message was of the expected type.
  831:  *   errorNoMessage: The message pointer is NULL.
  832:  *   errorWrongConfirm: The message is not of the expected type.
  833:  *
  834:  ******************************************************************************/
  835:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
  836:  {
  837:    /* Do we have a message? If not, the exit with error code */
  838:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  839:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  840:  
  841:    /* Is it the expected message type? If not then exit with error code */
  842:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
  843:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
  844:  
  845:    /* Found the expected message. Return with success code */
  846:    return errorNoError;
  000e 4f       [1]             CLRA  
  847:  }
  000f 8d       [7]             RTC   
  848:  
  849:  /******************************************************************************
  850:  * The App_TransmitCommData() function will perform (single/multi buffered)
  851:  * data transmissions of data received by the serial terminal interface. Data could also come from
  852:  * other sources such as sensors etc. This is completely determined by the
  853:  * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
  854:  * number of packets pending for transmission in the MAC. A global variable
  855:  * is incremented each time a data packet is sent to the MCPS, and decremented
  856:  * when the corresponding MCPS-Data Confirm message is received. If the counter
  857:  * reaches the defined maximum no more data buffers are allocated until the
  858:  * counter is decreased below the maximum number of pending packets.
  859:  *
  860:  * The function uses the device information, that was stored when the device,
  861:  * associated to us, for building an MCPS-Data Request message. The message
  862:  * is sent to the MCPS service access point in the MAC.
  863:  ******************************************************************************/
  864:  static void App_TransmitCommData(void)
  865:  {   
  0000 a7fc     [2]             AIS   #-4
  866:    static uint8_t keysBuffer[mMaxKeysToReceive_c];
  867:    static uint8_t keysReceived = 0;
  868:    static char *appAck = "APP_ACK";
  869:    uint16_t i = 0;
  870:    /* get data from serial terminal interface */
  871:    if( keysReceived < mMaxKeysToReceive_c) 
  0002 c60000   [4]             LDA   keysReceived
  0005 a120     [2]             CMP   #32
  0007 2414     [3]             BCC   L1D ;abs = 001d
  872:    { 
  873:      if(Comm_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
  0009 ab00     [2]             ADD   @keysBuffer
  000b 87       [2]             PSHA  
  000c 4f       [1]             CLRA  
  000d a900     [2]             ADC   @keysBuffer:MSB
  000f 88       [3]             PULX  
  0010 87       [2]             PSHA  
  0011 8a       [3]             PULH  
  0012 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0016 4d       [1]             TSTA  
  0017 2704     [3]             BEQ   L1D ;abs = 001d
  874:      {
  875:      keysReceived++;
  0019 450000   [3]             LDHX  @keysReceived
  001c 7c       [4]             INC   ,X
  001d          L1D:    
  876:      }
  877:    }
  878:    /* Use multi buffering for increased TX performance. It does not really
  879:       have any effect at a UART baud rate of 19200bps but serves as an
  880:       example of how the throughput may be improved in a real-world 
  881:       application where the data rate is of concern. */
  882:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  001d c60000   [4]             LDA   mcPendingPackets
  0020 a102     [2]             CMP   #2
  0022 240e     [3]             BCC   L32 ;abs = 0032
  0024 320000   [5]             LDHX  mpPacket
  0027 2609     [3]             BNE   L32 ;abs = 0032
  883:    {
  884:      /* If the maximum number of pending data buffes is below maximum limit 
  885:         and we do not have a data buffer already then allocate one. */
  886:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  0029 a69c     [2]             LDA   #-100
  002b ac000000 [8]             CALL  MM_Alloc
  002f 960000   [5]             STHX  mpPacket
  0032          L32:    
  887:    }
  888:  
  889:    if(mpPacket != NULL)
  0032 320000   [5]             LDHX  mpPacket
  0035 2603     [3]             BNE   L3A ;abs = 003a
  0037 cc0133   [4]             JMP   L133 ;abs = 0133
  003a          L3A:    
  890:    {
  891:  
  892:        for (i = 0; i < AssocDevCounter; ++i)
  003a 95       [2]             TSX   
  003b 6f03     [5]             CLR   3,X
  003d 6f02     [5]             CLR   2,X
  003f cc0128   [4]             JMP   L128 ;abs = 0128
  0042          L42:    
  893:        {
  894:  
  895:          if(!AssociatedDevices[i].DeviceType){
  0042 95       [2]             TSX   
  0043 e603     [3]             LDA   3,X
  0045 ae0c     [2]             LDX   #12
  0047 42       [5]             MUL   
  0048 95       [2]             TSX   
  0049 f7       [2]             STA   ,X
  004a 8c       [1]             CLRH  
  004b 97       [1]             TAX   
  004c de000b   [4]             LDX   @AssociatedDevices:11,X
  004f 2628     [3]             BNE   L79 ;abs = 0079
  896:            genericDataTransfer((uint8_t *)appAck, 7,AssociatedDevices[i] );
  0051 320000   [5]             LDHX  appAck
  0054 89       [2]             PSHX  
  0055 8b       [2]             PSHH  
  0056 a607     [2]             LDA   #7
  0058 87       [2]             PSHA  
  0059 95       [2]             TSX   
  005a e603     [3]             LDA   3,X
  005c ab00     [2]             ADD   @AssociatedDevices
  005e e703     [3]             STA   3,X
  0060 4f       [1]             CLRA  
  0061 a900     [2]             ADC   @AssociatedDevices:MSB
  0063 87       [2]             PSHA  
  0064 8a       [3]             PULH  
  0065 a7f4     [2]             AIS   #-12
  0067 95       [2]             TSX   
  0068 89       [2]             PSHX  
  0069 8b       [2]             PSHH  
  006a 87       [2]             PSHA  
  006b ee0f     [3]             LDX   15,X
  006d 8a       [3]             PULH  
  006e a60c     [2]             LDA   #12
  0070 cd0000   [6]             JSR   _COPY
  0073 ac000000 [8]             CALL  genericDataTransfer
  0077 a70f     [2]             AIS   #15
  0079          L79:    
  897:          }
  898:  
  899:  
  900:                /* get data from serial terminal interface */        
  901:          mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  0079 320000   [5]             LDHX  mpPacket
  007c af27     [2]             AIX   #39
  007e 9f       [1]             TXA   
  007f 8b       [2]             PSHH  
  0080 320000   [5]             LDHX  mpPacket
  0083 e726     [3]             STA   38,X
  0085 86       [3]             PULA  
  0086 e725     [3]             STA   37,X
  902:          FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) keysBuffer, keysReceived);
  0088 9ece25   [5]             LDHX  37,X
  008b 89       [2]             PSHX  
  008c 8b       [2]             PSHH  
  008d 450000   [3]             LDHX  @keysBuffer
  0090 c60000   [4]             LDA   keysReceived
  0093 ac000000 [8]             CALL  FLib_MemCpy
  0097 a702     [2]             AIS   #2
  903:  
  904:          /* Data was available in the serial terminal interface receive buffer. Now create an
  905:             MCPS-Data Request message containing the serial terminal interface data. */
  906:          mpPacket->msgType = gMcpsDataReq_c;
  0099 320000   [5]             LDHX  mpPacket
  009c 7f       [4]             CLR   ,X
  907:          /* Create the header using device information stored when creating 
  908:             the association response. In this simple example the use of short
  909:             addresses is hardcoded. In a real world application we must be
  910:             flexible, and use the address mode required by the given situation. */
  911:          FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, AssociatedDevices[i].ShortAddress, 2);
  009d af01     [2]             AIX   #1
  009f 89       [2]             PSHX  
  00a0 8b       [2]             PSHH  
  00a1 95       [2]             TSX   
  00a2 e605     [3]             LDA   5,X
  00a4 ae0c     [2]             LDX   #12
  00a6 42       [5]             MUL   
  00a7 95       [2]             TSX   
  00a8 e702     [3]             STA   2,X
  00aa ab00     [2]             ADD   @AssociatedDevices
  00ac e703     [3]             STA   3,X
  00ae 4f       [1]             CLRA  
  00af a900     [2]             ADC   @AssociatedDevices:MSB
  00b1 ee03     [3]             LDX   3,X
  00b3 87       [2]             PSHA  
  00b4 8a       [3]             PULH  
  00b5 a602     [2]             LDA   #2
  00b7 ac000000 [8]             CALL  FLib_MemCpy
  00bb a702     [2]             AIS   #2
  912:          FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  00bd 320000   [5]             LDHX  mpPacket
  00c0 af0c     [2]             AIX   #12
  00c2 89       [2]             PSHX  
  00c3 8b       [2]             PSHH  
  00c4 450000   [3]             LDHX  @maShortAddress
  00c7 a602     [2]             LDA   #2
  00c9 ac000000 [8]             CALL  FLib_MemCpy
  00cd a702     [2]             AIS   #2
  913:          FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  00cf 320000   [5]             LDHX  mpPacket
  00d2 af09     [2]             AIX   #9
  00d4 ac000145 [8]             CALL  App_TransmitCommData:325
  914:          FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  00d8 320000   [5]             LDHX  mpPacket
  00db af14     [2]             AIX   #20
  00dd ac000145 [8]             CALL  App_TransmitCommData:325
  915:          mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  00e1 a602     [2]             LDA   #2
  00e3 320000   [5]             LDHX  mpPacket
  00e6 e70b     [3]             STA   11,X
  916:          mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  00e8 e716     [3]             STA   22,X
  917:          mpPacket->msgData.dataReq.msduLength = keysReceived;
  00ea c60000   [4]             LDA   keysReceived
  00ed e717     [3]             STA   23,X
  918:          
  919:  
  920:          /* Transfer Options in case of FFD / RFD */
  921:          if(AssociatedDevices[i].DeviceType)
  00ef 8c       [1]             CLRH  
  00f0 9eee01   [4]             LDX   1,SP
  00f3 d6000b   [4]             LDA   @AssociatedDevices:11,X
  00f6 2703     [3]             BEQ   LFB ;abs = 00fb
  922:            /* Request MAC level acknowledgement of the data packet */
  923:            mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c;         /* Direct Transfer for FFD Device */
  00f8 a601     [2]             LDA   #1
  00fa 65       [3]             SKIP2 LFD ;abs = 00fd
  00fb          LFB:    
  924:          else
  925:            /* Request MAC level acknowledgement of the data packet and transmit Indirectly */
  926:            mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c;     /* Indirect Transfer for RFD device */
  00fb a605     [2]             LDA   #5
  00fd          LFD:    
  00fd 320000   [5]             LDHX  mpGenericPkg
  0100 e719     [3]             STA   25,X
  927:  
  928:          /* Give the data packet a handle. The handle is
  929:             returned in the MCPS-Data Confirm message. */
  930:          mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0102 c60000   [4]             LDA   mMsduHandle
  0105 320000   [5]             LDHX  mpPacket
  0108 e718     [3]             STA   24,X
  010a 4c       [1]             INCA  
  010b c70000   [4]             STA   mMsduHandle
  931:          #ifdef gMAC2006_d
  932:                mpPacket->msgData.dataReq.securityLevel = 0;
  010e 6f1a     [5]             CLR   26,X
  933:          #endif //gMAC2006_d      
  934:          
  935:          /* Send the Data Request to the MCPS */
  936:          (void)MSG_Send(NWK_MCPS, mpPacket);
  0110 ac000000 [8]             CALL  NWK_MCPS_SapHandler
  937:          /* Prepare for another data buffer */
  938:          mpPacket = NULL;
  0114 5f       [1]             CLRX  
  0115 8c       [1]             CLRH  
  0116 960000   [5]             STHX  mpPacket
  939:          mcPendingPackets++;
  0119 450000   [3]             LDHX  @mcPendingPackets
  011c 7c       [4]             INC   ,X
  940:          /* Receive another pressed keys */
  941:          keysReceived = 0;
  011d 4f       [1]             CLRA  
  011e c70000   [4]             STA   keysReceived
  0121 95       [2]             TSX   
  0122 6c03     [5]             INC   3,X
  0124 2602     [3]             BNE   L128 ;abs = 0128
  0126 6c02     [5]             INC   2,X
  0128          L128:   
  0128 320000   [5]             LDHX  AssocDevCounter
  012b 9ef303   [6]             CPHX  3,SP
  012e 2303     [3]             BLS   L133 ;abs = 0133
  0130 cc0042   [4]             JMP   L42 ;abs = 0042
  0133          L133:   
  942:  
  943:  
  944:        }
  945:  
  946:  
  947:    }
  948:    
  949:    /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
  950:    /* try to send it later   */
  951:    if (keysReceived)
  0133 c60000   [4]             LDA   keysReceived
  0136 270a     [3]             BEQ   L142 ;abs = 0142
  952:    {
  953:    TS_SendEvent(gAppTaskID_c, gAppEvtRxFromComm_c);
  0138 c60000   [4]             LDA   gAppTaskID_c
  013b ae02     [2]             LDX   #2
  013d 8c       [1]             CLRH  
  013e ac000000 [8]             CALL  TS_SendEvent
  0142          L142:   
  954:    }
  955:  }
  0142 a704     [2]             AIS   #4
  0144 8d       [7]             RTC   
  0145          L145:   
  0145 89       [2]             PSHX  
  0146 8b       [2]             PSHH  
  0147 450000   [3]             LDHX  @maPanId
  014a a602     [2]             LDA   #2
  014c ac000000 [8]             CALL  FLib_MemCpy
  0150 a702     [2]             AIS   #2
  0152 8d       [7]             RTC   
  956:  
  957:  /*****************************************************************************
  958:  * Function to handle a generic key press. Called for all keys.
  959:  *****************************************************************************/
  960:  static void App_HandleGenericKey(void)
  961:  {
  962:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
  963:    {
  964:      StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
  965:      StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
  966:      StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
  967:      StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
  968:      Led1Off();
  001d 1000     [5]             BSET  0,0
  969:      Led2Off();
  001f 1800     [5]             BSET  4,0
  970:      Led3Off();
  0021 1006     [5]             BSET  0,6
  971:      Led4Off();
  0023 1206     [5]             BSET  1,6
  972:      LCD_ClearDisplay();
  973:      LCD_WriteString(1,"Application");
  974:      LCD_WriteString(2,"    started");     
  975:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
  976:    }
  977:  }
  002f 8d       [7]             RTC   
  978:  
  979:  /*****************************************************************************
  980:  * Handles all key events for this device.
  981:  * Interface assumptions: None
  982:  * Return value: None
  983:  *****************************************************************************/
  984:  #if (gMC1323xMatrixKBD_d == TRUE)
  985:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
  986:  {
  987:   (void)events;
  988:   (void)pressedKey;
  989:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
  990:  }
  0004 8d       [7]             RTC   
  991:  #else
  992:  static void App_HandleKeys(key_event_t events)
  993:  {
  994:    switch ( events ) 
  995:      { 
  996:        case gKBD_EventSW1_c:
  997:        case gKBD_EventSW2_c:
  998:        case gKBD_EventSW3_c:
  999:        case gKBD_EventSW4_c:
 1000:        case gKBD_EventLongSW1_c:
 1001:        case gKBD_EventLongSW2_c:
 1002:        case gKBD_EventLongSW3_c:
 1003:        case gKBD_EventLongSW4_c:
 1004:         App_HandleGenericKey();
 1005:         break;  
 1006:      }    
 1007:  }                                                      
 1008:  #endif //gMC1323xMatrixKBD_d
 1009:  /*****************************************************************************
 1010:  * The DeepSleepWakeupStackProc(void) function is called each time the 
 1011:  * application exits the DeepSleep mode .
 1012:  * 
 1013:  * Return value:
 1014:  *     None
 1015:  *****************************************************************************/
 1016:  void DeepSleepWakeupStackProc(void){
 1017:    return;
 1018:  }
  0000 8d       [7]             RTC   
 1019:  
 1020:  /******************************************************************************
 1021:  * The following functions are called by the MAC to put messages into the
 1022:  * Application's queue. They need to be defined even if they are not used
 1023:  * in order to avoid linker errors.
 1024:  ******************************************************************************/
 1025:  
 1026:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
 1027:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1028:    /* Put the incoming MLME message in the applications input queue. */
 1029:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1030:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1031:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1032:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1033:  
 1034:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
 1035:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1036:    /* Put the incoming MCPS message in the applications input queue. */
 1037:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1038:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1039:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1040:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1041:  
 1042:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
 1043:  {
 1044:    /* If the message is not handled anywhere it must be freed. */
 1045:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
 1046:    return gSuccess_c;
  0004 4f       [1]             CLRA  
 1047:  }
  0005 8d       [7]             RTC   
 1048:  
 1049:  /******************************************************************************/
 1050:  
 1051:  /* NEWCODE: Added function to send package over the air with the active button number */
 1052:  
 1053:  static void genericDataTransfer(uint8_t *ptrPDU, uint8_t lengthPDU, EndDevListItem_t dstDevice ){
 1054:  
 1055:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpGenericPkg == NULL) ) 
  0000 c60000   [4]             LDA   mcPendingPackets
  0003 a102     [2]             CMP   #2
  0005 240e     [3]             BCC   L15 ;abs = 0015
  0007 320000   [5]             LDHX  mpGenericPkg
  000a 2609     [3]             BNE   L15 ;abs = 0015
 1056:    {
 1057:      /* If the maximum number of pending data buffes is below maximum limit 
 1058:         and we do not have a data buffer already then allocate one. */
 1059:      mpGenericPkg = MSG_Alloc(gMaxRxTxDataLength_c);
  000c a69c     [2]             LDA   #-100
  000e ac000000 [8]             CALL  MM_Alloc
  0012 960000   [5]             STHX  mpGenericPkg
  0015          L15:    
 1060:    }
 1061:  
 1062:    if(mpGenericPkg != NULL)
  0015 320000   [5]             LDHX  mpGenericPkg
  0018 2601     [3]             BNE   L1B ;abs = 001b
  001a 8d       [7]             RTC   
  001b          L1B:    
 1063:    {
 1064:      /* get data from serial terminal interface */        
 1065:        mpGenericPkg->msgData.dataReq.pMsdu = (uint8_t*)(&(mpGenericPkg->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  001b af27     [2]             AIX   #39
  001d 9f       [1]             TXA   
  001e 8b       [2]             PSHH  
  001f 320000   [5]             LDHX  mpGenericPkg
  0022 e726     [3]             STA   38,X
  0024 86       [3]             PULA  
  0025 e725     [3]             STA   37,X
 1066:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.pMsdu, (uint8_t*) ptrPDU, 9);
  0027 9ece25   [5]             LDHX  37,X
  002a 89       [2]             PSHX  
  002b 8b       [2]             PSHH  
  002c 9efe13   [5]             LDHX  19,SP
  002f a609     [2]             LDA   #9
  0031 ac000000 [8]             CALL  FLib_MemCpy
  0035 a702     [2]             AIS   #2
 1067:        /* Data was available in the serial terminal interface receive buffer. Now create an
 1068:           MCPS-Data Request message containing the serial terminal interface data. */
 1069:        mpGenericPkg->msgType = gMcpsDataReq_c;
  0037 320000   [5]             LDHX  mpGenericPkg
  003a 7f       [4]             CLR   ,X
 1070:        /* Create the header using coordinator information gained during 
 1071:           the scan procedure. Also use the short address we were assigned
 1072:           by the coordinator during association. */
 1073:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.dstAddr, dstDevice.ShortAddress, 2);
  003b af01     [2]             AIX   #1
  003d 89       [2]             PSHX  
  003e 8b       [2]             PSHH  
  003f 95       [2]             TSX   
  0040 af05     [2]             AIX   #5
  0042 a602     [2]             LDA   #2
  0044 ac000000 [8]             CALL  FLib_MemCpy
  0048 a702     [2]             AIS   #2
 1074:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  004a 320000   [5]             LDHX  mpGenericPkg
  004d af0c     [2]             AIX   #12
  004f 89       [2]             PSHX  
  0050 8b       [2]             PSHH  
  0051 450000   [3]             LDHX  @maShortAddress
  0054 a602     [2]             LDA   #2
  0056 ac000000 [8]             CALL  FLib_MemCpy
  005a a702     [2]             AIS   #2
 1075:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  005c 320000   [5]             LDHX  mpGenericPkg
  005f af09     [2]             AIX   #9
  0061 ac0000a4 [8]             CALL  genericDataTransfer:164
 1076:        FLib_MemCpy(mpGenericPkg->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  0065 320000   [5]             LDHX  mpGenericPkg
  0068 af14     [2]             AIX   #20
  006a ac0000a4 [8]             CALL  genericDataTransfer:164
 1077:        mpGenericPkg->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  006e a602     [2]             LDA   #2
  0070 320000   [5]             LDHX  mpGenericPkg
  0073 e70b     [3]             STA   11,X
 1078:        mpGenericPkg->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  0075 e716     [3]             STA   22,X
 1079:        mpGenericPkg->msgData.dataReq.msduLength = lengthPDU;
  0077 9ee610   [4]             LDA   16,SP
  007a e717     [3]             STA   23,X
 1080:  
 1081:        /* Transfer Options in case of FFD / RFD */
 1082:        if(dstDevice.DeviceType)
  007c 9e6d0f   [5]             TST   15,SP
  007f 2703     [3]             BEQ   L84 ;abs = 0084
 1083:          /* Request MAC level acknowledgement of the data packet */
 1084:          mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c;         /* Direct Transfer for FFD Device */
  0081 a601     [2]             LDA   #1
  0083 65       [3]             SKIP2 L86 ;abs = 0086
  0084          L84:    
 1085:        else
 1086:          /* Request MAC level acknowledgement of the data packet and transmit Indirectly */
 1087:          mpGenericPkg->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c;     /* Indirect Transfer for RFD device */
  0084 a605     [2]             LDA   #5
  0086          L86:    
  0086 e719     [3]             STA   25,X
 1088:  
 1089:        /* Give the data packet a handle. The handle is
 1090:           returned in the MCPS-Data Confirm message. */
 1091:        mpGenericPkg->msgData.dataReq.msduHandle = mMsduHandle++;
  0088 c60000   [4]             LDA   mMsduHandle
  008b 320000   [5]             LDHX  mpGenericPkg
  008e e718     [3]             STA   24,X
  0090 4c       [1]             INCA  
  0091 c70000   [4]             STA   mMsduHandle
 1092:    #ifdef gMAC2006_d
 1093:          mpGenericPkg->msgData.dataReq.securityLevel = 0;
  0094 6f1a     [5]             CLR   26,X
 1094:    #endif //gMAC2006_d      
 1095:        
 1096:        /* Send the Data Request to the MCPS */
 1097:        (void)MSG_Send(NWK_MCPS, mpGenericPkg);
  0096 ac000000 [8]             CALL  NWK_MCPS_SapHandler
 1098:        mcPendingPackets++;
  009a 450000   [3]             LDHX  @mcPendingPackets
  009d 7c       [4]             INC   ,X
 1099:        /* Prepare for another data buffer */
 1100:        mpGenericPkg = NULL;
  009e 5f       [1]             CLRX  
  009f 8c       [1]             CLRH  
  00a0 960000   [5]             STHX  mpGenericPkg
 1101:    }
 1102:  }
  00a3 8d       [7]             RTC   
  00a4          LA4:    
  00a4 89       [2]             PSHX  
  00a5 8b       [2]             PSHH  
  00a6 450000   [3]             LDHX  @maPanId
  00a9 a602     [2]             LDA   #2
  00ab ac000000 [8]             CALL  FLib_MemCpy
  00af a702     [2]             AIS   #2
  00b1 8d       [7]             RTC   
 1103:  
 1104:  /* NEWCODE: Added function to send package over the air with the active button number */
 1105:  
